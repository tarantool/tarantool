<!DOCTYPE chapter [
<!ENTITY % tnt SYSTEM "../tnt.ent">
%tnt;
]>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xml:id="databases">
<title>Databases</title>
<blockquote><para>
  This chapter describes how Tarantool stores 
  values and what operations with data it supports.
</para></blockquote>

<xi:include href="data-model.xml"/>
<xi:include href="persistence-architecture.xml"/>

<section xml:id="data-manipulation">
  <title>Data manipulation</title>

  <para>
    The basic "data-manipulation" requests are:
    <code>insert</code>, <code>replace</code>,
    <code>update</code>, <code>delete</code>, <code>select</code>.
    They all are part of the <code>box</code> library.
    They all may return data.
    Usually both inputs and outputs may be Lua tables.
 </para>
 <para>
   The Lua syntax for data-manipulation functions can vary.
   Here are examples of the variations with <code>select</code> examples;
   the same rules exist for the other data-manipulation functions.
   Every one of the examples does the same thing: select a tuple set
   from a space named tester where the primary-key field value equals 1.
  </para>
  <para>
    First there are "naming variations":
    <orderedlist xml:id="name-syntaxes" xreflabel="name-syntaxes">
      <listitem><para><code>box.space.tester:select{1}</code></para></listitem>
      <listitem><para><code>box.space['tester']:select{1}</code></para></listitem>
      <listitem><para><code>box.space[512]:select{1}</code></para></listitem>
    <listitem><para><code>variable = 'tester'; box.space[variable]:select{1}</code></para></listitem>
   </orderedlist>
   ... There is an assumption that
   the numeric id of 'tester' is 512, which happens to be the
   case in our sandbox example only. Literal values such as
   'tester' may be replaced by variable names.
   Examples and descriptions in this manual have the "box.space.space.tester:" form;
   however, this is a matter of user preference and
   all the variants exist in the wild.
  </para>
  <para>
    Then there are "parameter variations":
    <orderedlist xml:id="parameter-syntaxes" xreflabel="parameter-syntaxes">
      <listitem><para><code>box.space.tester:select{1}</code></para></listitem>
      <listitem><para><code>box.space.tester:select({1})</code></para></listitem>
      <listitem><para><code>box.space.tester:select(1)</code></para></listitem>
      <listitem><para><code>box.space.tester:select({1},{iterator='EQ'})</code></para></listitem>
      <listitem><para><code>variable = 1; box.space.tester:select{variable}</code></para></listitem>
      <listitem><para><code>variable = {1}; box.space.tester:select(variable)</code></para></listitem>
    </orderedlist>
    ... The primary-key value is enclosed in braces, and if it was a
    multi-part primary key then the value would be multi-part,
    for example "...select{1,2,3}". The braces can be enclosed
    inside parentheses -- "...select({...}) -- which is
    optional unless it is necessary to pass something besides
    the primary-key value, as in the fourth example.
    Literal values such as 1 (a scalar value) or {1}
    (a Lua table value) may be replaced by variable names,
    as in examples [5] and [6].
    Although there are special cases where braces can be omitted,
    they are preferable because they signal "Lua table".
    Examples and descriptions in this manual have the "{1}" form; however, this
    too is a matter of user preference and all the variants
    exist in the wild.
  </para>
 
  <para>
    All the data-manipulation functions operate on tuple sets but,
    since primary keys are unique, the number of tuples in the tuple set is always 1.
    The only exception is <code>box.space...select</code>, which may accept either a
    primary-key value or a secondary-key value.
  </para>

</section>

<section xml:id="sp-box-library">
    <title>The <code>box</code> library</title>

    <para>
      As well as executing Lua chunks or defining their own functions,
      users can exploit the Tarantool server's storage functionality
      with the <code>box</code> Lua library.
    </para>

  <para>
  <bridgehead renderas="sect4">Packages of the box library</bridgehead>
  
    The contents of the <code>box</code> library can be inspected at runtime with
    <code>box</code>, with no arguments.
    The packages inside the box library are: schema, box.tuple, box.space, box.index, 
    net.box, box.cfg, box.info, box.slab, box.stat.
    Every package contains one or more Lua functions. A few packages contain members as well as functions.
    The functions allow data definition (create alter drop), data manipulation (insert delete update select replace),
    and introspection (inspecting contents of spaces, accessing server configuration).
    </para>

    <para>
      <table>
      <title xml:id="function-types">Possible types of the values that a function in the box library can return</title>
      <tgroup cols="4" align="left" colsep="1" rowsep="1">
      <thead>
      <row><entry>General type</entry>                   <entry>Specific type</entry><entry>What Lua type() would return</entry>                                         <entry>Example</entry></row>
      </thead>
      <tbody>
      <row><entry xml:id="function-type-number">scalar     </entry><entry>number</entry>      <entry><link xlink:href="http://www.lua.org/pil/2.3.html">"number"</link></entry>   <entry>12345</entry></row>
      <row><entry xml:id="function-type-string">scalar     </entry><entry>string</entry>      <entry><link xlink:href="http://www.lua.org/pil/2.4.html">"string"</link></entry>   <entry>'A B C'</entry></row>
      <row><entry xml:id="function-type-nil">scalar        </entry><entry>nil</entry>         <entry><link xlink:href="http://www.lua.org/pil/2.1.html">"nil"</link></entry>      <entry>nil</entry></row>
      <row><entry xml:id="function-type-lua-table">compound</entry><entry>Lua table</entry>   <entry><link xlink:href="http://www.lua.org/pil/2.5.html">"table"</link></entry>    <entry>table: 0x410f8b10</entry></row>
      <row><entry xml:id="function-type-tuple">compound    </entry><entry>tuple</entry>       <entry><link xlink:href="http://www.lua.org/pil/28.1.html">"Userdata"</link></entry><entry>12345: {'A B C'}</entry></row>
      </tbody>
      </tgroup>                                   
      </table>
    A "number" is ordinarily an unsigned 64-bit integer. Tarantool will store a number
    as a float if the value contains a decimal point. Tarantool can store signed
    numbers, but not in indexed fields.
    </para>
    <para>
    A "nil" type has only one possible value, also called "nil", but often displayed
    as "null". Nils may be compared to values of any types with == (is-equal) or ~=
    (is-not-equal), but other operations will not work. Nils may not be used in Lua tables;
    the workaround is to use
    <link linkend="yaml-null"><code>yaml.NULL</code></link>
    or <link linkend="json-null"><code>json.NULL</code></link>
    or <link linkend="msgpack-null"><code>msgpack.NULL</code></link>.
    </para>
    <para>
      A tuple is returned in YAML format like <code>- [120, 'a', 'b', 'c']</code>.
      A  few functions may return tables with multiple tuples.
      A scalar may be converted to a tuple with only one field.
      A Lua table may contain all of a tuple's fields, but not nil.
      For more tuple examples see <code xlink:href="#box.tuple">box.tuple</code>.
    </para>

    <para>
     <table>
      <title xml:id="complexity-factors">Complexity Factors that may affect data manipulation functions in the box library</title>
      <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <thead>
      <row><entry>Factor</entry><entry>Explanation</entry></row>
      </thead>
      <tbody>
      <row><entry>Index size</entry>     <entry>The number of index keys is the same as the number
                                         of tuples in the data set. For a TREE index, if
                                         there are more keys then the lookup time will be
                                         greater, although of course the effect is not linear.
                                         For a HASH index, if there are more keys then there
                                         is more RAM use, but the number of low-level steps
                                         tends to remain constant.</entry></row>
      <row><entry>Index type</entry>      <entry>Typically a HASH index is faster than a TREE index
                                         if the number of tuples in the tuple set is greater than one.</entry></row>
      <row><entry>Number of indexes accessed</entry><entry>Ordinarily only one index is accessed to retrieve
                                         one tuple. But to update the tuple, there must be
                                         N accesses if the tuple set has N different indexes.</entry></row>
      <row><entry>Number of tuples accessed</entry><entry>A few requests, for example select, can retrieve
                                         multiple tuples. This factor is usually less
                                         important than the others.</entry></row>
      <row><entry>WAL settings</entry>   <entry>The important setting for the write-ahead log is
                                         <olink targetptr="wal_mode"/>.
                                         If the setting causes no writing or delayed writing,
                                         this factor is unimportant. If the settings causes
                                         every data-change request to wait for writing to
                                         finish on a slow device, this factor is more
                                         important than all the others.</entry></row>
      </tbody>
      </tgroup>                                   
      </table>
      In the discussion of each data-manipulation function there will be a note
      about which Complexity Factors might affect the function's resource usage.
     </para>
      
</section>

<section xml:id="sp-box-schema">
     <title>Package <code>box.schema</code></title>
<variablelist xml:id="box.schema" xreflabel="box.schema">
    <para>
      The <code>box.schema</code> package has one data-definition
      function: create_space().
    </para>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.create_space">
             box.schema.create_space(space-name [, {options} ])
            </emphasis>
        </term>
        <listitem>
            <para>
              Create a space.
            </para>
            <para>
              Parameters: <code>space-name</code>, which should not be a number and should not contain special characters;
              <code>options</code>.
            </para>
            <para>
                <table>
                    <title>Options for box.schema.create_space</title>
                    <tgroup cols="4" align="left" colsep="1" rowsep="1">
                      <tbody>
                        <row>
                         <entry>NAME</entry><entry>EFFECT</entry><entry>TYPE</entry><entry>DEFAULT</entry>
                        </row>
                        <row>
                         <entry>temporary</entry><entry>space is temporary</entry><entry>true|false</entry><entry>false</entry>
                        </row>
                        <row>
                         <entry>id</entry><entry>unique identifier</entry><entry>number</entry><entry>last space's id, +1</entry>
                        </row>
                        <row>
                         <entry>enabled</entry><entry>space is enabled</entry><entry>true|false</entry><entry>true</entry>
                        </row>
                        <row>
                         <entry>field_count</entry><entry>fixed field count</entry><entry>number</entry><entry>0 i.e. not fixed</entry>
                        </row>
                        <row>
                         <entry>if_not_exists</entry><entry>no error if duplicate name</entry><entry>true|false</entry><entry>false</entry>
                        </row>
                        <row>
                         <entry>engine</entry><entry>storage package</entry><entry>string</entry><entry>'memtx'</entry>
                        </row>
                        <row>
                         <entry>user</entry><entry>user name</entry><entry>string</entry><entry>current user's name</entry>
                        </row>                        
                      </tbody>
                    </tgroup>
                </table>
            </para>
            <para>
              Returns: (type = tuple) the new space descriptor.
            </para>
            <para>
              Possible errors: If a space with the same name already exists.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>s = box.schema.create_space('space55')</userinput>
---
...
tarantool> <userinput>s = box.schema.create_space('space55', {id = 555, temporary = false})</userinput>
---
- error: Space 'space55' already exists
...
tarantool> <userinput>s = box.schema.create_space('space55', {if_not_exists = true})</userinput>
---
...
</programlisting>
            </para>
            <para>
            <bridgehead renderas="sect4">The Sophia alternative storage engine</bridgehead>
            There are actually two storage engines for Tarantool: memtx (the in-memory storage engine)
            and Sophia (the on-disk storage engine). To specify that the engine should be Sophia,
            add a clause: <code>engine = 'sophia'</code>. The manual concentrates on memtxt because it is
            the default and has been around longer. But Sophia is a working key-value engine and will especially
            appeal to users who like to see data go directly to disk, so that recovery time might be
            shorter and database size might be larger. On the other hand, with Sophia the maximum
            number of indexes is 1, and the maximum number of fields per index is 1.
            For architectural explanations and benchmarks, see sphia.org.
            </para>
        </listitem>
    </varlistentry>


</variablelist>

</section>

<section xml:id="sp-box-space">
    <title>Package <code>box.space</code></title>
<variablelist xml:id="box.space" xreflabel="box.space">
    <para>
      The <code>box.space</code> package has the data-manipulation
      functions <code>select</code>, <code>insert</code>, <code>replace</code>, <code>update</code>,
      <code>delete</code>, <code>get</code>, <code>put</code>.
      It also has members, such as id, and whether or not a space is
      enabled.
      Package source code is available in file <filename
      xlink:href="https://github.com/tarantool/tarantool/blob/master/src/box/lua/box.lua">src/box/lua/box.lua</filename>.
    </para>

    <para>
       A list of all box.space functions follows, then comes a list of all <code>box.space</code> members.
    </para>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.create_index">
             box.space.<replaceable>space-name</replaceable>:create_index(index-name [, {options} ])
            </emphasis>
        </term>
        <listitem>
            <para>
              Create an index. It is mandatory to create an index for a tuple set before trying to
              insert tuples into it, or select tuples from it. The first created index, which will
              be used as the primary-key index, must be unique.
            </para>
            <para>
              Parameters: <code>index-name</code>, which should not be a number and should not contain special characters;
              <code>options</code>.
            </para>
            <para>
                <table>
                    <title>Options for box.space...create_index</title>
                    <tgroup cols="4" align="left" colsep="1" rowsep="1">
                      <tbody>
                        <row>
                         <entry>NAME</entry><entry>EFFECT</entry><entry>TYPE</entry><entry>DEFAULT</entry>
                        </row>
                        <row>
                         <entry>type</entry><entry>type of index</entry><entry>'HASH'|'TREE'|'BITSET'</entry><entry>'TREE'</entry>
                        </row>
                        <row>
                         <entry>id</entry><entry>unique identifier</entry><entry>number</entry><entry>last index's id, +1</entry>
                        </row>
                        <row>
                         <entry>unique</entry><entry>index is unique</entry><entry>true|false</entry><entry>true</entry>
                        </row>
                        <row>
                         <entry>parts</entry><entry>field-numbers + types</entry><entry>{field_no, 'NUM'|STR'}</entry><entry>{1, 'NUM'}</entry>
                        </row>
                      </tbody>
                    </tgroup>
                </table>
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Possible errors: too many parts.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>s = box.space.space55</userinput>
---
...
tarantool> <userinput>s:create_index('primary', {unique = true, parts = {1, 'NUM', 2, 'STR'}})</userinput>
---
...

</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.insert">
             box.space.<replaceable>space-name</replaceable>:insert{<replaceable>field-value [, field-value ...]</replaceable>}
            </emphasis>
        </term>
        <listitem>
            <para>
              Insert a tuple into a space.
            </para>
            <para>
              Parameters: <code>space-name</code>, <code> field-value(s)</code> = fields of the new tuple.
            </para>
            <para>
              Returns: (type = tuple) the inserted tuple.
            </para>
            <para>
              Possible errors: If a tuple with the same primary key already exists, returns ER_TUPLE_FOUND.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.select" xreflabel="box.select">
             box.space.<replaceable>space-name</replaceable>:select{<replaceable>field-value [, field-value ...]</replaceable>}
            </emphasis>
        </term>
        <listitem>
            <para>
                Search for a tuple in the given space.
            </para>
            <para>
                 Parameters: (type = tuple, as a Lua table) <code>field-value(s)</code>&mdash;
                 = values to be matched against the index key, which may be multi-part.
            </para>
            <para>
               Returns: (type = tuple set, as a Lua table) the selected tuple.
            </para>
            <para>
              Complexity Factors: Index size, Index type.
            </para>
            <para>
               Possible Errors: No such space; wrong type.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.tester:insert{101, 'test#1', 'my first tuple'}</userinput>
---
- [101, 'test#1', 'my first tuple']
...
tarantool> <userinput>box.space.tester:select{101}</userinput>
---
- - [101, 'test#1', 'my first tuple']
...
tarantool> <userinput>box.space.tester:insert{105, 'test#2', 'first_name', 'last_name'}</userinput>
---
- [105, 'test#2', 'first_name', 'last_name']
...
tarantool> <userinput>table_of_tuples = box.space.tester:select{105}</userinput>
---
...
tarantool> <userinput>table_of_tuples[1]</userinput>
---
- [105, 'test#2', 'first_name', 'last_name']
...
</programlisting>
            For examples of complex <code>select</code>s, which can return multiple tuples
            via secondary indexes, see the later section <olink targetptr="box.index.iterator">box.space.space-name.index.index-name]:select</olink>.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.get" xreflabel="box.get">
             box.space.<replaceable>space-name</replaceable>:get{<replaceable>field-value [, field-value ...]</replaceable>}
            </emphasis>
        </term>
        <listitem>
            <para>
                Search for a tuple in the given space.
            </para>
            <para>
                 Parameters: (type = tuple, as a Lua table) <code>field-value(s)</code>&mdash;
                 = values to be matched against the index key, which may be multi-part.
            </para>
            <para>
               Returns: (type = tuple) the selected tuple.
            </para>
            <para>
              Complexity Factors: Index size, Index type.
            </para>
            <para>
               Possible Errors: No such space; wrong type.
            </para>
            <para>
               The <code>box.space...select</code> function returns a set of tuples as a Lua
               table; the <code>box.space...get</code> function returns a single tuple.
               And it is possible to get the first tuple in a tuple set by appending "[1]".
               Therefore <code>box.space.tester:get{1}</code> has the same effect as
               <code>box.space.tester:select{1}[1]</code>, and may serve as a convenient
               shorthand.
             </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.drop">
             box.space.<replaceable>space-name</replaceable>:drop()
            </emphasis>
        </term>
        <listitem>
            <para>
              Drop a space.
            </para>
            <para>
              Parameters: none.
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of indexes accessed, WAL settings.
            </para>
            <para>
              Possible errors: If space-name does not exist.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.space_that_does_not_exist:drop()</userinput>
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.rename">
            box.space.<replaceable>space-name</replaceable>:rename(<replaceable>space-name</replaceable>)
            </emphasis>
        </term>
        <listitem>
            <para>
              Rename a space.
            </para>
            <para>
              Parameters: new name for space.
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Possible errors: If space-name does not exist.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.space55:rename('space56')</userinput>
---
...
tarantool> box.space.space56:rename('space55')
---
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.space.alter">
             box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:alter({options})
            </emphasis>
        </term>
        <listitem>
            <para>
              Alter an index.
            </para>
            <para>
              Parameters: <code>options</code> -- see the options list for create_index().
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Possible errors: The first index cannot be changed to {unique = false}.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.space55.index.primary:alter({type = 'HASH'})</userinput>
---
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.space.drop">
             box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:drop()
            </emphasis>
        </term>
        <listitem>
            <para>
              Drop an index.
            </para>
            <para>
              Parameters: none.
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Possible errors: If index-name doesn't exist.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.space55.index.primary:drop()</userinput>
---
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.space.rename">
             box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:rename(index-name)
            </emphasis>
        </term>
        <listitem>
            <para>
              Rename an index.
            </para>
            <para>
              Parameters: new name for index.
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
              Possible errors: If index-name doesn't exist.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.space55.index.primary:rename('secondary')</userinput>
---
...
</programlisting>
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of tuples accessed.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.replace">
            box.space.<replaceable>space-name</replaceable>:replace{<replaceable>field-value [, field-value ...]</replaceable>}
            </emphasis>
            or
            <emphasis role="lua" xml:id="box.put">
            box.space.<replaceable>space-name</replaceable>:put{<replaceable>field-value [, field-value ...]</replaceable>}
           </emphasis>
        </term>
        <listitem>
            <para>
                Insert a tuple into a space. If a tuple with
                the same primary key already exists,
                <code>box.space...:replace()</code> replaces the existing
                tuple with a new one. The syntax variants <code>box.space...:replace()</code>
                and <code>box.space...:put()</code> have the same effect; the latter is sometimes
                 used to show that the effect is the converse of <code>box.space...:get()</code>.
            </para>
            <para>
              Parameters: <code>space-name</code>, <code> field-value(s)</code> = fields of the new tuple.
            </para>
            <para>
            Returns: (type = tuple) the inserted tuple.
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of indexes accessed, WAL settings.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
          <emphasis role="lua" xml:id="box.update">
          box.space.<replaceable>space-name</replaceable>:update{<replaceable>key, format, {field_no, value}...</replaceable>)
          </emphasis>
        </term>
        <listitem>
            <para>
                Update a tuple.
               </para>
  <para>
   The <code>update</code> function supports operations on fields &mdash;
    assignment, arithmetic operations (the field must be numeric),
    cutting and pasting fragments of a field, &mdash; as well as
    operations on a tuple: push and pop of a field at the tail of
    a tuple, deletion and insertion of a field.  Multiple
    operations can be combined into a single update, and in this
    case they are performed atomically. Each operation expects
    field number as its first argument. When a sequence of changes
    is present, field identifier in each operation is assumed to
    be relative to the most recent state of the tuple, i.e. as if
    all previous operations in a multi-operation update have
    already been applied. In other words, it's always safe to
    merge multiple <code>update</code> invocations into a single invocation, with no
    change in semantics.
  </para>
            <para>
             Parameters: <code>space-name</code>,
              <code>key</code> = primary-key field values, must be passed as a Lua table if key is multi-part,
                <code>format</code> = a sequence of
                pairs of characters, where the first character in each pair
                is the operation specifier, and the second character in
                each pair is the operation argument.
                The <code>{field_no, value}</code> arguments are the
                field numbers of affected fields and applicable values.
                For some operations the field number can be -1, meaning
                the last field in the tuple.
                There must be a pair of {field_no, value} arguments
                for each character pair in the format argument.
                The format and {field_no, value} arguments are passed to
                <code>pickle.pack()</code> and the result is sent
                to <code>box.process()</code>.
                Possible operation specifiers are: <quote>+</quote>
                for addition, <quote>-</quote> for subtraction,
                <quote>&amp;</quote> for bitwise AND,
                <quote>|</quote> for bitwise OR, <quote>^</quote>
                for bitwise exclusive OR (XOR), <quote>:</quote>
                for string splice, <quote>!</quote> for insertion.
                Possible operation arguments are: <quote>p</quote>.
                Thus in the instruction <code>s:update{44,, {{'+p,1,55},{=p',3,'x'}})</code>
                the primary-key value is 44,
                the formats are '+p' and '=p'
                meaning "add a value to a field
                and then assign a value to a field", the first affected field
                is field 1 and the value which will be added to it is 55, the second affected field
                is field 3 and the value which will be assigned to it is 'x'.
               </para>
               <para>
               Returns: (type = tuple) the updated tuple.
              </para>
            <para>
              Complexity Factors: Index size, Index type, number of indexes accessed, WAL settings.
            </para>
              <para>
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
#Assume that the initial state of the database is ...
#  tester has one tuple set and one primary key whose type is 'NUM'.
#  There is one tuple, with field[1] = 999 and field[2] = 'A'.

#In the following update ...
#  The first argument is tester, that is, the affected space is tester
#  The second argument is 999, that is, the affected tuple is identified by
#    primary key value = 999
#  The third argument is '=', that is, there is one operation, assignment
#    to a field
#  The fourth argument is 2, that is, the affected field is field[2]
#  The fifth argument is 'B', that is, field[2] contents change to 'B'
#  Therefore, after the following update, field[1] = 999 and field[2] = 'B'.
box.space.tester:update(999, {{'=', 2, 'B'}})

#In the following update, the arguments are the same, except that ...
#  the key is passed as a Lua table (inside braces). This is unnecessary
#  when the primary key has only one field, but would be necessary if the
#  primary key had more than one field.
#  Therefore, after the following update, field[1] = 999 and field[2] = 'B'
#    (no change).
box.space.tester:update({999}, {{'=', 2, 'B'}})

#In the following update, the arguments are the same, except that ...
#   The fourth argument is 3, that is, the affected field is field[3].
#   It is okay that, until now, field[3] has not existed. It gets added.
#   Therefore, after the following update, field[1] = 999, field[2] = 'B',
#     field[3] = 1.
box.space.tester:update({999}, {{'=', 3, 1}})

#In the following update, the arguments are the same, except that ...
#   The third argument is '+', that is, the operation is addition rather
#     than assignment.
#   Since field[3] previously contained 1, this means we're adding 1 to 1.
#   Therefore, after the following update, field[1] = 999, field[2] = 'B',
#     field[3] = 2.
box.space.tester:update({999}, {{'+', 3, 1}})

#In the following update ...
#   The idea is to modify two fields at once.
#   The formats are '|' and '=', that is, there are two operations, OR and
#     assignment.
#   The fourth and fifth arguments mean that field[3] gets ORed with 1.
#   The seventh and eighth arguments mean that field[2] gets assigned 'C'.
#   Therefore, after the following update, field[1] = 999, field[2] = 'C',
#     field[3] = 3.
box.space.tester:update({999}, {{'|', 3, 1}, {'=', 2, 'C'}})

#In the following update ...
#   The idea is to delete field[2], then subtract 3 from field[3], but ...
#   after the delete, there is a renumbering -- so field[3] becomes field[2]
#   before we subtract 3 from it, and that's why the seventh argument is 2 not 3.
#   Therefore, after the following update, field[1] = 999, field[2] = 0.
box.space.tester:update({999}, {{'#', 2, 1}, {'-', 2, 3}})

#In the following update ...
#   We're making a long string so that splice will work in the next example.
#   Therefore, after the following update, field[1] = 999, field[2] = 'XYZ'.
box.space.tester:update({999}, {{'=', 2, 'XYZ'}})

#In the following update ...
#   The third argument is ':', that is, this is the example of splice.
#   The fourth argument is 2 because the change will occur in field[2].
#   The fifth argument is 1 because deletion will begin with the second byte.
#   The sixth argument is 1 because the number of bytes to delete is 1.
#   The seventh argument is '!!' because '!!' is to be added at this position.
#   Therefore, after the following update, field[1] = 999, field[2] = 'X!!Z'.
box.space.tester:update({999}, {{':', 2, 1, 1, '!!'}})

</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="box.delete">
            box.space.<replaceable>space-name</replaceable>:delete{<replaceable>field-value [, field-value ...]</replaceable>}
            </emphasis>
        </term>
        <listitem>
            <para>
              Delete a tuple identified by a primary key.
            </para>
            <para>
              Parameters: <code>space-name</code>, <code>field-value(s)</code> = values to match against keys in the primary index.
            </para>
            <para>
              Returns: (type = tuple) the deleted tuple.
            </para>
            <para>
              Complexity Factors: Index size, Index type
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>box.space.tester:delete(0)</userinput>
---
- [0, 'My first tuple']
...
tarantool> <userinput>box.space.tester:delete(0)</userinput>
---
...
tarantool> <userinput>box.space.tester:delete('a')</userinput>
- error: 'Supplied key type of part 0 does not match index part type:
  expected NUM'
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua">box.space.<replaceable>space-name</replaceable>.id</emphasis></term>
        <listitem>
            <para>
              (type = number) Ordinal space number. Spaces can be referenced by either name or number.
              Thus, if space 'tester' has id = 800, then "box.space.tester:insert{0}" and "box.space[800]:insert{0}"
              are equivalent requests.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>

        <term><emphasis role="lua">box.space.<replaceable>space-name</replaceable>.enabled</emphasis></term>
        <listitem>
            <para>
              (type = boolean) Whether or not this space is enabled.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.field_count</emphasis>
        </term>
        <listitem>
            <para>
             (type = number) The required field count for all tuples in this space.
             The field_count can be set initially with <code>box.schema.create_space<replaceable>... field_count = new-field-count-value ...</replaceable></code>.
             The default value is 0, which means there is no required field count.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index[]</emphasis>
        </term>
        <listitem>
            <para>
              (type = table) A container for all defined indexes. An index is a Lua object
              of type <code xlink:href="#box.index">box.index</code> with
              methods to search tuples and iterate over them in predefined order.
        <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.id,box.space.tester.field_count,box.space.tester.index.primary.type</userinput>
---
- 512
- 0
- HASH
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:len()</emphasis>
        </term>
        <listitem>
            <para>
              Returns: (type = number) number of tuples in the space.
              <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester:len()</userinput>
---
 - 2
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:truncate()</emphasis>
        </term>
        <listitem>
            <para>
              Deletes all tuples.
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of tuples accessed.
            </para>
            <para>
               Returns: nil.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester:truncate()</userinput>
---
...
tarantool&gt; <userinput>box.space.tester:len()</userinput>
---
 - 0
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:pairs()</emphasis>
        </term>
        <listitem>
            <para>
              A helper function to prepare for iterating over all tuples in a space.
            </para>
            <para>
              Returns: (type = function) function which can be used in a for/end loop.
              Within the loop, a value (type = tuple) is returned for each iteration.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting><prompt>tarantool&gt;</prompt> <userinput>s = box.schema.create_space('space33')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>s:create_index('X', {}) -- index 'X' has default parts {1,'NUM'}</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>s:insert{0,'Hello my '}; s:insert{1,'Lua world'}</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>tmp = ''; for k, v in s:pairs() do tmp = tmp .. v[2] end</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>tmp</userinput>
---
- Hello my Lua world
...</programlisting>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="on_replace">
         <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:on_replace(<replaceable>function-name</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Create a "replace trigger". The <code>function-name</code> will be executed whenever a replace() or insert() happens to <code>space-name</code>.
            </para>
            <para>
              Returns: nil.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
              The following series of requests will create a space, create an index,
              create a function which increments a counter, create a trigger,
              do two inserts, drop the space, and display the counter value -- which is 2,
              because the function is executed once after each insert.
<programlisting>s = box.schema.create_space('space53')
s:create_index('primary', {parts = {1, 'NUM'}})
function replace_trigger() replace_counter = replace_counter + 1 end
s:on_replace(replace_trigger)
replace_counter = 0
t = s:insert{1, 'First replace'}
t = s:insert{2, 'Second replace'}
s:drop()
replace_counter</programlisting>
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
         <emphasis role="lua">box.space._schema</emphasis>
        </term>
        <listitem>
            <para>
              _schema is a system tuple set. Its single tuple contains these fields:
              'version', major-version-number, minor-version-number.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
              The following function will display all fields in all tuples of _schema.
<programlisting>
console = require('console'); console.delimiter('!')
function example()
  local ta = {}, i, line
  for k, v in box.space._schema:pairs() do
    i = 1
    line = ''
    while i &lt;= #v do line = line .. v[i] .. ' ' i = i + 1 end
    table.insert(ta, line)
  end
  return ta
end!
console.delimiter('')!</programlisting>
              Here is what example() returns in a typical installation:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>example()</userinput>
---
- - 'cluster 1ec4e1f8-8f1b-4304-bb22-6c47ce0cf9c6 '
- - 'version 1 6 '
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua">box.space._space</emphasis>
        </term>
        <listitem>
            <para>
              _space is a system tuple set. Its tuples contain these fields:
              id, uid, space-name, engine, field_count, temporary.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
              The following function will display all fields in all tuples of _space.
<programlisting>console = require('console'); console.delimiter('!')
function example()
  local ta = {}, i, line
  for k, v in box.space._space:pairs() do
    i = 1
    line = ''
    while i &lt;= #v do line = line .. v[i] .. ' ' i = i + 1 end
    table.insert(ta, line)
  end
  return ta
end!
console.delimiter('')!</programlisting>
              Here is what example() returns in a typical installation:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>example()</userinput>
---
- - '33 0 tester sophia 0  '
  - '272 1 _schema memtx 0 '
  - '280 1 _space memtx 0 '
  - '288 1 _index memtx 0 '
  - '296 1 _func memtx 0 '
  - '304 1 _user memtx 0 '
  - '312 1 _priv memtx 0 '
  - '320 1 _cluster memtx 0 '
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua">box.space._index</emphasis>
        </term>
        <listitem>
            <para>
              _index is a system tuple set. Its tuples contain these fields:
              space-id index-id index-name index-type index-is-unique index-field-count
              [tuple-field-no, tuple-field-type ...].
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
              The following function will display all fields in all tuples of _index.
<programlisting>console = require('console'); console.delimiter('!')
function example()
  local ta = {}, i, line
  for k, v in box.space._index:pairs() do
    i = 1
    line = ''
    while i &lt;= #v do line = line .. v[i] .. ' ' i = i + 1 end
    table.insert(ta, line)
  end
  return ta
end!
console.delimiter('')!</programlisting>
              Here is what example() returns in a typical installation:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>example()</userinput>
---
- - '272 0 primary tree 1 1 0 str '
  - '280 0 primary tree 1 1 0 num '
  - '280 1 owner tree 0 1 1 num '
  - '280 2 name tree 1 1 2 str '
  - '288 0 primary tree 1 2 0 num 1 num '
  - '288 2 name tree 1 2 0 num 2 str '
  - '296 0 primary tree 1 1 0 num '
  - '296 1 owner tree 0 1 1 num '
  - '296 2 name tree 1 1 2 str '
  - '304 0 primary tree 1 1 0 num '
  - '304 2 name tree 1 1 2 str '
  - '312 0 primary tree 1 3 1 num 2 str 3 num '
  - '312 1 owner tree 0 1 1 num '
  - '320 0 primary tree 1 1 0 num '
  - '320 1 uuid tree 1 1 1 str '
...  
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
         <emphasis role="lua">box.space._user</emphasis>
        </term>
        <listitem>
            <para>
             _user is a new system tuple set for support of the authorization feature.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
         <emphasis role="lua">box.space._priv</emphasis>
        </term>
        <listitem>
            <para>
             _priv is a new system tuple set for support of the authorization feature.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
         <emphasis role="lua">box.space._cluster</emphasis>
        </term>
        <listitem>
            <para>
             _cluster is a new system tuple set for support of the replication feature.
            </para>
        </listitem>
    </varlistentry>
    
    
</variablelist>

<bridgehead renderas="sect4">Example showing use of the box.space functions</bridgehead>
<para>
This function will illustrate how to look at all the spaces,
and for each display: approximately
how many tuples it contains, and the first field of its first tuple.
The function uses Tarantool box.space functions len() and pairs().
The iteration through the spaces is coded as a scan of the
_space system tuple set, which contains metadata. The third field in
_space contains the space name, so the key instruction "space_name = v[3]"
means "space_name = the space_name field in the tuple of _space
that we've just fetched with pairs()". The function returns a table.
</para>
<programlisting>
console = require('console'); console.delimiter('!')
function example()
  local tuple_count, space_name, line
  local ta = {}
  for k, v in box.space._space:pairs() do
    space_name = v[3]
    if box.space[space_name].index[0] ~= nil then
      tuple_count = box.space[space_name]:len()
    else
      tuple_count = 0
    end
    line = space_name .. ' tuple_count =' .. tuple_count
    if tuple_count > 0 then
      for k1, v1 in box.space[space_name]:pairs() do
        line = line .. '. first field in first tuple = ' .. v1[1]
        break
      end
    end
    table.insert(ta, line)
  end
  return ta
end!
console.delimiter('')!
</programlisting>
<para>
... And here is what happens when one invokes the function:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>example()</userinput>
---
- - space1 tuple_count =0
  - tester tuple_count =3. first field in first tuple = 1
  - _schema tuple_count =1. first field in first tuple = version
  - _space tuple_count =7. first field in first tuple = 33
  - _index tuple_count =13. first field in first tuple = 272
  - _func tuple_count =0
  - _user tuple_count =2. first field in first tuple = 0
  - _priv tuple_count =0
...
</programlisting>
</para>

</section>

<section xml:id="sp-box-index">
    <title>Package <code >box.index</code></title>
<variablelist xml:id="box.index" xreflabel="box.index">
            <para>
              The <code>box.index</code> package provides read-only access for index definitions and index keys.
              Indexes are contained in <code
              xlink:href="#box.space">box.space.<replaceable>space-name</replaceable>.index</code> array
              within each space object. They provide an API for
              ordered iteration over tuples. This API is a direct
              binding to corresponding methods of index objects of type <code>box.index</code> in the
              storage engine.
            </para>
    <varlistentry>
        <term><emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>.unique</emphasis></term>
        <listitem>
            <para>
              (type = boolean) true if the index is unique.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>.type</emphasis>
        </term>
        <listitem>
            <para>
              (type = string) index type,  'TREE' or 'HASH' or 'BITSET'.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>.key_field</emphasis>
        </term>
        <listitem>
            <para>
              An array describing index key fields.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.primary</userinput>
---
  unique: true
  parts:
    0:
      type: NUM
      fieldno: 1
  id: 0
  type: TREE
  idx: ' index 0'
  etc.
...</programlisting></listitem>
    </varlistentry>

    <varlistentry>
        <term>
             <emphasis role="lua" xml:id="boxindexiterator" xreflabel="box.index.iterator(type, ...)">
            box.space.<replaceable>space-name</replaceable>.index[.<replaceable>index-name</replaceable>]:pairs(<replaceable>bitset-value | field-value..., iterator-type</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
                This method provides iteration support within an
                index. Parameter <code>type</code> is used to
                identify the semantics of iteration. Different
                index types support different iterators. The
                remaining arguments of the function are varying
                and depend on the iteration type. For example,
                a TREE index maintains a strict order of keys and
                can return all tuples in ascending or descending
                order, starting from the specified key. Other
                index types, however, do not support ordering.
            </para>
            <para xml:id="iterator-consistency">
                To understand consistency of tuples
                returned by an iterator, it's essential to know
                the principles of the Tarantool transaction processing
                subsystem.
                An iterator in Tarantool does not own a consistent
                read view. Instead, each procedure is granted exclusive
                access to all tuples and spaces until it
                encounters a "context switch": by causing a write to
                disk, network, or by an explicit call to <emphasis
                role="lua" xlink:href="#fiber.yield">fiber.yield()</emphasis>.
                When the execution flow returns to the yielded
                procedure, the data set could have changed significantly.
                Iteration, resumed after a yield point, does not
                preserve the read view, but continues with the new
                content of the database.
            </para>
            <para>
                Parameters:
                <code>type</code> &mdash; iteration strategy as defined in tables below.
            </para>
            <para>
               Returns: this method returns an iterator closure, i.e.
                    a <code>function</code> which can be used to
                    get the next value on each invocation.
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of tuples accessed.
            </para>
            <para>
               Possible Errors:
                    Selected iteration type is not supported in
                    the subject index type, or supplied parameters
                    do not match iteration type.
            </para>

            <xi:include href="iterator-types.xml"/>

            <para>
                <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput> s = box.schema.create_space('space17')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput> s:create_index('primary', {parts = {1, 'STR', 2, 'STR'}})</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput> s:insert{'C', 'C'}</userinput>
---
- ['C', 'C']
...
<prompt>tarantool&gt;</prompt> <userinput> s:insert{'B', 'A'}</userinput>
---
- ['B', 'A']
...
<prompt>tarantool&gt;</prompt> <userinput> s:insert{'C', '!'}</userinput>
---
- ['C', '!']
...
<prompt>tarantool&gt;</prompt> <userinput> s:insert{'A', 'C'}</userinput>
---
- ['A', 'C']
...
<prompt>tarantool&gt;</prompt> <userinput> console = require('console'); console.delimiter('!')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput> function example()
         &gt;   for _, tuple in
         &gt;   s.index.primary:pairs(nil, {iterator = box.index.ALL}) do
         &gt;     print(tuple)
         &gt;   end
         &gt; end!</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput> console.delimiter('')!</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput> example()</userinput>
['A', 'C']
['B', 'A']
['C', '!']
['C', 'C']
---
...
<prompt>tarantool&gt;</prompt> <userinput>s:drop()</userinput>
---
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
     <term>
             <emphasis role="lua" xml:id="box.index.iterator" xreflabel="box.index.select(type, ...)">
            box.space.<replaceable>space-name</replaceable>[.index.<replaceable>index-name</replaceable>]:select({<replaceable>{fields}, {parameters}]</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
             This is is an alternative to <olink targetptr="box.select">box.space...select()</olink>
             which goes via a particular index and can make use of additional parameters that
             specify the iterator type, and the limit (that is, the maximum number of tuples to
             return) and the offset (that is, which tuple to start with in the list).
            </para>
            <para>
              Returns: (type = tuple set, as a Lua table) the tuple or tuples that match the field values.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
# Create a space named tester.
# Create a unique index 'primary', which won't be needed for this example.
# Create a non-unique index 'secondary' with an index on the second field.
# Insert three tuples, values in field[2] equal to 'X', 'Y', and 'Z'.
# Select all tuples where the secondary index keys are greater than 'X'.
box.schema.create_space('tester')
box.space.tester:create_index('primary', {parts = {1, 'NUM' }})
box.space.tester:create_index('secondary', {type = 'tree', unique = false, parts = {2, 'STR'}})
box.space.tester:insert{1,'X','Row with field[2]=X'}
box.space.tester:insert{2,'Y','Row with field[2]=Y'}
box.space.tester:insert{3,'Z','Row with field[2]=Z'}
box.space.tester.index.secondary:select({'X'}, {iterator = 'GT'})
</programlisting>
The result will be a table of tuples and will look like this:
<programlisting>
---
- - [2, 'Y', 'Row with field[2]=Y']
  - [3, 'Z', 'Row with field[2]=Z']
...
</programlisting>
            </para>
            <para>
            Note: <code>[.index.<replaceable>index-name</replaceable>]</code> is optional. If it is
            omitted, then the assumed index is the first (primary-key) index. Therefore, for
            the example above, <code>box.space.tester:select({1}, {iterator = 'GT'})</code>
            would have returned the same two rows, via the 'primary' index.
            </para>
            <para>
             Note: <code>box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:select(...)[1]</code>.
             can be replaced by <code>box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:get(...)</code>.
             That is, <code>get</code> can be used as a convenient shorthand to get the first
             tuple in the tuple set that would be returned by <code>select</code>.
             However, if there is more than one tuple in the tuple set, then <code>get</code> returns an error.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:min([key])</emphasis>
        </term>
        <listitem>
            <para>
              Find the minimum value in the specified index.
            </para>
            <para>
              Returns: (type = tuple) the tuple for the first key in the index.
            </para>
            <para>
              Complexity Factors: Index size, Index type.
            </para>
            <para>
              Possible errors: index is not of type 'TREE'.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.primary:min()</userinput>
---
- ['Alpha!', 55, 'This is the first tuple!']
...
</programlisting>
        </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:max([key])</emphasis>
        </term>
        <listitem>
            <para>
              Find the maximum value in the specified index.
            </para>
            <para>
              Returns: (type = tuple) the tuple for the last key in the index.
            </para>
            <para>
              Complexity Factors: Index size, Index type.
            </para>
            <para>
              Possible errors: index is not of type 'TREE'.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.primary:max()</userinput>
---
- ['Gamma!', 55, 'This is the third tuple!']
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:random(<replaceable>random-value</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Find a random value in the specified index.
              This method is useful when it's important to get insight
              into data distribution in an index without having to
               iterate over the entire data set.
            </para>
            <para>
              Parameters: <code>random-value</code> = an arbitrary non-negative integer.
            </para>
            <para>
              Returns: (type = tuple) the tuple for the random key in the index.
            </para>
            <para>
              Complexity Factors: Index size, Index type.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.secondary:random(1)</userinput>
---
- ['Beta!', 66, 'This is the second tuple!']
...
</programlisting>
        </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.index.<replaceable>index-name</replaceable>:count(<replaceable>key-value</replaceable>, options)</emphasis>
        </term>
        <listitem>
            <para>
              Iterate over an index, counting the number of tuples which equal the
              provided search criteria.
            </para>
            <para>
              Parameters: <code>key-value</code> = the value which must match the key(s)
              in the specified index. The type may be a list of field-values, or a tuple containing
              only the field-values.
            </para>
            <para>
              Returns: (type = number) the number of matching index keys.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.primary:count(999)</userinput>
---
- 0
...
</programlisting>
<programlisting>tarantool&gt; <userinput>box.space.tester.index.primary:count('Alpha!', { iterator = 'LE' })</userinput>
---
 - 1
...
</programlisting>
        </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua">box.space.<replaceable>space-name</replaceable>.auto_increment{<replaceable>field-value [, field-value ...]</replaceable>}</emphasis>
        </term>
        <listitem>
            <para>
                Insert a new tuple using an auto-increment primary key.
                The space specified by space-name must have a
                NUM primary key index of type TREE.
                The primary-key field will be incremented before the insert.
            </para>
            <para>
               Parameters: <code>space-name</code>, <code>field-value(s)</code> = values for the tuple's fields,
               other than the primary-key field.
            </para>
            <para>
               Returns: (type = tuple) the inserted tuple.
            </para>
            <para>
              Complexity Factors: Index size, Index type, Number of indexes accessed, WAL settings.
            </para>
            <para>
               Possible errors: index has wrong type or primary-key indexed field is not a number.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool> <userinput>box.space.tester:auto_increment{'Fld#1', 'Fld#2'}</userinput>
---
- [1, 'Fld#1', 'Fld#2']
...
tarantool> <userinput>box.space.tester:auto_increment{'Fld#3'}</userinput>
---
- [2, 'Fld#3']
...
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
         <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:inc{<replaceable>field-value [, field-value ...]</replaceable>}</emphasis>
        </term>
        <listitem>
            <para>
                Increments a counter in a tuple whose primary key matches the field-value(s).
                The field following the primary-key fields will be the counter.
                If there is no tuple matching the field-value(s), a new one is inserted
                with initial counter value set to 1.
            </para>
                <para>Parameters: <code>space-name</code>, <code>field-value(s)</code> = values
                which must match the primary key.
            </para>
            <para>
               Returns: (type = number) the new counter value.
            </para>
            <para>
              Complexity Factors: Index size, Index type, WAL settings.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool> <userinput>s = box.schema.create_space('forty_second_space')</userinput>
---
...
tarantool> <userinput>s:create_index('primary', {unique = true, parts = {1, 'NUM', 2, 'STR'}})</userinput>
---
...
tarantool> <userinput>box.space.forty_second_space:inc{1,'a'}</userinput>
---
- 1
...
tarantool> <userinput>box.space.forty_second_space:inc{1,'a'}</userinput>
---
- 2
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
         <emphasis role="lua">box.space.<replaceable>space-name</replaceable>:dec{<replaceable>field-value [, field-value ...]</replaceable>}</emphasis>
        </term>
        <listitem>
            <para>
                Decrements a counter in a tuple whose primary key matches the field-value(s).
                The field following the primary-key fields will be the counter.
                If there is no tuple matching the field-value(s), a new one is not inserted.
                If the counter value drops to zero, the tuple is deleted.
            </para>
            <para>
               Parameters: <code>space-name</code>, <code>field-value(s)</code> = values
               which must match the primary key.
            </para>
            <para>
              Returns: (type = number) the new counter value.
            </para>
            <para>
              Complexity Factors: Index size, Index type, WAL settings.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool> <userinput>s = box.schema.create_space('space19')</userinput>
---
...
tarantool> <userinput>s:create_index('primary', {unique = true, parts = {1, 'NUM', 2, 'STR'}})</userinput>
---
...
tarantool> <userinput>box.space.space19:insert{1,'a',1000}</userinput>
---
- [1, 'a', 1000]
...
tarantool> <userinput>box.space.space19:dec{1,'a'}</userinput>
---
- 999
...
tarantool> <userinput>box.space.space19:dec{1,'a'}</userinput>
---
- 998
... </programlisting>
        </listitem>
    </varlistentry>
</variablelist>

<bridgehead renderas="sect4">Example showing use of the box functions</bridgehead>
<para xml:id="box-function-example" xreflabel="box-function-example">
This example will work with the sandbox configuration described in the preface.
That is, there is a space named tester with a numeric primary key.
The example function will: (1) select a tuple whose key value is 1000;
(2) return an error if the tuple already exists and already has 3 fields;
(3) Insert or replace the tuple with: field[1] = 1000, field[2] = a uuid, field[3] = number of seconds since 1970-01-01;
(4) Get field[3] from what was replaced;
(5) Format the value from field[3] as yyyy-mm-dd hh:mm:ss.ffff;
(6) Return the formatted value.
The function uses Tarantool box functions <code>box.space...select</code>, <code>box.space...replace</code>, <code>fiber.time</code>, <code>uuid.hex()</code>.
The function uses Lua functions
<link xlink:href="http://www.lua.org/pil/22.1.html">os.date()</link>
and <link xlink:href="http://www.lua.org/pil/20.html">string.sub()</link>.
</para>
<programlisting>
console = require('console'); console.delimiter('!')
function example()
  local a, b, c, table_of_selected_tuples, replaced_tuple, time_field
  local formatted_time_field
  local fiber = require('fiber')
  table_of_selected_tuples = box.space.tester:select{1000}
  if table_of_selected_tuples ~= nil then
    if table_of_selected_tuples[1] ~= nil then
      if #table_of_selected_tuples[1] == 3 then
        box.raise(1, 'This tuple already has 3 fields')
      end
    end
  end
  replaced_tuple = box.space.tester:replace
            {1000,  require('uuid').hex(), tostring(fiber.time())}
  time_field = tonumber(replaced_tuple[3])
  formatted_time_field = os.date("%Y-%m-%d %H:%M:%S", time_field)
  c = time_field % 1
  d = string.sub(c, 3, 6)
  formatted_time_field = formatted_time_field .. '.' .. d
  return formatted_time_field
end!
console.delimiter('')!
</programlisting>
<para>
... And here is what happens when one invokes the function:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>box.space.tester:delete(1000)</userinput>
---
- 1000: {'264ee2da03634f24972be76c43808254', '1391037015.6809'}
...
<prompt>tarantool&gt;</prompt> <userinput>example(1000)</userinput>
---
- 2014-01-29 16:11:51.1582
...
<prompt>tarantool&gt;</prompt> <userinput>example(1000)</userinput>
---
- error: 'This tuple already has 3 fields'
...
</programlisting>
</para>

</section>

<section xml:id="sp-error">
    <title>Package <code>box.error</code></title>
<variablelist xml:id="error" xreflabel="error">
    <varlistentry>
        <term>
            <emphasis role="lua">box.error(<replaceable>errcode-number, errtext-string</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
                Raises a client error. The difference between this function
                and the built-in <code>error()</code> function in Lua
                is that when the error reaches the client, its error code
                is preserved, whereas every Lua error is presented to the
                client as <constant>ER_PROC_LUA</constant>. This function
                makes it possible to emulate any kind of native exception,
                such as unique constraint violation, no such space/index,
                etc. A complete list of errors is present in the file <link xlink:href="https://github.com/tarantool/tarantool/blob/master/src/errcode.h"><filename>errcode.h</filename></link>
                in the source tree.
                Lua constants which correspond to Tarantool errors
                are defined as members of <code>box.error</code>. The error
                message can be arbitrary.
                Lua function can use <code>box.error(...)</code> to emulate
                request errors (for example: unique key exception).
                When called without arguments this function re-throws the last
                thrown error.
            </para>
            <para>
              Parameters: <code>errcode-number</code> = number taken from the complete list of errors,
              <code>errtext-string</code> = the message which will accompany the error.
            </para>
            <para>
              Possible errors: whatever is specified in errcode-number.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>tarantool> box.error(box.error,,'Tuple/Key must be MsgPack array')</userinput>
---
- error: Tuple/Key must be MsgPack array
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.error.rethrow()</emphasis>
        </term>
        <listitem>
            <para>
              Rethrow previous error.
             </para>
        </listitem>
     </varlistentry>
</variablelist>
</section>

<section xml:id="sp-box-tuple">
    <title>Package <code>box.tuple</code></title>
<variablelist xml:id="box.tuple" xreflabel="box.tuple">
    <para>The <code>box.tuple</code> package provides read-only access for the <code>box.tuple</code> userdata
    type. It allows, for a single tuple: selective retrieval of the
    field contents, retrieval of information about size,
    iteration over all the fields, and conversion to a Lua table.
    </para>
    <varlistentry>
        <term>
            <emphasis role="lua">box.tuple.new(<replaceable>scalar-value | Lua-table-value</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
                Construct a new tuple from either a scalar or a Lua table.
                Alternatively, one can get new tuples from tarantool's
                SQL-like statements: SELECT, INSERT, UPDATE, REPLACE,
                which can be regarded as statements that do new()
                implicitly.
            </para>
            <para>
               Parameters: <code>scalar-value | Lua-table-value</code> = the value that will become the tuple contents.
            </para>
            <para>
              Returns: (type = tuple) a new tuple.
            </para>
            <para>
              In the following example, x will be a new table object containing one tuple and t will be a new tuple object.
              Saying <code>t</code> returns the entire tuple t.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>x = box.space.tester:insert{33,tonumber('1'),tonumber64('2')}:totable()</userinput>
---
...
tarantool> <userinput>t = box.tuple.new({'abc', 'def', 'ghi', 'abc'})</userinput>
---
...
tarantool> <userinput>t</userinput>
---
- ['abc', 'def', 'ghi', 'abc']
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua"># <replaceable>tuple-value</replaceable></emphasis>
        </term>
        <listitem>
            <para>
                The # operator in Lua means "return count of components".
                So, if t is a tuple instance, <code>#t</code>
                will return the number of
                 fields.
            </para>
            <para>
               Returns: (type = number) number of fields.
            </para>
            <para>
                In the following example, a tuple named t is created
                and then the number of fields in t is returned.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4'})</userinput>
---
...
tarantool&gt; <userinput>#t</userinput>
---
- 4
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua"> <replaceable>tuple-value</replaceable> : bsize()</emphasis>
        </term>
        <listitem>
            <para>
              If t is a tuple instance, <code>t:bsize()</code>
              will return the number of bytes in the tuple.
              It is useful to check this number when making changes to data,
              because there is a fixed maximum: one megabyte.
              Every field has one or more "length" bytes preceding the
              actual contents, so bsize() returns a value which is
              slightly greater than the sum of the lengths of the contents.
            </para>
            <para>
              Returns: (type = number) number of bytes.
            </para>
            <para>
              In the following example, a tuple named t is created
              which has three fields, and for each field it takes one byte
              to store the length and three bytes to store the contents,
              and a bit for overhead, so bsize() returns  3*(1+3)+1.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'aaa','bbb','ccc'})</userinput>
---
...
tarantool&gt; <userinput>t:bsize()</userinput>
---
 - 13
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">[ <replaceable>field-number</replaceable> ]</emphasis>
        </term>
        <listitem>
            <para>
                If t is a tuple instance, <code>t[<replaceable>field-number</replaceable>]</code>
                will return the field numbered <code>field-number</code> in the tuple.
                 The first field is t[1].
            </para>
            <para>
              Returns: (type = scalar) field value.
            </para>                
            <para>
              In the following example, a tuple named t is created
              and then the second field in t is returned.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4'})</userinput>
---
...
tarantool&gt; <userinput>t[2]</userinput>
---
 - Fld#2
...</programlisting>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">find(<replaceable>[field-number,] field-value) or findall([field-number,] field-value</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              If t is a tuple instance, <code>t:find(<replaceable>field-value</replaceable>)</code>
              will return the number of the first field in t that matches the field value), and
              <code>t:findall(<replaceable>field-value [, field-value ...]</replaceable>)</code>
              will return numbers of all fields in t that match the field value. Optionally
              one can put a numeric argument field-number before the search-value to indicate
              <quote>start searching at field number <code>field-number</code>.</quote>
            </para>
            <para>
              Returns: (type = number) the number of the field in the tuple.
            </para>
            <para>
              In the following example, a tuple named t is created
              and then: the number of the first field in t which matches 'a' is returned,
              then the numbers of all the fields in t which match 'a' are returned,
              then the numbers of all the fields in t which match 'a' and are at or after the second field
              are returned.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'a','b','c','a'})</userinput>
---
...
tarantool&gt; <userinput>t:find('a')</userinput>
---
- 1
...
tarantool&gt; <userinput>t:findall('a')</userinput>
---
- 1
- 4
...
tarantool&gt; <userinput>t:findall(2, 'a')</userinput>
---
 - 4
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">transform(<replaceable>start-field-number, fields-to-remove [, field-value ...]</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              If t is a tuple instance, <code>t:transform(<replaceable>start-field-number</replaceable>,<replaceable>fields-to-remove</replaceable>)</code>
              will return a tuple where, starting from field start-field-number, a number of fields (fields-to-remove) are removed.
              Optionally one can add more arguments after fields-to-remove to indicate new values that will replace
              what was removed.
            </para>
            <para>
              Parameters: <code>start-field-number</code> = base 1, may be negative, <code>fields-to-remove</code>, <code>field-values(s)</code>.
            </para>
            <para>
              Returns: (type = tuple) a new tuple.
            </para>
            <para>
              In the following example, a tuple named t is created
              and then, starting from the second field, two fields are removed
              but one new one is added, then the result is returned.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4','Fld#5'})</userinput>
---
...
tarantool&gt; <userinput>t:transform(2,2,'x')</userinput>
---
- ['Fld#1', 'x', 'Fld#4', 'Fld#5']
...</programlisting>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">slice(<replaceable>start-field-number [, end-field-number]</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              If t is a tuple instance, <code>t:slice(<replaceable>n</replaceable>)</code>
              will return all fields starting with field number n, and
              <code>t:slice(<replaceable>n1</replaceable>,<replaceable>n2</replaceable>)</code>
              will return all fields starting with field number n1, but
              stopping <emphasis>before</emphasis> field number n2.
              In the following example, a tuple named t is created
              and then, starting from the second field, fields before the fourth field are selected,
              then the result is returned.
            </para>
            <para>
              Parameters: <code>start-field-number</code> = base 1, may be negative, <code>end-field-number</code> = optional, base 1, negative treated as positive.
            </para>
            <para>
              Returns: (type = scalar) one or more field values.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4','Fld#5'})</userinput>
---
...
tarantool&gt; <userinput>t:slice(2, 4)</userinput>
---
 - Fld#2
 - Fld#3
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">unpack()</emphasis>
        </term>
        <listitem>
            <para>
              If t is a tuple instance, <code>t:unpack(<replaceable>n</replaceable>)</code>
              will return all fields. In effect, <code>unpack()</code> is the same as <code>slice(1, -1)</code>.
            </para>
            <para>
              Returns: (type = scalar) field(s) from the tuple.
            </para>
            <para>
              In the following example, a tuple named t is created
              and then all its fields are selected,
              then the result is returned.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
            <programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4','Fld#5'})</userinput>
---
...
tarantool&gt; <userinput>t:unpack()</userinput>
---
 - Fld#1
 - Fld#2
 - Fld#3
 - Fld#4
 - Fld#5
...</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">pairs()</emphasis>
        </term>
        <listitem>
            <para>
              In Lua, lua-table-value:pairs() is a method which returns: function, lua-table-value, nil.
              Tarantool has extended this so that tuple-value:pairs() returns: function, tuple-value, nil.
              It is useful for Lua iterators, because Lua iterators traverse
              a value's components until an end marker is reached.
            </para>
            <para>
              Returns: (type = function) function, (type = tuple) tuple-value, (type = nil) nil.
            </para>
            <para>
              In the following example, a tuple named t is created
              and then all its fields are selected using a Lua for-end loop.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>t = box.tuple.new({'Fld#1','Fld#2','Fld#3','Fld#4','Fld#5'})</userinput>
---
...
tarantool&gt; <userinput>tmp = ''; for k, v in t:pairs() do tmp = tmp .. v end</userinput>
---
...
tarantool> <userinput>tmp</userinput>
---
- Fld#1Fld#2Fld#3Fld#4Fld#5
...</programlisting>
        </listitem>
    </varlistentry>

</variablelist>

<bridgehead renderas="sect4">Example showing use of the box.tuple functions</bridgehead>
<para>
This function will illustrate how to convert tuples to/from
Lua tables and lists of scalars:
<programlisting>
  scalars to tuple:     tuple = box.tuple.new({scalar1, scalar2, ... scalar_n})
  tuple to Lua table:   lua_table = {tuple:unpack()}
  tuple to scalars:     scalar1, scalar2, ... scalar_n = tuple:unpack()
  Lua table to tuple:   tuple = box.tuple.new(lua_table)
</programlisting>
Then it will find the field that contains 'b',
remove that field from the tuple,
and display how many bytes remain in the tuple.
The function uses Tarantool box.tuple functions new(), unpack(), find(), transform(), bsize().
</para>
<programlisting>
console = require('console'); console.delimiter('!')
function example()
  local tuple1, tuple2, lua_table_1, scalar1, scalar2, scalar3, field_number
  tuple1 = box.tuple.new({'a', 'b', 'c'})
  luatable1 = {tuple1:unpack()}
  scalar1, scalar2, scalar3 = tuple1:unpack()
  tuple2 = box.tuple.new(luatable1)
  field_number = tuple2:find('b')
  tuple2 = tuple2:transform(field_number, 1)
  return 'tuple2 = ' , tuple2 , ' # of bytes = ' , tuple2:bsize()
end!
console.delimiter('')!
</programlisting>
<para>
... And here is what happens when one invokes the function:
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>example()</userinput>
---
- 'tuple2 = '
- ['a', 'c']
- ' # of bytes = '
- 5
...
</programlisting>
</para>

</section>

<!--   end of lib -->


<!--   end of lib -->

<!--   end of lib -->

<section xml:id="sp-box-cfg">
    <title>Packages <code>box.cfg</code>,
    <code>box.info</code>, <code>box.slab</code> and
    <code>box.stat</code>: server introspection</title>

<variablelist>
    <title>Package <code xml:id="box.cfg">box.cfg</code></title>
    <para>
      The box.cfg package is for administrators to specify all the server configuration parameters;
      the full description of the parameters is in section <olink targetptr="configuration-file">Configuration</olink>.
      Use <code>box.cfg</code> without braces to get read-only access to those parameters.
    </para>
    <varlistentry>
        <term><emphasis role="lua">box.cfg</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
tarantool> <userinput>box.cfg</userinput>
---
- too_long_threshold: 0.5
  slab_alloc_factor: 2
  slab_alloc_minimal: 64
  background: false
  slab_alloc_arena: 1
  log_level: 5
  ...
...
</programlisting></listitem>
    </varlistentry>
</variablelist>

<variablelist>
    <title>Package <code>box.info</code></title>
    <para>
        The box.info package provides access to information about
        server variables -- pid, uptime, version and others.
    </para>
    
        <para>
        <emphasis role="strong">recovery_lag</emphasis> holds the
        difference (in seconds) between the current time on the
        machine (wall clock time) and the time stamp of the last
        applied record.  In replication setup, this difference can
        indicate the delay taking place before a change is
        applied to a replica.
      </para>
      <para>
        <emphasis role="strong">recovery_last_update</emphasis> is
        the wall clock time of the last change recorded in the
        write-ahead log. To convert it to human-readable time,
        you can use <command>date -d@<replaceable>1306964594.980</replaceable></command>.
      </para>
      <para>
        <emphasis role="strong">status</emphasis> is
        either "primary" or "replica/&lt;hostname&gt;".
      </para>
      
    <varlistentry>
        <term>
            <emphasis role="lua">box.info()</emphasis>
        </term>
        <listitem>
            <para>
              Since box.info contents are dynamic, it's not
              possible to iterate over keys with the Lua
              <emphasis>pairs()</emphasis> function. For this
              purpose, <emphasis>box.info()</emphasis> builds and
              returns a Lua table with all keys and values provided
              in the package.
            </para>
            <para>
              Returns: (type = Lua table) keys and values in the package.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead><programlisting>
tarantool> <userinput>box.info()</userinput>
---
- version: 1.6.0-819-geefb2d0
  status: primary
  pid: 20978
  lsn: 340
  snapshot_pid: 0
  recovery_last_update: 0
  recovery_lag: 0
  uptime: 16071
  ...
...
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">box.info.status, box.info.pid, box.info.version, ...</emphasis>
        </term>
        <listitem>
        <bridgehead renderas="sect4">Example</bridgehead><programlisting>
tarantool> <userinput>box.info.pid</userinput>
---
- 1747
...
tarantool> <userinput>box.info.logger_pid</userinput>
---
- 1748
...
tarantool> <userinput>box.info.version</userinput>
---
- 1.6.0-819-geefb2d0
...
tarantool> <userinput>box.info.uptime</userinput>
---
- 3672
...
tarantool> <userinput>box.info.status</userinput>
---
 - primary
...
tarantool> <userinput>box.info.recovery_lag</userinput>
---
 - 0.000
...
tarantool> <userinput>box.info.recovery_last_update</userinput>
---
 - 1306964594.980
...
tarantool> <userinput>box.info.snapshot_pid</userinput>
---
 - 0
...
tarantool> <userinput>box.info.build</userinput>
---
- flags: ' -fno-omit-frame-pointer -fno-stack-protector -fexceptions
         -funwind-tables -msse2 -std=gnu99 -Wall -Wextra -Wno-sign-compare
         -Wno-strict-aliasing -fopenmp -pthread'
  target: Linux-x86_64-Debug
  compiler: /usr/bin/cc /usr/bin/c++
  options: cmake . -DCMAKE_INSTALL_PREFIX=/usr/local -DENABLE_STATIC=OFF
    -DENABLE_TRACE=ON -DENABLE_BACKTRACE=ON -DENABLE_CLIENT=true
...
</programlisting>
        </listitem>
    </varlistentry>

</variablelist>

<variablelist>
    <title>Package <code>box.slab</code></title>
    <para>
      The box.slab package provides access to slab allocator statistics.
          The slab
          allocator is the main allocator used to store tuples.
          This can be used to monitor the total memory use and
          memory fragmentation.
    </para>
          <para>
          The display of slabs is broken down by the slab size --
          64-byte, 136-byte, and so on. The example omits the slabs
          which are empty. The example display is saying that:
          there are 16 items stored
          in the 64-byte slab (and 16*64=1024 so
          bytes_used = 1024); there is 1 item
          stored in the 136-byte slab (and
          136*1=136 so bytes_used = 136); the
          arena_used value is the total of all the bytes_used
          values (1024+136 = 1160); the
          arena_size value is the arena_used value
          plus the total of all the bytes_free values
          (1160+4193200+4194088 = 8388448). The
          arena_size and arena_used values are the amount of  
          the % of <olink targetptr="slab_alloc_arena"/> that is
          already distributed to the slab allocator.
        </para>
    <varlistentry>
        <term xml:id="box.slab.info" xreflabel="box.slab.info()">
        <emphasis role="lua">box.slab</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
tarantool&gt; <userinput>box.slab.info().arena_used</userinput>
---
 - 4194304
...
tarantool&gt; <userinput>box.slab.info().arena_size</userinput>
---
 - 104857600
...
tarantool&gt; <userinput>box.slab.info().slabs</userinput>
---
 64
 128
...
tarantool&gt; <userinput>box.slab.info().slabs[64]</userinput>
---
 items: 1
 bytes_used: 160
 item_size: 64
 slabs: 1
 bytes_free: 4194144
...
</programlisting></listitem>
    </varlistentry>
</variablelist>

<variablelist>
     <title>Package <code>box.stat</code></title>
    <para>
      The box.stat package provides access to request
      statistics. Show the average number of requests per second, and the
      total number of requests since startup, broken down by
      request type.
    </para>
    <varlistentry>
        <term xml:id="box.stat" xreflabel="box.stat">
        <emphasis role="lua">box.stat</emphasis></term>
        <listitem><bridgehead renderas="sect4">Example</bridgehead><programlisting>
tarantool> <userinput>box.stat, type(box.stat) -- a virtual table</userinput>
---
- []
- table
...
tarantool> <userinput>box.stat() -- the full contents of the table</userinput>
---
- DELETE:
    total: 48902544
    rps: 147
  SELECT:
    total: 388322317
    rps: 1246
  REPLACE:
    total: 4
    rps: 0
  INSERT:
    total: 48207694
    rps: 139
  CALL:
    total: 8
    rps: 0
  UPDATE:
    total: 743350520
    rps: 1874
...
tarantool> <userinput>box.stat().DELETE -- a selected item of the table</userinput>
---
- total: 33
  rps: 0
...
</programlisting></listitem>
    </varlistentry>
</variablelist>

<para>
    Additional examples can be found in the open source <link
    xlink:href="https://github.com/mailru/tntlua">Lua stored
    procedures repository</link> and in the server test suite.
</para>
</section>

<section xml:id="sp-net-box">
    <title>Package <code>net.box</code> &mdash; working with networked Tarantool peers</title>
    <para>
        The <code>net.box</code> package contains connectors to remote database systems.
        One variant, <code>box.net.sql</code>, is for connecting to MySQL or MariaDB or PostgreSQL
        &mdash; that variant is the subject of the <olink targetptr="plugins"><quote>SQL DBMS plugins</quote></olink> appendix.
        In this section the subject is the built-in variant, <code>box.net</code>.
        This is for connecting to tarantool servers via a network.
    </para>
<variablelist xml:id="net.box">
    <para>
        Call <code>require('net.box')</code> to get a net.box object, which will be called <code>net_box</code>
        for examples in this section.
        Call <code><replaceable>net_box</replaceable>:new()</code> to connect and get a connection object,
        which will be called <code>conn</code> for examples in this section.
        Call the other <code>net.box()</code> routines, passing <code>conn:</code>,
        to execute requests on the remote box.
        Call <code>conn:close</code> to disconnect.
    </para>

    <para>
        All <code>net.box</code> methods are fiber-safe, that is, it is
        safe to share and use the same connection object across
        multiple concurrent fibers. In fact, it's perhaps the
        best programming practice with Tarantool. When multiple
        fibers use the same connection, all requests are pipelined
        through the same network socket, but each fiber gets back a
        correct response. Reducing the number of active sockets
        lowers the overhead of system calls and increases the
        overall server performance. There are, however, cases when
        a single connection is not enough &mdash; for example when it's necessary to
        prioritize requests or to use different authentication ids.
    </para>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="net.box.new">
             conn = <replaceable>net_box</replaceable>:new(<replaceable>host</replaceable>, <replaceable>port</replaceable> [, {<replaceable>other parameter[s]</replaceable>}])</emphasis>
        </term>
        <listitem>
            <para>
                Create a new connection. The connection is
                established on demand, at the time of the first
                request. It is re-established automatically after
                a disconnect.
                The returned <code>conn</code> object supports methods for making remote
                requests, such as select, update or delete.
            </para>
            <para>
               For the local tarantool server there is a pre-created always-established
               connection object named <code><replaceable>net_box</replaceable>.self</code>.
               Its purpose is to make polymorphic use of the
               <code>net.box</code> API easier. Therefore
               <code>conn = <replaceable>net_box</replaceable>:new('localhost', 3301)</code> can
               be replaced by <code>conn = <replaceable>net.box</replaceable>.self</code>.
               However, there is an important difference between the embedded
               connection and a remote one. With the embedded connection,
               requests which do not modify data do not yield. When using
               a remote connection, any request can yield, and local database state may
               have changed by the time it returns.
            </para>
            <para>
             Parameters: <code>host</code>, <code>port</code>, <code>wait_connect</code>, <code>user</code>, <code>password</code>.
            </para>
            <para>
               Returns: (type = userdata) conn object).
            </para>
            <para>
               Examples: <code>conn = net_box:new('localhost', 3301)</code>,
               <code>conn = net_box:new('127.0.0.1', box.cfg.listen, {wait_connect = false, user = 'guest', password = ''})</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.ping">
        conn:ping()</emphasis></term>
        <listitem>
            <para>
                Execute a PING command.
            </para>
            <para>
               Returns: (type = boolean) <code>true</code> on success,
               <code>false</code> on error. Example: <code>net_box.self:ping()</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.close">
        conn:close()</emphasis></term>
        <listitem>
            <para>
            Close a connection.
            </para>
            <para>
              Connection objects are garbage collected just like any other objects
              in Lua, so an explicit destruction is not mandatory.
              However, since <code>close()</code> is a system call, it
              is good programming practice to close a connection
              explicitly when it is no longer needed, to avoid lengthy
              stalls of the garbage collector.
            </para>
            <para>
              Example: <code>conn:close()</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.select">
         conn.space.<replaceable>space-name</replaceable>:select{<replaceable>field-value</replaceable>, ...}</emphasis></term>
        <listitem>
            <para>
              <code>conn.space.<replaceable>space-name</replaceable>:select{...}</code> is the remote-call equivalent of the local call
              <code xlink:href="#box.select">box.space.<replaceable>space-name</replaceable>:select{...}</code>.
              Please note this difference: a local <code>box.space.<replaceable>space-name</replaceable>:select{...}</code> does not yield,
              but a remote <code>conn.space.<replaceable>space-name</replaceable>:select{...}</code> call does yield,
              so local data may change while a remote <code>conn.space.<replaceable>space-name</replaceable>:select{...}</code> is running.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.insert">
         conn.space.<replaceable>space-name</replaceable>:insert{field-value, ...}</emphasis></term>
        <listitem>
            <para>
             <code>conn.space.<replaceable>space-name</replaceable>:insert(...)</code> is the remote-call equivalent of the local call
             <code xlink:href="#box.insert">box.space.<replaceable>space-name</replaceable>:insert(...)</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.replace">
         conn.space.<replaceable>space-name</replaceable>:replace{field-value, ...}</emphasis></term>
        <listitem>
            <para>
              <code>conn.space.<replaceable>space-name</replaceable>:replace(...)</code> is the remote-call equivalent of the local call
              <code xlink:href="#box.replace">box.space.<replaceable>space-name</replaceable>:replace(...)</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.update">
         conn.space.<replaceable>space-name</replaceable>:update(<replaceable>key</replaceable>, <replaceable>format</replaceable>, ...)</emphasis></term>
        <listitem>
            <para>
             <code>conn.space.<replaceable>space-name</replaceable>:update(...)</code> is the remote-call equivalent of the local call
              <code xlink:href="#box.update">box.space.<replaceable>space-name</replaceable>:update(...)</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.delete">
         conn.space.<replaceable>space-name</replaceable>:delete{key}</emphasis></term>
        <listitem>
            <para>
              <code>conn.space.<replaceable>space-name</replaceable>:delete{...}</code> is the remote-call equivalent of the local call
              <code xlink:href="#box.delete">box.space.<replaceable>space-name</replaceable>:delete{...}</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.call">
         conn:call(<replaceable>function-name</replaceable> [, <replaceable>arguments</replaceable>])</emphasis></term>
        <listitem>
            <para>
              <code>conn:call('func', '1', '2', '3')</code> is the remote-call equivalent of <code>func('1', '2', '3')</code>.
              That is, conn:call is a remote stored-procedure call.
            </para>
            <para>
              Example: <code>conn:call('box.space.tester:insert',{2})</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua" xml:id="net.box.timeout">
         conn:timeout(<replaceable>timeout</replaceable>)</emphasis></term>
        <listitem>
            <para>
              <code>timeout(...)</code> is a wrapper which sets a timeout for the request that follows it.
              Example: <code>conn:timeout(0.5).space.tester:update({1}, {{'=', 2, 15}})</code>.
            </para>
            <para>
              All remote calls support execution timeouts.
              Using a wrapper object makes the remote
              connection API compatible with the local one, removing
              the need for a separate <code>timeout</code> argument, which
              the local version would ignore. Once a request is sent,
              it cannot be revoked from the remote server even if
              a timeout expires: the timeout expiration only aborts the
              wait for the remote server response, not the request itself.
            </para>
        </listitem>
    </varlistentry>
</variablelist>

 <bridgehead renderas="sect4">Example showing use of most of the net.box methods</bridgehead>
 <para>
 This example will work with the sandbox configuration described in the preface.
 That is, there is a space named tester with a numeric primary key.
 Assume that the database is nearly empty.
 Assume that the tarantool server is running on localhost 127.0.0.1:3301.
<programlisting>
<prompt>tarantool&gt;</prompt><userinput> box.schema.user.grant('guest', 'read,write,execute', 'universe')</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> console = require('console'); console.delimiter('!')</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> net_box = require('net.box')!</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> function example()</userinput>
<prompt>         &gt;</prompt><userinput> if net_box.self:ping() then</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta, 'self:ping() succeeded')</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta, '  (no surprise -- self connection is pre-established)')</userinput>
<prompt>         &gt;</prompt><userinput> end</userinput>
<prompt>         &gt;</prompt><userinput> if box.cfg.listen == '3301' then</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta,'The local server listen address = 3301')</userinput>
<prompt>         &gt;</prompt><userinput> else</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta, 'The local server listen address is not 3301')</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta, '(  (maybe box.cfg{...listen="3301"...} was not stated)')</userinput>
<prompt>         &gt;</prompt><userinput>   table.insert(ta, '(  (so connect will fail)')</userinput>
<prompt>         &gt;</prompt><userinput> end</userinput>
<prompt>         &gt;</prompt><userinput> conn = net_box:new('127.0.0.1', 3301)</userinput>
<prompt>         &gt;</prompt><userinput> conn.space.tester:delete{800}</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn delete done on tester.')</userinput>
<prompt>         &gt;</prompt><userinput> conn.space.tester:insert{800, 'data'}</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn insert done on tester, index 0')</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, '  primary key value = 800.')</userinput>
<prompt>         &gt;</prompt><userinput> wtuple = conn.space.tester:select{800}</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn select done on tester, index 0')</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, '  number of fields = ' .. #wtuple)</userinput>
<prompt>         &gt;</prompt><userinput> conn.space.tester:delete{800}</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn delete done on tester')</userinput>
<prompt>         &gt;</prompt><userinput> conn.space.tester:replace{800, 'New data', 'Extra data'}</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn:replace done on tester')</userinput>
<prompt>         &gt;</prompt><userinput> conn:timeout(0.5).space.tester:update({800}, {{'=', 2, 'Fld#1'}})</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn update done on tester')</userinput>
<prompt>         &gt;</prompt><userinput> conn:close()</userinput>
<prompt>         &gt;</prompt><userinput> table.insert(ta, 'conn close done')</userinput>
<prompt>         &gt;</prompt><userinput> end!</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> console.delimiter('')!</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> ta = {}</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> example()</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> ta</userinput>
---
- - self:ping() succeeded
  - '  (no surprise -- self connection is pre-established)'
  - The local server listen address = 3301
  - conn delete done on tester.
  - conn insert done on tester, index 0
  - '  primary key value = 800.'
  - conn select done on tester, index 0
  - '  number of fields = 1'
  - conn delete done on tester
  - conn:replace done on tester
  - conn update done on tester
  - conn close done
...
<prompt>tarantool&gt;</prompt><userinput> box.space.tester:select{800} -- Prove that the update succeeded.</userinput>
---
- [800, 'Fld#1', 'Extra data']
...
</programlisting>
</para>
</section>

<section xml:id="sp-shard">
    <title>Package <code>shard</code></title>

<para>
With <link xlink:href="https://en.wikipedia.org/wiki/Sharding">Sharding</link>,
the tuples of a tuple set are distributed
to multiple nodes, with a Tarantool database server on each node. With this arrangement,
each server is handling only a subset of the total data, so larger loads can be
handled by simply adding more computers to a network.
</para>
<para>
The Tarantool shard package has facilities
for creating or redistributing or cleaning up shards, as well as analogues for the
data-manipulation functions of the box library (select, insert, replace, update, delete).
The important new concept is that there must be a function which, given a key value,
returns a Shard Identification Number so that the data-manipulation functions will know
which location is relevant.
In fact there must be two such functions, one for giving Shard Identification Number
according to the current algorithm, and one for giving Shard Identification Number
according to a previous algorithm. The former is called [curr], the latter is called [prev].
When the algorithm has to be changed because new nodes are added or because the load
must be balanced differently, the [curr] function becomes the [prev] function, a
new [curr] function is introduced, and a function named <code>shard.copy()</code> redistributes
all the tuples -- a process called "resharding".
</para>
<para>
The shard package can be installed by
putting a directive at the start of an init.lua file:<programlisting>
require 'shard'</programlisting>which brings in all the required functionality
from a program file named shard.lua.
</para>
<para>
For the original package description in Russian, see
<link xlink:href="https://github.com/tarantool/shard/blob/master/README.md">
https://github.com/tarantool/shard/blob/master/README.md</link>.
</para>
<variablelist>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.schema.config (<replaceable>{ key = value, ... }</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This function configures or reconfigures the shard-host or proxy-host.
        The parameters which are indicated by the "key = value" pairs are:
 <code>
    * shard list - a list of shards and their types (see "List of shards", below)
    * me -   each node has to know "which shard in the list is me?" so this is the node's number in the list
             (or 0 if the shard is a proxy)
    * mode - mode for the current shard (either 'ro' or 'rw')
    * curr - the current function that returns, for a given space and key, the Shard Number.
    * prev - the previous function that returns, for a given space and key, the Shard Number.
</code>
        The function reconfigures only those parameters that are transmitted during the call.
        Other parameters' values remain the same.
        </para>
        <para>
        The SHARD LIST is a Lua table, which is an array of arrays.
        Each entry in the table describes one shard, with the following fields :
<code>
        1. Shard operation mode. Either 'ro' = read only, or 'rw' = read / write.
        2. Shard weight (a number between 0 and 1000 )
        3. Shard connection parameters (the host and port of the node that handles the shard)
        ?. Implicitly, a Shard Number.
</code>
        </para>
        <para>
        Notes:
        1. If there are multiple descriptions of the same shard, only one of them may have shard operation mode = 'rw'.
        2. Operations which modify data must always go to hosts with shard operation mode = 'rw'.
        Operations which do not modify data may go to either 'ro' or 'rw' shards, depending on the semantics of the call.
        </para>
        <para>
        The <code>shard.schema.config()</code> function must be performed on each node,
        before creating a sharded database, and whenever the configuration changes.
        Care must be taken that the nodes' configurations are consistent with each other.
        The administrator is responsible for determining the values that [curr] and [prev]
        functions should return -- a simple example would be "if key is less than a million
        then return Shard Identification Number = 1, else return Shard Identification Number = 2".
        </para>
        <para>
         Given this configuration information, subsequent <code>shard</code> functions will all
        know what to do. Simplifying slightly, a subroutine in the shard functions will:
<programlisting>
Get the space number and the primary-key value from the function's parameters.
Pass the space number and the primary-key value to [curr] or [prev] to get a Shard Identification Number.
If the number is equal to "me", perform the function directly because this is the responsible node.
Otherwise, use the box.net package to pass the function to the host and port of
the node that, according to the Shard List, is responsible for handling this tuple.
</programlisting>
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.copy()</code></emphasis></term>
        <listitem>
        <para>
        This function reads all tuples, if necessary copying them to new shards.
        </para>
        <para>
        Start conditions:
        The 'me' shard, that is, the shard which this node is responsible for, must be marked as 'rw'.
        The 'me' shard must have both a [curr] and a [prev] function.
        </para>
        <para>
        For each space, for each tuple in the space: if the [prev] function says that the
        tuple belongs in the 'me' node, and the [curr] function says that the tuple belongs
        in a different node, then copy it by sending an "insert" request to the different node.
        This is actually an "insert nothrow", that is, an insert without an error message,
        because the insert is simply not performed if the different node already has a tuple
        with the same primary key. The copied tuple is not deleted on the 'me' node at this stage;
        that is a separate job which will be handled by a separate function, <code>shard.cleanup()</code>.
        </para>
        <para>
        The function returns a list of tuples. Each tuple contains two fields:
        1. ID Number of the space which was worked on
        2. Count of tuples which are copied into the space (may be 0)
        </para>
        <para>
        In order to perform resharding, the administrator must:
<code>
* For all hosts ,determine the functions [curr] and [prev]
 * Update the Shard List with shard.config
 * Run shard.copy() on all hosts -- this will find tuples
  on nodes according to [prev], and move them to new nodes
  according to [curr].
* Delete the [prev] function on all shards.
* Run shard.cleanup() on all hosts, to remove outdated data.
</code>
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.cleanup()</code></emphasis></term>
        <listitem>
        <para>
        This function reads all tuples, if necessary deleting tuples which don't fit.
        </para>
        <para>
        Start conditions :
        current shard marked as 'rw' (read/write)
        shard specifies only one function - [curr], not [prev] (that is, resharding mode is disabled)
        </para>
        <para>
        This function goes through all the Tarantool spaces and,
        for each tuple in a space, invokes the [curr] function.
        If the number returned by [curr] is not equal to the actual number that the shard is in (known as [me]),
        the tuple is deleted.
        </para>
        <para>
        The function returns a list of tuples. Each tuple contains two fields :
        1. ID Number of the space which was worked on,
        2. Count of tuples which are deleted from the space.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.select (<replaceable>space, key [, subkey, ...]</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This function performs a query using a key. A key may have multiple fields.
        </para>
        <para>
        If <code>shard.select()</code> is called while a resharding is taking place,
        and the tuple is not found on the node which the [curr] function identifies,
        then the request is forwarded to the node which the [prev] function identifies.
        </para>
        <para>
        Notes:
        if the key is multi-field key then all fields must be present -- sampling multiple nodes with partially-specified keys is not possible.
        </para>
        <para>
        The <code>shard.select()</code> function is the only function which can access hosts that are marked "read only".
        The host selection algorithm ([curr] or [prev]) may choose among multiple possible hosts that all contain
        copies of the specific tuple. Usually the algorithm will choose the shard whose 'weight' field in the shard
        list has the greatest value.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.eselect (<replaceable>mode, space, key [, subkey, ...]</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This function is the same as <code>shard.select()</code> but has an additional parameter, "mode",
        to indicate which hosts it is preferable to sample.
        </para>
        <para>
        The mode parameter can have one of the following values:
        'ro' (means that it is preferable to sample the hosts marked as "read only", but if there are none, then sampling an 'rw' node is okay),
        'rw' (means that it is necessary to sample only the hosts marked as " read-write").
        Thus, "call <code>shard.eselect('ro', ...)</code>" is the same as "call <code>shard.select(...)</code>".
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.insert (<replaceable>space, ...</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This functions inserts a specified tuple into a given space.
        </para>
        <para>
        The essential operation is:
<code>
* The local node -- call it Node#1 -- uses [curr] to determine the shard to go to,
  and sends the request to the different node, call it Node#2.
* Node#1 returns a duplicate-key error if the tuple already exists in its space.
* If there is a [prev] function on the different node, then the different node
  uses [prev] to determine another node to go to, and sends the request to the
  other node, call it Node#3.
* If Node#3 finds the row in its space, then that is an error, which eventually
  gets returned to Node#1 and the user sees a duplicate-key error.
 </code>
        This mechanism is a bit complex, but all the user has to know is:
        if there's a duplicate, even if sharding or resharding is taking place when
        the insert request happens, no problem -- Tarantool will detect the duplicate.
</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code><replaceable>shard.replace (space, ...)</replaceable></code></emphasis></term>
        <listitem>
        <para>
        This function inserts, or possibly replaces, a tuple.
        </para>
        <para>
        The initial part of the operation is the same as for <code>shard.insert()</code>,
        but <code>shard.replace()</code> is simpler because it does not have to search for
        duplicates.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.delete (<replaceable>space, key [, subkey, ...])</replaceable></code></emphasis></term>
        <listitem>
        <para>
        This function deletes a tuple.
        </para>
        <para>
        Control is transferred to the node which is responsible according to [curr].
        That different node will delete the tuple from its own tuple set,
        and also -- if that different node has a [prev] function in its Shard List --
        will pass the delete request on to whatever node the [prev] function identifies.
        </para>
        <para>
        Returns: exists_from_curr or exists_from_prev.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.update (<replaceable>space, key, [subkey, ...] format, ...</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This function updates a tuple.
        </para>
        <para>
        Control is transferred to the node which is responsible according to [curr].
        If the tuple is present on that different node, the tuple is updated
        and the new updated value is returned.
        Otherwise, if that different node has a [prev] function in its Shard List,
        then the request is passed on to whatever node the [prev[ function identifies,
        and that node actually performs an insert(), then returns what looks like
        an updated value.
        </para>
        <para>
        Like <code>shard.insert()</code>, the operations for <code>shard.update()</code> look a bit
        complex. But, again, the user only has to know that the <code>shard</code> package
        has routines which ensure that the result is an updated tuple, even though
        there are several remotely-possible scenarios which must be taken care of.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><code>shard.call (<replaceable>mode, procname, ...</replaceable>)</code></emphasis></term>
        <listitem>
        <para>
        This function calls a remote function.
        </para>
        <para>
        The host which receives <code>shard.call()</code> selects a random node from
        the Shard List -- preferably a read-only node if the mode parameter says 'ro'.
        The remote node will perform the function and return its result to the original
        node, which will return it to the user.
        </para>
        </listitem>
    </varlistentry>
</variablelist>
</section>

<section xml:id="administrative-requests">
  <title>Administrative requests</title>
  <para>To learn which functions are considered to be administrative,
    type <emphasis role="lua">help()</emphasis>.
    A reference description also follows
    below:</para>

  <variablelist>

    <varlistentry>
      <term xml:id="box.snapshot" xreflabel="box.snapshot()">
        <emphasis role="lua">box.snapshot()</emphasis>
      </term>
      <listitem><para>
        Take a snapshot of all data and store it in
        <filename><olink
        targetptr="snap_dir"/>/&lt;latest-lsn&gt;.snap</filename>.
        To take a snapshot, Tarantool first enters the delayed
        garbage collection mode for all data. In this mode,
        tuples which were allocated before the snapshot has
        started are not freed until the snapshot has finished.
        To preserve consistency of the primary key, used to
        iterate over tuples, a copy-on-write technique is employed.
        If the master process changes part of a primary key, 
        the corresponding process page is split, and the snapshot
        process obtains an old copy of the page. Since a
        snapshot is written sequentially, one can expect a very
        high write performance (averaging to 80MB/second on modern
        disks), which means an average database instance gets
        saved in a matter of minutes.  Note, that as long as there
        are any changes to the parent index memory through concurrent
        updates, there are going to be page splits, and therefore
        one needs to have some extra free memory to run this
        command. 10% of <olink targetptr="slab_alloc_arena"/>
        is, on average, sufficient. This statement waits until a
        snapshot is taken and returns operation result. For
        example:
<programlisting>tarantool> <userinput>box.info.version</userinput>
---
- 1.6.0-805-g4a7e71d
...
tarantool> <userinput>box.snapshot()</userinput>
---
- ok
...
tarantool> <userinput>box.snapshot()</userinput>
---
error: can't save snapshot, errno 17 (File exists)
...
</programlisting>
      </para>
      <para>
        Taking a snapshot does not cause the server to start a new
        write-ahead log. Once a snapshot is taken, old WALs can be
        deleted as long as all replicas are up to date. But the
        WAL which was current at the time <emphasis
        role="lua">box.snapshot()</emphasis> started must be
        kept for recovery, since it still contains log records
        written after the start of <emphasis role="lua">
        box.snapshot()</emphasis>.
      </para>
      <para>
        An alternative way to save a snapshot is to send the server
        SIGUSR1 UNIX signal. While this approach could be handy, it
        is not recommended for use in automation: a signal provides no
        way to find out whether the snapshot was taken successfully
        or not.
      </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term xml:id="coredump" xreflabel="coredump()">
        <emphasis role="lua">coredump()</emphasis>
      </term>
      <listitem><para>
        Fork and dump a core. Since Tarantool stores all tuples
        in memory, it can take some time. Mainly useful for
        debugging.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term xml:id="fiber.info" xreflabel="fiber.info">
        <emphasis role="lua">require('fiber').info()</emphasis>
      </term>
      <listitem><para>
        Show all running fibers, with their stack.
        Mainly useful for debugging.
      </para></listitem>
    </varlistentry>

  </variablelist>

</section>

<section xml:id="limitations">

<title>Limitations</title>

<variablelist>

  <varlistentry>
    <term xml:id="limitations-index-field-count" xreflabel="limitations-index-field-count">Number of fields in an index</term>
    <listitem><para>For BITSET indexes, the maximum is 1.
    For TREE indexes, the theoretical maximum is about 4 billion (BOX_FIELD_MAX)
    but the practical maximum is the number of fields in a tuple.
    </para></listitem>
  </varlistentry>
  
  <varlistentry>
    <term xml:id="limitations-index-count" xreflabel="limitations-index-count">Number of indexes in a space</term>
    <listitem><para>10 (BOX_INDEX_MAX).
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="limitations-tuple-field-count" xreflabel="limitations-tuple-field-count">Number of fields in a tuple</term>
    <listitem><para>There is no theoretical maximum.
    The practical maximum is whatever is specified by space.cardinality in the configuration file,
    or the maximum tuple length.
    </para></listitem>
  </varlistentry>
  
  <varlistentry>
    <term xml:id="limitations-space-count" xreflabel="limitations-space-count">Number of spaces</term>
    <listitem><para>65535.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="limitations-connections-count" xreflabel="limitations-connections-count">Number of connections</term>
    <listitem><para>The practical limit is the number of file descriptors that one can set with
    the operating system.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="limitations-slab-alloc-arena-size" xreflabel="limitations-slab-alloc-arena-size">Space size</term>
    <listitem><para>The total maximum size for all spaces is in effect set by the slab_alloc_arena_size
    parameter in the configuration file, which in turn is limited by the total available memory.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="limitations-update-count" xreflabel="limitations-updae-count">Update operations count</term>
    <listitem><para>The maximum number of operations that can be in a single update is 4000 (BOX_UPDATE_OP_CNT_MAX).
    </para></listitem>
  </varlistentry>
  
  <varlistentry>
    <term xml:id="limitations-user-count" xreflabel="limitations-user-count">Number of users</term>
    <listitem><para>32.
    </para></listitem>
  </varlistentry>

</variablelist>
</section>

<section xml:id="multitasking">
<title>Atomic execution</title>

<para>
    In several places it's been noted that Lua processes occur in
    fibers on a single thread. That is why there
    can be a guarantee of execution atomicity. That requires emphasis.
</para>
<bridgehead renderas="sect4">Cooperative multitasking environment</bridgehead>
<para>
    Tarantool core is built around a cooperative multi-tasking
    paradigm: unless a running fiber deliberately yields control
    to some other fiber, it is not preempted.
    <quote>Yield points</quote> are built into all
    calls from Tarantool core to the operating system.
    Any system call which can block is performed in an
    asynchronous manner and the fiber waiting
    on the system call is preempted with a fiber ready to
    run. This model makes all programmatic locks unnecessary:
    cooperative multitasking ensures that there is no concurrency
    around a resource, no race conditions and no memory
    consistency issues.
</para>
<para>
    When requests are small, e.g. simple UPDATE, INSERT, DELETE,
    SELECT, fiber scheduling is fair: it takes only a little time
    to process the request, schedule a disk write, and yield to
    a fiber serving the next client.
</para>
<para>
    A function, however, can perform complex computations,
    or be written in such a way that control is not given away for a
    long time. This can lead to unfair scheduling, when a single
    client throttles the rest of the system, or to apparent stalls
    in request processing.
    Avoiding this situation is the responsibility of the function's
    author. Most of the <code>box</code> calls, such as
    <code>box.space...insert</code>, <code>box.space...update</code>,
    <code>box.space...delete</code> are yield points;
    <code>box.space...select</code>, however, is not.
</para>
<para>
    It should also be noted that, in absence of transactions,
    any yield in a function is a potential change in the
    database state. Effectively, it's only possible
    to have CAS (compare-and-swap) -like atomic stored
    procedures: i.e. functions which select and then modify a record.
    Multiple data change requests always run through a built-in
    yield point.
</para>
<para>
    At this point an objection could arise: "It's good that a single
    data-change request will commit and yield, but surely there are
    times when multiple data-change requests must happen without
    yielding." The standard example is the money-transfer, where
    $1 is withdrawn from account #1 and deposited into account #2.
    If something interrupted after the withdrawal, then the
    institution would be out of balance. For such cases, the
    <code>begin ... commit|rollback</code> block was designed.
</para>
  <variablelist>
    <varlistentry>
      <term xml:id="begin" xreflabel="begin()">
        <emphasis role="lua">box.begin()</emphasis>
      </term>
      <listitem><para>
        From this point, implicit yields are suspended.
        In effect the fiber which executes <code>box.begin()</code>
        is starting an "active multi-request transaction", blocking all
        other fibers until the transaction ends.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term xml:id="commit" xreflabel="commit()">
        <emphasis role="lua">box.commit()</emphasis>
      </term>
      <listitem><para>
        End the currently active transaction, and make
        all its data-change operations permanent.
       </para></listitem>
    </varlistentry>
    
    <varlistentry>
      <term xml:id="rollback" xreflabel="rollback()">
        <emphasis role="lua">box.rollback()</emphasis>
      </term>
      <listitem><para>
        End the currently active transaction, but cancel
        all its data-change operations. An explicit call
        to fiber.yield() will have the same effect.
       </para></listitem>
    </varlistentry>
    
  </variablelist>

<para>
Example:
Assuming that in tuple set 'tester' there are tuples
in which the third field represents a positive dollar amount ...
Start a transaction, withdraw from tuple#1, deposit in tuple#2,
and end the transaction, making its effects permanent.<programlisting>
box.begin()
amount_of_money = 1.00
box.space.tester:update({999}, {{'-', 3, amount_of_money}})
box.space.tester:update({1000}, {{'+', 3, amount_of_money}})
box.commit()</programlisting>
</para>
</section>

<section xml:id="errcode">

<title>List of error codes</title>

<para>In the current version of the binary protocol, error message,
which is normally more descriptive than error code,
is not present in server response. The actual message may contain
a file name, a detailed reason or operating system error code.
All such messages, however, are logged in the error log. 
Below follow only general descriptions
of some popular codes. A complete list of errors can be found in
file <filename xlink:href="https://github.com/tarantool/tarantool/blob/master/src/errcode.h">errcode.h</filename> in the source tree.

</para>
<variablelist>
<title>List of error codes</title>

  <varlistentry>
    <term xml:id="ER_NONMASTER" xreflabel="ER_NONMASTER">ER_NONMASTER</term>
    <listitem><para>Can't modify data on a replication slave.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_ILLEGAL_PARAMS" xreflabel="ER_ILLEGAL_PARAMS">ER_ILLEGAL_PARAMS</term>
    <listitem><para>Illegal parameters. Malformed protocol
    message.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_MEMORY_ISSUE" xreflabel="ER_MEMORY_ISSUE">ER_MEMORY_ISSUE</term>
    <listitem><para>Out of memory: <olink targetptr="slab_alloc_arena"/> limit is reached.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_WAL_IO" xreflabel="ER_WAL_IO">ER_WAL_IO</term>
    <listitem><para>Failed to write to disk. May mean: failed to record a change in
    the write-ahead log. Some sort of disk error.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_KEY_PART_COUNT" xreflabel="ER_KEY_PART_COUNT">ER_KEY_PART_COUNT</term>
    <listitem><para>Key part count is not the same as index part count
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_NO_SUCH_SPACE" xreflabel="ER_NO_SUCH_SPACE">ER_NO_SUCH_SPACE</term>
    <listitem><para>Attempt to access a space that does not exist.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_NO_SUCH_INDEX" xreflabel="ER_NO_SUCH_INDEX">ER_NO_SUCH_INDEX</term>
    <listitem><para>The specified index does not exist for the specified space.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_PROC_LUA" xreflabel="ER_PROC_LUA">ER_PROC_LUA</term>
    <listitem><para>An error inside a Lua procedure.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_FIBER_STACK" xreflabel="ER_FIBER_STACK">ER_FIBER_STACK</term>
    <listitem><para>Recursion limit reached when creating a new fiber. This is
    usually an indicator of a bug in a stored procedure, recursively invoking itself
    ad infinitum.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term xml:id="ER_UPDATE_FIELD" xreflabel="ER_UPDATE_FIELD">ER_UPDATE_FIELD</term>
    <listitem><para>An error occurred during update of a field.
    </para></listitem>
  </varlistentry>

</variablelist>
</section>

<section xml:id="authentication">
<title>Authentication and access control</title>

<para>
Understanding the details of security is primarily an issue for administrators,
but ordinary users should at least skim this section so that they will have an
idea of how Tarantool makes it possible for administrators to prevent
unauthorized access to the database and to certain functions.
</para>


<para>
Briefly: there is a method to guarantee with password checks that users really
are who they say they are ("authentication"). There is a _user space where
user names and password-hashes are stored. There are functions for saying
that certain users are allowed to do certain things ("privileges"). There
is a _priv space where privileges are stored. Whenever a user tries to do
an operation, there is a check whether the user has the privilege to do
the operation ("access control").
</para>

<para>
<bridgehead renderas="sect4">Passwords</bridgehead>
Each user may have a password.
The password is any alphanumeric string.
Administrators should advise users to choose long unobvious passwords,
but it is ultimately up to the users to choose or change
their own passwords.
</para>

<para>
Tarantool passwords are stored in the _user space with a
<link xlink:href="https://en.wikipedia.org/wiki/Cryptographic_hash">Cryptographic hash function</link>
so that, if the password is 'x', the stored hashed-password is a long string like
'lL3OvhkIPOKh+Vn9Avlkx69M/Ck='.
When a client connects to a Tarantool server, the server sends a random
<link xlink:href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">Salt Value</link>
which the client must mix with the hashed-password before sending
to the server.
Thus the original value 'x' is never stored anywhere except in the
user's head, and the hashed value is never passed passed down a
network wire except when mixed with a random salt.
This system prevents malicious onlookers from finding passwords
by snooping in the log files or snooping on the wire.
It is the same system that <link xlink:href="http://dev.mysql.com/doc/refman/4.1/en/password-hashing.html">MySQL introduced several years ago</link>
which has proved adequate for medium-security installations.
Nevertheless administrators should warn users that no system
is foolproof against determined long-term attacks, so passwords
should be guarded and changed occasionally.
</para>

<para>
Notes: To get the hash-password of a string 'X', say <code>box.schema.user.password('X')</code>.
To see more about the details of the algorithm for the purpose of writing a new client application, read 
<link xlink:href="https://github.com/tarantool/tarantool/blob/master/src/scramble.h">the scramble.h header file</link>.
</para>

<para>
<bridgehead renderas="sect4">Users and the _user space</bridgehead>
The fields in the _user space are:
a numeric id, a number, the user name, the type, and the optional password.
</para>

<para>
There are three special users: 'guest', 'admin', and 'public'.
</para>

            <para>
                <table>
                    <title>The system users</title>
                    <tgroup cols="4" align="left" colsep="1" rowsep="1">
                      <tbody>
                        <row>
                         <entry>NAME</entry><entry>ID</entry><entry>TYPE</entry><entry>DESCRIPTION</entry>
                        </row>
                        <row>
                         <entry>guest</entry><entry>0</entry><entry>user</entry><entry>Default when connecting remotely. Usually an untrusted user with few privileges.</entry>
                        </row>
                        <row>
                         <entry>admin</entry><entry>1</entry><entry>user</entry><entry>Default when using sys/tarantool as a console. Usually an administrative user with all privileges.</entry>
                        </row>
                        <row>
                         <entry>public</entry><entry>2</entry><entry>role</entry><entry>Not a user in the usual sense. A role is a container for privileges which can be granted to regular users. </entry>
                        </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

<para>
To select a row from the _user space, use <code>box.select</code>.
For example, here is what happens with a select for user id = 0,
which is the 'guest' user, without a password:
<programlisting><prompt>tarantool&gt;</prompt> box.space._user:select{0}
---
- - [0, 1, 'guest']
...</programlisting></para>

<para>
To change tuples in the user space, do not use ordinary <code>box.space</code> functions
for insert or update or delete -- the _user space is special so
there are special functions which have appropriate error checking.
</para>

<para>
To create a new user, say
<code>box.schema.user.create(<replaceable>user-name</replaceable>)</code>
or
<code>box.schema.user.create(<replaceable>user-name</replaceable>, {password=<replaceable>password</replaceable>})</code>.
</para>

<para>
To change the current user's password, say
<code>box.schema.user.passwd(<replaceable>password</replaceable>)</code>.
</para>

<para>
To drop a user, say
<code>box.schema.user.drop(<replaceable>user-name</replaceable>)</code>.
</para>

<para>
For example, here is a session which creates a new user with
a strong password, selects a tuple in
the _user space, and then drops the user.
<programlisting><prompt>tarantool&gt;</prompt> box.schema.user.create('ElizabethBrowning', {password = 'Iwtso65$SDS?'})
---
...
<prompt>tarantool&gt;</prompt> box.space._user:select{4}
---
- - [4, 1, 'ElizabethBrowning', {'chap-sha1': 'zyy3yArGOQ4T40PnsL6yPGlgYrU='}]
...
<prompt>tarantool&gt;</prompt> box.schema.user.drop('ElizabethBrowning')
---
...</programlisting></para>

<para>
Notes: The maximum number of users is 32.
</para>

<para>
<bridgehead renderas="sect4">Privileges and the _priv space</bridgehead>
The fields in the _priv space are:
the numeric id of the user who gave the privilege ("grantor_id"),
the numeric id of the user who received the privilege ("grantee_id"),
the id of the object,
the type of object -- "space" or "function" or "universe",
the type of operation -- "read" or "write" or "execute" or a combination such as "read,write,execute".
</para>

<para>
The function for granting a privilege is:
<code>box.schema.user.grant(<replaceable>user-name-of-grantee</replaceable>, <replaceable>operation-type</replaceable>, <replaceable>object-type</replaceable>, '<replaceable>>object-name</replaceable>)</code>
or
<code>box.schema.user.grant(<replaceable>user-name-of-grantee</replaceable>, <replaceable>operation-type</replaceable>, 'universe')</code>.
</para>

<para>
The function for revoking a privilege is:
<code>box.schema.user.revoke(<replaceable>user-name-of-grantee</replaceable>, <replaceable>operation-type</replaceable>, <replaceable>object-type</replaceable>, '<replaceable>>object-name</replaceable>)</code>.
</para>

<para>
For example, here is a session where the admin user gave
the guest user the privilege to read from a
space named space55, and then took the privilege away:
<programlisting><prompt>tarantool&gt;</prompt> box.schema.user.grant('guest', 'read', 'space', 'space55')
---
...
<prompt>tarantool&gt;</prompt> box.schema.user.revoke('guest', 'read', 'space', 'space55')
---
...</programlisting></para>

<para>
Notes: Generally privileges are granted or revoked by the owner of the object
(the user who created it), or by the 'admin' user.
Before dropping any objects or users, steps should be taken to ensure
that all their associated privileges have been revoked.
Only the 'admin' user can grant privileges for the 'universe'.
</para>

<para>
<bridgehead renderas="sect4">Functions and the _func space</bridgehead>
The fields in the _func space are:
the numeric function id, a number, and the function name.
</para>

<para>
The _func space does not include the function's body.
One continues to create Lua functions in the usual way,
by saying "<code>function <replaceable>function_name</replaceable> () ... end</code>", without
adding anything in the _func space. The _func space only
exists for storing function tuples so that their names
can be used within grant/revoke functions.
</para>

<para>
The function for creating a _func tuple is:
<code>box.schema.func.create(<replaceable>function-name</replaceable>)</code>.
</para>

<para>
The function for dropping a _func tuple is:
<code>box.schema.func.drop(<replaceable>function-name</replaceable>)</code>.
</para>

<para>
In the following example, a function named 'f7' is created,
then it is put in the _func space, then it is used in a
box.schema.user.grant function, then it is dropped:
<programlisting><prompt>tarantool&gt;</prompt> <userinput>function f7() session.uid() end</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>box.schema.func.create('f7')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>box.schema.user.grant('guest', 'execute', 'function', 'f7')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>box.schema.user.revoke('guest', 'execute', 'function', 'f7')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>box.schema.func.drop('f7')</userinput>
---
...</programlisting></para>

<para>
<bridgehead renderas="sect4">"session=require('session')" and security</bridgehead>

After a connection has taken place, the user has access to a "session" object
which has several functions. The ones which are of interest for security
purposes are:
<programlisting>session.uid()           #returns the id of the current user
session.user()          #returns the name of the current user
session.su(<replaceable>user-name</replaceable>)   #allows changing current user to 'user-name'</programlisting></para>

<para>
If a user types requests directly on the Tarantool server in its interactive mode,
or if a user connects via telnet to the administrative port (using
<olink targetptr="admin_port">admin</olink> instead of listen), then the user by default is 'admin' and has
many privileges. If a user connects from an application program via one of the
<olink targetptr="connectors">connectors</olink>, then the user by default is 'guest' and has few
privileges. Typically an admin user will set up and configure objects, then
grant privileges to appropriate non-admin users. Typically a guest user will
use <code>session.su()</code> to change into a non-generic user to whom admin
has granted more than the default privileges. For example, admin might say:<programlisting>
box.space._user:insert{123456,0,'manager'}
box.schema.user.grant('manager', 'read', 'space', '_space')
box.schema.user.grant('manager', 'read', 'space', 'payroll')</programlisting>
and later a guest user, who wishes to see the payroll, might say:<programlisting>
session = require('session')
session.su('manager')
box.space.payroll:select{'Jones'}</programlisting>
</para>


</section>


</chapter>
<!--
vim: tw=66 syntax=docbk
vim: spell spelllang=en_us
-->
