<!DOCTYPE section [
<!ENTITY % tnt SYSTEM "../tnt.ent">
%tnt;
]>
<section xmlns="http://docbook.org/ns/docbook" version="5.0"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xml:id="stored-procedures">
    <title>Writing and running Lua code</title>

    <para>
      Procedures can be defined and invoked interactively, for example::
      <programlisting><computeroutput>tarantool> <userinput>function f1() return 'hello' end</userinput>
---
...
tarantool> <userinput>f1()</userinput>
---
- hello
...
</computeroutput>
</programlisting>
      In the above example, the requests are being handled in interactive mode
      for evaluation as a chunk of Lua code.
    </para>
    <para>
      Thus, the request "<code>function f1() return 'hello' end</code>"
      causes definition of the Lua function which will be identified as f1().
      Then the request "<code>f1()</code>" causes execution of
      the function. The function returns a string 'hello', which gets displayed.
    </para>
    <para>
      It's possible to execute any chunk of Lua code, not just invoke functions ...
    <programlisting><computeroutput>tarantool> <userinput>1 + 2</userinput>
---
 - 3
...
tarantool> <userinput>'hello' .. ' world' -- '..' means 'concatenate'</userinput>
---
 - hello world
...
</computeroutput></programlisting>
    </para>
    <para>
    Lua functions could also be called at the time of initialization with a script in a
    <olink targetptr="configuration-file">lua-initialization file</olink>.
    An example and discussion of such a script will appear later in section
    <link linkend="sp-expirationd">expirationd</link>.
    </para>
    <para>
      The initialization script can select and modify data.
    </para>
    <para>
     Another common task to perform in the initialization script
     is to start background fibers for data expiration, re-sharding,
     or communication with networked peers.
    </para>
    <para>
      Finally, the script can be used to define Lua <olink
      targetptr="triggers">triggers</olink> invoked on various events
      within the system.
    </para>
    <para>
      There is a single global instance of the Lua interpreter, which is
      shared across all connections. Any request from a client
      is sent
      directly to this interpreter. Any changes of the interpreter
      state, including global variable values, have immediate
      effect on all client connections.
    </para>
    <para>
      However, each connection uses its own Lua
      <emphasis>coroutine</emphasis> &mdash; a mechanism akin to a
      Tarantool <emphasis>fiber</emphasis>. A coroutine has its
      own execution stack and its own set of local variables and
      definitions, as described in the 
      <link xlink:href="http://www.lua.org/pil/6.1.html">
      <emphasis>closure</emphasis> section</link> of the Lua manual. 
    </para>
    <para>
      In addition to conventional method invocation,
      Lua provides object-oriented syntax. Typically this involves
      the format <computeroutput><replaceable>object-specifier</replaceable>:<replaceable>function-name ...</replaceable></computeroutput>,
      where object-specifier is acquired as the result of another function invocation,
      or is the full <replaceable>library-name.package-name.object-name</replaceable>,
      or is the full <replaceable>library-name.package-name['object-name']</replaceable>,
      or is the full <replaceable>library-name.package-name[object-numeric-id]</replaceable>.
      The following example shows all four forms of object-specifier:
<programlisting>
tarantool> <userinput>s = box.schema.create_space('name_of_space', {id = 33})</userinput>
---
...
tarantool> <userinput>i = s:create_index('name_of_index', {type = 'tree', parts = {1, 'STR'}})</userinput>
---
...
tarantool> <userinput>s:insert{'a', 'b', 'c'}</userinput>
---
- ['a', 'b', 'c']
...
tarantool> <userinput>box.space.name_of_space:insert{'c', 'd', 'e'}</userinput>
---
- ['c', 'd', 'e']
...
tarantool> <userinput>box.space['name_of_space']:insert{'x', 'y', 'z'}</userinput>
---
- ['x', 'y', 'z']
...
</programlisting>
    </para>
    <para>
      When a function in Lua terminates with an error, the error
      is sent to the client as <olink targetptr="ER_PROC_LUA" />
      return code, along with the original error message.
      Similarly, an error which has occurred inside Tarantool (observed on the
      client as an error code), when it happens during execution of a
      Lua procedure, produces a genuine Lua error:
<programlisting><computeroutput>tarantool> <userinput>function f()error('!') end</userinput>
---
...
tarantool> <userinput>f()</userinput>
- error: '[string "function f()error(''!'') end"]:1: !'
tarantool> <userinput>s:insert{5}</userinput>
---
- error: 'Tuple field 1 type does not match one required by operation:
  expected STR'
...
tarantool> <userinput>function insert_without_colon(tuple) s:insert(tuple) end</userinput>
---
...
tarantool> <userinput>pcall(insert_without_colon,{0, 'b', 'c'})</userinput>
---
- false
- 'Tuple field 1 type does not match one required by operation: expected STR'
tarantool> <userinput>box.space[33]:drop()</userinput>
---
...
</computeroutput></programlisting>
    </para>
    
<para>
<bridgehead renderas="sect4">The "Batteries Included" Lua Software Distribution</bridgehead>
Tarantool incorporates open-source
precompiled packages which Tarantool's developers
have tested for compatibility -- the "built-in" packages.
Tarantool specializes in packages which aid
database applications or which Tarantool's own developers
use to make database-related tools.
At the same time.
Tarantool makes it easy to add new Lua packages
from <link xlink:href=" http://luarocks.org/">LuaRocks</link> -- the "downloadable" packages.
</para>

<para>
The included language processor is <link xlink:href="http://luajit.org/">LuaJIT</link>.
Major "built-in" components are: fibers,
<link xlink:href="http://msgpack.org">MsgPack</link>,
digest, JSON, <link xlink:href="http://en.wikipedia.org/wiki/Yaml">YAML</link>,
<link xlink:href="http://en.wikipedia.org/wiki/Inter-process_communication">IPC</link>,
fio, and box.
</para>

<para>
<emphasis>LuaJIT</emphasis> is a processor for the entire Lua language. 
This differs from the original Lua interpreter from
<link xlink:href="http://www.puc-rio.br/index.html">Pontifícia Universidade Católica do Rio de Janeiro</link>
("RIO-PUC" <link xlink:href="http://www.lua.org/">Lua</link>) 
because the JIT stands for "Just In Time" compiling, that
is, it can compile some Lua code into machine executable form the
after a few executions of the code.
The result is that some
loops will run as quickly as an equivalent C program.
Also some precompiled C code can be brought in using
LuaJIT's FFI (<link xlink:href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign Function Interface</link>).
Examples for using FFI exist on the Internet, for example 
<link xlink:href="https://github.com/tarantool/tarantool/blob/master/src/box/lua/tuple.lua">tuple.lua</link> on the tarantool.org site.
</para>

<para>
LuaJIT has been compared to competitive implementations
and found to be reliable and efficient,
provided one takes advantage of it where <link xlink:href="http://wiki.luajit.org/Numerical-Computing-Performance-Guide">performance</link> counts. 
</para>

    <para>
        Apart from increased performance, LuaJIT provides such
        features as <link
        xlink:href="http://bitop.luajit.org/">bitwise
        operations</link> and <link xlink:href="#tonumber64">64-bit integer arithmetic.</link>
    </para>

<para>
<emphasis>Fibers</emphasis> are like Lua coroutines, but as <link xlink:href="http://members.chello.nl/~w.couwenberg/fibers.htm">one fiber developer</link>
put it: "The main difference between a coroutine and a fiber
is that a running fiber can be suspended anywhere in a call
chain, regardless of its C and Lua call stack nesting levels."       
</para>

<para>
<emphasis>MsgPack</emphasis> is a relatively new way to serialize data.                    
The point of MsgPack is that it can
handle Lua types and C types, with structures and nesting,
without the overhead of an SGML-style markup language.
</para>

<para>
<emphasis>Digest</emphasis> is a cryptography package for CRC32, SHA, and MDA.
Nothing new here -- except that Tarantool has made them into a
package, so that one doesn't have to get each one of these
things individually from the <link xlink:href="http://lua-users.org/wiki/CryptographyStuff">many that are available</link>.
And, since Tarantool is binding with FFI rather than a traditional Lua C
API, the routines should run faster on LuaJIT.
</para>

<para>
<emphasis>JSON</emphasis> is a serialization format which has
become popular in the web world. The package within
Tarantool is derived from <link xlink:href="http://www.kyne.com.au/~mark/software/lua-cjson-manual.html">CJSON</link>
which, according to <link xlink:href="http://lua-users.org/wiki/JsonModules">a survey</link>, 
handles Unicode surrogate pairs and is robust when
edge cases come up.
</para>

<para>
<emphasis>YAML</emphasis> is short for "YAML Ain't a Markup Language". YAML is a            
way to show data in human-readable form, without losing
underlying information about typing, arrays, and structures.
</para>

<para>
<emphasis>IPC</emphasis> is Inter-Process Communication.
This is useful for implementations of task queues and long polling.
</para>

<para>
<emphasis>Fio</emphasis> is standard file IO,
adapted to work with Tarantool's fibers in a cooperative environment.
</para>

<para>
<emphasis>Box</emphasis> is the NoSQL DBMS that was developed by Tarantool
and its community. Box's architecture and routines will be the
subject of the next chapter.
</para>

<para>
<bridgehead renderas="sect4">The Downloadable Packages</bridgehead>
A directory of Lua Addons packages can be found on the <link xlink:href="http://lua-users.org/wiki/LuaAddons">Lua-users</link> wiki. 
For a "managed package" system equivalent to Perl's CPAN and Ruby's RubyGems and Python's
Eggs, one gets "rocks" (modules or packages) from <emphasis>LuaRocks</emphasis>.
Either way, the installation requirement can be as simple as saying
require('package-name')
and the effect is a simple Lua table containing 
functions and members, superficially like C/Java classes.
</para>

<para>
There are <link xlink:href="https://rocks.moonscript.org/modules">several hundred LuaRocks packages</link> that are not built-in       
but are reasonably easy to obtain by anyone with an Internet
connection. Just as a sampling: ...
<link xlink:href="https://rocks.moonscript.org/modules/kikito/ansicolors">ansicolors</link> for color manipulation,
<link xlink:href="https://rocks.moonscript.org/modules/luarocks/htmlparser">htmlparser</link> for changing HTML text into a tree of elements,
<link xlink:href="https://rocks.moonscript.org/modules/kikito/i18n">i18n</link> an internationalization library,
<link xlink:href="https://rocks.moonscript.org/modules/luarocks/lposix">lposix</link> a POSIX library,
<link xlink:href="https://rocks.moonscript.org/modules/luarocks/lua-spore">lua-Spore</link> a generic ReST client,
<link xlink:href="https://rocks.moonscript.org/modules/luarocks/tekui">TekUI</link> a GUI toolkit.
For example, to bring in the i18n package: install luarocks, say <code>luarocks install i18n</code>,
start Tarantool, and say <code>require('i18n')</code>.
</para>

<para>
The rest of this chapter is a reference that has what's needed for programming and
administration with the built-in packages.
</para>


<section xml:id="sp-digest">
    <title>Package <code>digest</code></title>
    <para>
    A "digest" is a value which is returned by a

    <link xlink:href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Cryptographic hash function</link>
    applied against a string.
    Tarantool supports five types of cryptographic hash functions
    (<link xlink:href="https://en.wikipedia.org/wiki/Md4">MD4</link>,
    <link xlink:href="https://en.wikipedia.org/wiki/Md5">MD5</link>,
    <link xlink:href="https://en.wikipedia.org/wiki/Sha-0">SHA-0</link>,
    
    <link xlink:href="https://en.wikipedia.org/wiki/Sha-1">SHA-1</link>,
    <link xlink:href="https://en.wikipedia.org/wiki/Sha-2">SHA-2</link>)

    as well as a checksum function
    (<link xlink:href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC32</link>)
    and two functions for <link xlink:href="https://en.wikipedia.org/wiki/Base64">base64</link>.
    The functions in <code>digest</code> are:
    <informaltable>
    <tgroup cols="2" align="left" colsep="1" rowsep="0">
     <thead>
      <row><entry>name</entry><entry>effect</entry></row>
     </thead>
    <tbody>
    <row><entry><code>digest.crc32(<replaceable>string</replaceable>)</code></entry><entry>                  Returns 32-bit checksum made with CRC32.</entry></row>
    <row><entry><code>digest.crc32_update(<replaceable>number</replaceable>,<replaceable>string</replaceable>)</code></entry><entry>    Returns update of a checksum calculated with crc32.</entry></row>
    <row><entry><code>digest.sha(<replaceable>string</replaceable>)</code></entry><entry>                    Returns 160-bit digest made with SHA-0. Not recommended.</entry></row>
    <row><entry><code>digest.sha_hex(<replaceable>string</replaceable>)</code></entry><entry>                Returns hexadecimal of a digest calculated with sha.</entry></row>
    <row><entry><code>digest.sha1(<replaceable>string</replaceable>)</code></entry><entry>                   Returns 160-bit digest made with SHA-1.</entry></row>
    <row><entry><code>digest.sha1_hex(<replaceable>string</replaceable>)</code></entry><entry>               Returns hexadecimal of a digest calculated with sha1.</entry></row>
    <row><entry><code>digest.sha224(<replaceable>string</replaceable>)</code></entry><entry>                 Returns 224-bit digest made with SHA-2.</entry></row>
    <row><entry><code>digest.sha224_hex(<replaceable>string</replaceable>)</code></entry><entry>             Returns hexadecimal of a digest calculated with sha224.</entry></row>
    <row><entry><code>digest.sha256(<replaceable>string</replaceable>)</code></entry><entry>                 Returns 256-bit digest made with SHA-2.</entry></row>
    <row><entry><code>digest.sha256_hex(<replaceable>string</replaceable>)</code></entry><entry>             Returns hexadecimal of a digest calculated with sha256.</entry></row>
    <row><entry><code>digest.sha384(<replaceable>string</replaceable>)</code></entry><entry>                 Returns 384-bit digest made with SHA-2.</entry></row>
    <row><entry><code>digest.sha384_hex(<replaceable>string</replaceable>)</code></entry><entry>             Returns hexadecimal of a digest calculated with sha384.</entry></row>
    <row><entry><code>digest.sha512(<replaceable>string</replaceable>)</code></entry><entry>                 Returns 512-bit digest made with SHA-2.</entry></row>
    <row><entry><code>digest.sha512_hex(<replaceable>string</replaceable>)</code></entry><entry>             Returns hexadecimal of a digest calculated with sha512.</entry></row>
    <row><entry><code>digest.md4(<replaceable>string</replaceable>)</code></entry><entry>                    Returns 128-bit digest made with MD4.</entry></row>
    <row><entry><code>digest.md4_hex(<replaceable>string</replaceable>)</code></entry><entry>                Returns hexadecimal of a digest calculated with md4.</entry></row>
    <row><entry><code>digest.md5(<replaceable>string</replaceable>)</code></entry><entry>                    Returns 256-bit digest made with MD5.</entry></row>
    <row><entry><code>digest.md5_hex(<replaceable>string</replaceable>)</code></entry><entry>                Returns hexadecimal of a digest calculated with md5.</entry></row>
    <row><entry><code>digest.base64_encode(<replaceable>string</replaceable>)</code></entry><entry>          Returns base64 encoding from a regular string.</entry></row>
    <row><entry><code>digest.base64_decode(<replaceable>string</replaceable>)</code></entry><entry>          Returns a regular string from a base64 encoding.</entry></row>
    </tbody>
    </tgroup>                                   
    </informaltable>

   </para>
<bridgehead renderas="sect4">Example</bridgehead>
    <para>
    In the following example, the user creates two functions, password_insert() 
    which inserts a SHA-1 digest of the word "^S^e^c^ret Wordpass" into a tuple set,
    and password_check() which requires input of a password.<programlisting>
<prompt>localhost&gt;</prompt> <userinput>digest = require('digest')</userinput>
<prompt>localhost&gt;</prompt> <userinput>console = require('console'); console.delimiter('!') --this means ignore line feeds until next '!'</userinput>
<prompt>localhost&gt;</prompt> <userinput>function password_insert()</userinput>
        <prompt>-&gt;</prompt> <userinput>  box.space.tester:insert{12345,digest.sha1('^S^e^c^ret Wordpass')}</userinput>
        <prompt>-&gt;</prompt> <userinput>  return 'OK'</userinput>
        <prompt>-&gt;</prompt> <userinput>  end!</userinput>
---
...
<prompt>localhost&gt;</prompt> <userinput>function password_check(password)</userinput>
        <prompt>-&gt;</prompt>  <userinput> local t</userinput>
        <prompt>-&gt;</prompt>  <userinput> t=box.space.tester:select{12345}</userinput>
        <prompt>-&gt;</prompt>  <userinput> if (digest.sha1(password)==t[2]) then</userinput>
        <prompt>-&gt;</prompt>  <userinput>   print('Password is valid')</userinput>
        <prompt>-&gt;</prompt>  <userinput>   else</userinput>
        <prompt>-&gt;</prompt>  <userinput>     print('Password is not valid')</userinput>
        <prompt>-&gt;</prompt>  <userinput>   end</userinput>
        <prompt>-&gt;</prompt> <userinput>end!</userinput>
---
...
<prompt>localhost&gt;</prompt> <userinput>password_insert()!</userinput>
Call OK, 1 rows affected
['OK']
<prompt>localhost></prompt> <userinput>console.delimiter('') --  back to normal: commands end with line feed!</userinput>
</programlisting></para>
<para>
  If a later user calls
  the password_check() function and enters the wrong password, the result is an
  error.<programlisting><prompt>localhost&gt;</prompt> <userinput>password_check ('Secret Password')</userinput>
---
Password is not valid
...</programlisting></para>
</section>

<section xml:id="sp-box-uuid">
    <title>Package <code>uuid</code></title>

<para>
  A "UUID" is a 
  <link xlink:href="https://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</link>.
  If an application requires that a value be unique only within a single computer or
  on a single database, then a simple counter is better than a UUID, because getting
  a UUID is time-consuming (it requires a
  <link xlink:href="https://en.wikipedia.org/wiki/Syscall">syscall</link>).
  For clusters of computers, or widely distributed applications, UUIDs are better.
</para>
<para>
  The functions that can return a UUID are: <code>uuid()</code>, <code>uuid.bin()</code>, <code>uuid.str()</code>.
  The functions that can convert between different types of UUID are: <code>:bin()</code>, <code>:str()</code>, <code>uuid.fromstr()</code>, <code>uuid.frombin()</code>.
  The function that can determine whether a UUID is an all-zero value is: <code>:isnil()</code>.
</para>

<variablelist xml:id="x-uuid" xreflabel="x-uuid">

    <varlistentry>
        <term>
            <emphasis role="lua">uuid()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: a UUID with type = cdata.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">uuid.bin()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: a UUID with type = 16-byte binary string.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">uuid.str()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: a UUID with type = 36-byte hexadecimal string.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua"><replaceable>uuid_with_type_cdata</replaceable>:bin([<replaceable>byte-order</replaceable>])</emphasis>
        </term>
        <listitem>
            <para>
                Parameters: byte-order can be 'l' (little-endian), 'b' (big-endian), 'h' (endianness depends on host) (default), or 'n' (endianness depends on network).
            </para>         
            <para>
                Returns: UUID with type = 16-byte binary string converted from cdata input value.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">  <replaceable>uuid_with_type_cdata</replaceable>:str()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: UUID with type = 36-byte hexadecimal string converted from cdata input value.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">  uuid.fromstr(<replaceable>uuid_with_type_string</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
                Returns: UUID with type = cdata converted from 36-byte hexadecimal string input value.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">uuid.frombin(<replaceable>uuid_with_type_binary_string</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
                Returns: UUID with type = cdata converted from 16-byte binary string input value.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua"><replaceable>uuid_with_type_cdata</replaceable>:isnil()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: true if the value is all zero, otherwise false.
                The all-zero UUID value can be expressed as <code>uuid.NULL</code>, or as
                uuid.fromstr('00000000-0000-0000-0000-000000000000').
                The comparison with an all-zero value can also be expressed as
                <replaceable>uuid_with_type_cdata</replaceable> == uuid.NULL.
            </para>
        </listitem>
    </varlistentry>

</variablelist>
<para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool&gt; <userinput>uuid = require('uuid')</userinput>
---
...
tarantool&gt; <userinput>uuid(), uuid.bin(), uuid.str()</userinput>
---
- 16ffedc8-cbae-4f93-a05e-349f3ab70baa
- !!binary FvG+Vy1MfUC6kIyeM81DYw==
- 67c999d2-5dce-4e58-be16-ac1bcb93160f
...
tarantool&gt; <userinput>uu = uuid()</userinput>
---
...
tarantool&gt; <userinput>#uu:bin(), #uu:str(), type(uu), uu:isnil()</userinput>
---
- 16
- 36
- cdata
- false
...
</programlisting>
</para>

</section>

<section xml:id="sp-box-cjson">
    <title>Package <code>json</code></title>

<variablelist xml:id="box.cjson" xreflabel="box.cjson">
    <para>
        The <code>json</code> package provides JSON manipulation routines.
        It is based on the <link xlink:href="http://www.kyne.com.au/~mark/software/lua-cjson.php">
        Lua-CJSON package by Mark Pulford</link>.

        For a complete manual on Lua-CJSON please read <link xlink:href="http://www.kyne.com.au/~mark/software/lua-cjson-manual.html">the official documentation</link>.
    </para>
    <varlistentry>
        <term><emphasis role="lua">json.encode(<replaceable>scalar-value | Lua-table-value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a Lua object to a JSON string.
            </para>
            <para>
              Parameters: either a scalar value or a Lua table value.
            </para>
            <para>
              Returns: (type = string) the original value reformatted as a JSON string.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool&gt; <userinput>json=require('json')</userinput>
---
...
tarantool&gt; <userinput>json.encode(123)</userinput>
---
- '123'
...
tarantool&gt; <userinput>json.encode({123})</userinput>
---
- '[123]'
...
tarantool&gt; <userinput>json.encode({123, 234, 345})</userinput>
---
- '[123,234,345]'
...
tarantool&gt; <userinput>json.encode({abc = 234, cde = 345})</userinput>
---
- '{"cde":345,"abc":234}'
...
tarantool&gt; <userinput>json.encode({hello = {'world'}})</userinput>
---
- '{"hello":["world"]}'
...
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">json.decode(<replaceable>string-value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a JSON string to a Lua object.
            </para>
            <para>
              Parameters: <code>string-value</code> = a string formatted as JSON.
            </para>
            <para>
              Returns: (type = Lua table) the original contents formatted as a Lua table.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>json=require('json')</userinput>
---
...
 tarantool&gt; <userinput>json.decode('123')</userinput>
---
- 123
...
tarantool&gt; <userinput>json.decode('[123, "hello"]')[2]</userinput>
---
- hello
...
tarantool&gt; <userinput>json.decode('{"hello": "world"}').hello</userinput>
---
- world
...
</programlisting>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua" xml:id="json-null" xreflabel="json-null">json.NULL</emphasis></term>
        <listitem>
            <para>
              Return a value comparable to Lua "nil" which may be useful as a placeholder in a tuple or Lua table.
            </para>
            <para>
              Parameters: none.
            </para>
            <para>
              Returns: the comparable value.
            </para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
<prompt>tarantool&gt;</prompt> <userinput>-- When nil is assigned to a Lua-table field, the field disappears</userinput>
<prompt>tarantool&gt;</prompt> <userinput>{nil, 'a', 'b'}</userinput>
---
- 2: a
  3: b
...
<prompt>tarantool&gt;</prompt> <userinput> -- When json.NULL is assigned to a Lua-table field, the field is json.NULL</userinput>
<prompt>tarantool&gt;</prompt> <userinput>{json.NULL, 'a', 'b'}</userinput>
---
- - null
  - a
  - b
...
<prompt>tarantool&gt;</prompt> <userinput>-- When json.NULL is assigned to a JSON field, the field is null</userinput>
<prompt>tarantool&gt;</prompt> <userinput>json.encode({field2 = json.NULL, field1 = 'a',  field3 = 'c'})</userinput>
---
- '{"field2":null,"field1":"a","field3":"c"}'
...</programlisting>
        </listitem>
    </varlistentry>
</variablelist>

</section>

<section xml:id="sp-yaml">
    <title>Package <code>yaml</code></title>
    <para>
     The <code>yaml</code> package takes strings in YAML format and decodes them,
     or takes a series of non-YAML values and encodes them.
    </para>
<variablelist xml:id="yaml">
    <varlistentry>
        <term><emphasis role="lua">yaml.encode(<replaceable>scalar-value | Lua-table-value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a Lua object to a YAML string.
            </para>
            <para>
              Parameters: either a scalar value or a Lua table value.
            </para>
            <para>
              Returns: (type = string) the original value reformatted as a YAML string.
            </para>
       </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">yaml.decode(<replaceable>string-value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a YAML string to a Lua object.
            </para>
            <para>
              Parameters: <code>string-value</code> = a string formatted as YAML.
            </para>
            <para>
              Returns: (type = Lua table) the original contents formatted as a Lua table.
            </para>
        </listitem>
    </varlistentry>
        <varlistentry>
        <term><emphasis role="lua" xml:id="yaml-null" xreflabel="yaml-null">yaml.NULL</emphasis></term>
        <listitem>
            <para>
              Return a value comparable to Lua "nil" which may be useful as a placeholder in a tuple.
            </para>
            <para>
              Parameters: none.
            </para>
            <para>
              Returns: the comparable value.
            </para>
        </listitem>
    </varlistentry>
</variablelist>
    <para>
    <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
<prompt>tarantool></prompt> <userinput>yaml = require('yaml')</userinput>
---
...
<prompt>tarantool></prompt> <userinput>y =  yaml.encode({'a',1,'b',2})</userinput>
---
...
<prompt>tarantool></prompt> <userinput>z = yaml.decode(y)</userinput>
---
...
<prompt>tarantool></prompt> <userinput>z[1],z[2],z[3],z[4]</userinput>
---
- a
- 1
- b
- 2
...
<prompt>tarantool></prompt> <userinput>if yaml.NULL == nil then print('hi') end</userinput>
hi
---
...
</programlisting>
    </para>
</section>

<section xml:id="sp-msgpack">
    <title>Package <code>msgpack</code></title>
    <para>
     The <code>msgpack</code> package takes strings in MsgPack format and decodes them,
     or takes a series of non-MsgPack values and encodes them.
    </para>
<variablelist xml:id="msgpack">
    <varlistentry>
        <term><emphasis role="lua">msgpack.encode(<replaceable>scalar-value | Lua-table-value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a Lua object to a MsgPack string.
            </para>
            <para>
              Parameters: either a scalar value or a Lua table value.
            </para>
            <para>
              Returns: (type = string) the original value reformatted as a MsgPack string.
            </para>
       </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua">msgpack.decode(<replaceable>string-value</replaceable>[, <replaceable>field-number</replaceable>])</emphasis></term>
        <listitem>
            <para>
              Convert a MsgPack string to a Lua object.
            </para>
            <para>
              Parameters: <code>string-value</code> = a string formatted as MsgPack.
              <code>field-number</code> = a number of a particular field to decode.
            </para>
            <para>
              Returns: (type = Lua table) the original contents formatted as a Lua table.
            </para>
        </listitem>
    </varlistentry>
        <varlistentry>
        <term><emphasis role="lua" xml:id="msgpack-null" xreflabel="msgpack-null">msgpack.NULL</emphasis></term>
        <listitem>
            <para>
              Return a value comparable to Lua "nil" which may be useful as a placeholder in a tuple.
            </para>
            <para>
              Parameters: none.
            </para>
            <para>
              Returns: the comparable value.
            </para>
        </listitem>
    </varlistentry>
</variablelist>
    <para>
    <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
<prompt>tarantool></prompt> <userinput>msgpack = require('msgpack')</userinput>
---
...
<prompt>tarantool></prompt> <userinput> y =  msgpack.encode({'a',1,'b',2})</userinput>
---
...
<prompt>tarantool></prompt> <userinput> z = msgpack.decode(y)</userinput>
---
...
<prompt>tarantool></prompt> <userinput> z[1],z[2],z[3],z[4]</userinput>
---
- a
- 1
- b
- 2
...
<prompt>tarantool></prompt> <userinput> box.space.tester:insert{20,msgpack.NULL,20}</userinput>
---
- [20, null, 20]
...
</programlisting>
    </para>
</section>

<section xml:id="sp-box-fiber">
    <title>Package <code>fiber</code></title>
    <para>
      The <code>fiber</code> package allows for creating, running and managing <emphasis>fibers</emphasis>.
    </para>
    <para>
      A fiber is a set of instructions which are executed
      with cooperative multitasking. Fibers managed by the
      fiber package are associated with a user-supplied function
      called the <emphasis>fiber function</emphasis>.

      A fiber has three possible states: running, suspended or dead.
      When a fiber is created with <code>fiber.create()</code>, it is running.
      When a fiber yields control with <code>fiber.sleep()</code>, it is suspended.
      When a fiber ends (because the fiber function ends), it is dead.
    </para>
    <para>
       All fibers are part of the fiber registry.
       This registry can be searched (<code>fiber.find()</code>)
-      via fiber id (fid), which is numeric.
    </para>
    <para>
      A runaway fiber can be stopped with <code>fiber.cancel()</code>.
      However, <code>fiber.cancel()</code> is advisory &mdash; it works
      only if the runaway fiber calls <code>fiber.testcancel()</code>
      once in a while. Most <code>box.*</code> hooks, such as <code>box.space...delete()</code>
      or <code>box.space...update()</code>, do call <code>fiber.testcancel()</code>.
      <code>box.space...select{}</code> does not.
      In practice, a runaway fiber can only become unresponsive
      if it does many computations and does not check
      whether it's been canceled.
<!--
In addition to the advisory cancellation, configuration parameter
<code>lua_timeout</code> can be used to cancel runaway Lua
procedures.
-->
    </para>
    <para>
      The other potential problem comes from
      fibers which never get scheduled, because they are not subscribed
      to any events, or because no relevant events occur. Such morphing fibers
      can be killed with <code>fiber.cancel()</code> at any time,
      since <code>fiber.cancel()</code>
      sends an asynchronous wakeup event to the fiber,
      and <code>fiber.testcancel()</code> is checked whenever such an event occurs.
    </para>
    <para>
      Like all Lua objects, dead fibers are
      garbage collected. The garbage collector frees pool allocator
      memory owned by the fiber, resets all fiber data, and returns
      the fiber (now called a fiber carcass) to the fiber pool.
      The carcass can be reused when another fiber is created.
    </para>
<variablelist xml:id="fiber">
 
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.create">fiber.create(<replaceable>function, function-arguments</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Create and start a fiber. The fiber is
              created and begins to run immediately.
            </para>
            <para>
              Parameters: <code>function</code> = the function to be associated with the fiber,
              <code>function-arguments</code> = what will be passed to the function.
            </para>
            <para>
             Returns: (type = userdata) created fiber object.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.id">fiber.id(<replaceable>fiber</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
              Parameters: fiber object, for example the fiber returned by <code>fiber.create</code>.
            </para>
            <para>
              Returns: (type = number) id of the fiber.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.name">fiber.name(<replaceable>fiber</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
              Parameters: fiber object, for example the fiber returned by <code>fiber.create</code>.
            </para>
            <para>
              Returns: (type = string) name of the fiber.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.self">fiber.self() </emphasis>
        </term>
        <listitem>
            <para>
              Returns: (type = userdata) <code>fiber</code>
              object for the currently scheduled fiber.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.find">fiber.find(<replaceable>id</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
              Locate a fiber userdata object by id.
            </para>
            <para>
              Returns: (type = userdata) fiber object for the specified fiber.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.sleep">fiber.sleep(<replaceable>time</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Yield to the sched fiber and sleep for the specified number of seconds.
              Only the current fiber can be made to sleep.
            </para>
            <para>
              Parameters: <code>time</code> = number of seconds to sleep.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
         <emphasis role="lua" xml:id="fiber.yield" xreflabel="fiber.yield">fiber.yield() </emphasis>
        </term>
        <listitem>
            <para>
              Yield control to the scheduler. Equivalent to <code>fiber.sleep(0)</code>.
            </para>
            <para>
              Parameters: <code>none</code>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.status">fiber.status(<replaceable>[fiber]</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Return the status of the specified fiber.
            </para>
            <para>
              Parameters: <code>fiber</code> = the fiber to be checked -- if this is not
              supplied, then the current fiber is to be checked.
            </para>
            <para>
              Returns: (type = string) the status of <code>fiber</code>.
              One of: <quote>dead</quote>,
              <quote>suspended</quote>, <quote>attached</quote>
              or <quote>running</quote>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">fiber.info()</emphasis>
        </term>
        <listitem>
            <para>
              Return information about all fibers.
            </para>
            <para>
              Returns: (type = table) the name, id, and backtrace of all fibers.
            </para>
        </listitem>
    </varlistentry>
 
    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.cancel">fiber.cancel(<replaceable>fiber</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Cancel a <code>fiber</code>.
              Running and suspended fibers can be canceled.
            </para>
            <para>
              Parameters: <code>fiber</code> = the fiber to be canceled.
            </para>
            <para>
              Possible errors: the specified fiber does not permit cancel.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.kill">fiber.kill(<replaceable>id</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
              Locate a fiber by its numeric id and cancel it. In
              other words, <code>fiber.kill()</code> combines <emphasis
              role="lua">fiber.find()</emphasis> and <emphasis
              role="lua">fiber.cancel()</emphasis>.
            </para>
            <para>
              Parameters: <code>id</code> = the id of the fiber to be canceled.
            </para>
            <para>
              Possible errors: the specified fiber does not exist or does not permit cancel.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua" xml:id="fiber.testcancel">fiber.testcancel()</emphasis>
        </term>
        <listitem>
            <para>
              Check if the current fiber has been canceled and
              throw an exception if this is the case.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
            <emphasis role="lua">fiber.time()</emphasis>
        </term>
        <listitem>
            <para>
                Returns: current system time (in seconds since the epoch) as a Lua
                number.  The time is taken from the event loop
                clock, which makes this call very cheap,
                but still useful for constructing artificial
                tuple keys.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>fiber = require('fiber')</userinput>
---
...
tarantool&gt; <userinput> fiber.time(), fiber.time()</userinput>
---
 - 1385758759.2591
 - 1385758759.2591
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <emphasis role="lua">fiber.time64()</emphasis>
        </term>
        <listitem>
            <para>
              Returns: current system time (in microseconds since the epoch) as a 64-bit
              integer. The time is taken from the event loop clock.
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>tarantool&gt; <userinput>fiber = require('fiber')</userinput>
---
...
tarantool&gt; <userinput>fiber.time(), fiber.time64()</userinput>
---
 - 1385758828.9825
 - 1385758828982485
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

</variablelist>

<para>
<bridgehead renderas="sect4">Example</bridgehead>
Make the function which will be associated with the fiber.
This function contains an infinite loop
("while 0 == 0" is always true).
Each iteration of the loop adds 1 to a global variable
named gvar, then goes to sleep for 2 seconds.
The sleep causes an implicit fiber.yield().<programlisting>
<prompt>tarantool&gt;</prompt><userinput> fiber = require('fiber')</userinput>
<prompt>tarantool&gt;</prompt><userinput> console = require('console'); console.delimiter('!')</userinput>
<prompt>tarantool&gt;</prompt><userinput> function function_x()</userinput>
<prompt>        -&gt;</prompt><userinput>   gvar = 0</userinput>
<prompt>        -&gt;</prompt><userinput>   while 0 == 0 do</userinput>
<prompt>        -&gt;</prompt><userinput>     gvar = gvar + 1</userinput>
<prompt>        -&gt;</prompt><userinput>     fiber.sleep(2)</userinput>
<prompt>        -&gt;</prompt><userinput>     end</userinput>
<prompt>        -&gt;</prompt><userinput>   end!</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> console.delimiter('')!</userinput></programlisting>
Make a fiber, associate function_x with the fiber,
and start function_x. It will immediately "detach"
so it will be running independently of the caller.
<programlisting>
<prompt>tarantool&gt;</prompt><userinput> fiber_of_x = fiber.create(function_x)</userinput>
---
...</programlisting>

Get the id of the fiber (fid), to be used in later displays.<programlisting>
<prompt>tarantool&gt;</prompt><userinput> fid = fiber.id(fiber_of_x)</userinput>
---
...
</programlisting>
Pause for a while, while the detached function runs. Then ...
Display the fiber id, the fiber status, and gvar  (gvar will have
gone up a bit depending how long the pause lasted). The status is
suspended because the fiber spends almost all its time sleeping or yielding.<programlisting>
<prompt>tarantool&gt;</prompt><userinput> print('#',fid,'. ',fiber.status(fiber_of_x),'. gvar=',gvar)</userinput>
# 102 .  suspended . gvar= 399
---
...
</programlisting>
Pause for a while, while the detached function runs. Then ...
Cancel the fiber. Then, once again ...
Display the fiber id, the fiber status, and gvar (gvar will have
gone up a bit more depending how long the pause lasted). This time
the status is dead because the cancel worked.<programlisting>
<prompt>tarantool&gt;</prompt><userinput> fiber.cancel(fiber_of_x)</userinput>
... fiber `lua' has been cancelled
... fiber `lua': exiting
---
...
<prompt>tarantool&gt;</prompt><userinput> print('#',fid,'. ',fiber.status(fiber_of_x),'. gvar=',gvar)</userinput>
# 102 .  dead . gvar= 421
---
...</programlisting>
</para>

</section>

<section xml:id="sp-fiber-ipc">
    <title>Package <code>fiber-IPC</code> &mdash; inter-process communication</title>
    <para>
      The <code>fiber-IPC</code> package allows sending and receiving messages between
      different processes. The words "different processes" in this context mean
      different connections, different sessions, or different fibers.
    </para>
    <para>
      Call <code>fiber.channel()</code> to allocate space and get a channel object, which will be
      called <code>channel</code> for examples in this section.
      Call the other fiber-IPC routines, via <code>channel</code>, to send messages, receive messages, or check ipc status.
      Message exchange is synchronous.
      The channel is garbage collected when no one is using it, as with any
      other Lua object.
      Use object-oriented syntax, for example <code>channel:put(message)</code>
      rather than <code>fiber.channel.put(message)</code>. 
    </para>
<variablelist xml:id="fiber.ipc">
    <para>
    </para>
    <varlistentry>
        <term><emphasis role="lua">fiber.channel(<replaceable>capacity-number</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Create a new communication channel.
            </para>
            <para>
              Parameters: <code>capacity-number</code> =
              a positive integer as great as the maximum number of slots
              (spaces for get or put or broadcast messages)
              that might be pending at any given time.
            </para>
            <para>
              Returns: new channel.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:put(<replaceable>message[, timeout]</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Send a message using a channel. If the channel is full,
                <code>channel:put()</code>
                blocks until there is a free slot in the channel.
            </para>
            <para>
                Parameters: <code>message</code>, <code>timeout</code>.
            </para>
            <para>
                Returns: If <code>timeout</code> is provided,
                and the channel doesn't become empty for the duration
                of the timeout,
                <code>channel:put()</code>
                returns false. Otherwise it returns true.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:close()</emphasis></term>
        <listitem>
            <para>
               Close the channel. All waiters in the channel will be
               woken up. All following <code>channel:put()</code>
               or <code>channel:get()</code> operations will return
               an error (nil).
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:get(<replaceable>[timeout]</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Fetch a message from a channel. If the channel is empty,
                <code>channel:get()</code>
                blocks until there is a message.
            </para>
            <para>
              Parameters: <code>timeout</code>.
            </para>
            <para>
              Returns: the value placed on the channel by an earlier <code>channel:put()</code> or <code>channel:broadcast()</code>.
            </para>
            <para>
                Possible errors: If <code>timeout</code> is provided,
                and there are no new messages for the duration
                of the timeout,
                <code>channel:get()</code>
                returns error.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:broadcast(<replaceable>message</replaceable>)</emphasis></term>
        <listitem>
            <para>
             If the channel is empty, <code>channel:broadcast()</code> is equivalent to
             <code>channel:put()</code>.
              Otherwise, <code>channel:broadcast()</code> sends the message to all readers of the
              channel.
            </para>
            <para>
             Parameters: <code>message</code>.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:is_empty()</emphasis></term>
        <listitem>
            <para>
               Check whether the specified channel is empty (has no messages).
            </para>
            <para>
               Returns: (type = boolean) true if the specified channel is empty.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:is_full()</emphasis></term>
        <listitem>
            <para>
                Check whether the specified channel is full.
            </para>
            <para>
                Returns: (type = boolean) true if the specified channel is full (has no room for a new message).
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:has_readers()</emphasis></term>
        <listitem>
            <para>
               Check whether the specified channel is empty and has readers waiting
               for a message (because they have issued <code>channel:get()</code> and then
               blocked).
            </para>
            <para>
               Returns: (type = boolean) true if blocked users are waiting. Otherwise false.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:has_writers()</emphasis></term>
        <listitem>
            <para>
                Check whether the specified channel is full and has writers waiting
                (because they have issued <code>channel:put()</code> and then blocked
                due to lack of room).
            </para>
            <para>
                Returns: (type = boolean) true if blocked users are waiting. Otherwise false.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><emphasis role="lua"><replaceable>channel</replaceable>:is_closed()</emphasis></term>
        <listitem>
            <simpara>
                Returns: (type = boolean) true if the specified channel is already
                closed.
                Otherwise false.
            </simpara>
        </listitem>
    </varlistentry>
</variablelist>
<para>
           <bridgehead renderas="sect4">Example</bridgehead><programlisting><userinput>
             
fiber = require('fiber')            
channel = fiber.channel(10)
function consumer_fiber()
    while true do
        local task = channel:get()
        ...
    end
end

function consumer2_fiber()
    while true do
        local task = channel:get(10)        -- 10 seconds
        if task ~= nil then
            ...
        else
            ...                             -- timeout
        end
    end
end

function producer_fiber()
    while true do
        task = box.space...:select{...}
        ...
        if channel:is_empty() then
            # channel is empty
        end

        if channel:is_full() then
            # channel is full
        end

        ...
        if channel:has_readers() then
            # there are some fibers that are waiting for data
        end
        ...

        if channel:has_writers() then
            # there are some fibers that are waiting for readers
        end
        channel:put(task)
    end
end

function producer2_fiber()
    while true do
        task = box.space...select{...}

        if channel:put(task, 10) then       -- 10 seconds
            ...
        else
            ...                             -- timeout
        end
    end
end
</userinput></programlisting>
</para>
</section>

<section xml:id="sp-box-session">
    <title>Package <code>box.session</code></title>
    <para>
    The <code>box.session</code> package allows querying the session state,
    writing to a session-specific temporary Lua table, or setting up triggers
    which will fire when a session starts or ends.
    A <emphasis>session</emphasis> is an object associated with each client connection.
    </para>
<variablelist>
    <varlistentry>
        <term>
            <emphasis role="lua">box.session.id() </emphasis>
        </term>
        <listitem>
            <para>
              Returns: (type = number) the unique identifier
              (ID) for the current session. The result can be 0 meaning
              there is no session.
            </para>
      </listitem>
    </varlistentry>

    <varlistentry>
        <term>
            <emphasis role="lua">box.session.exists(<replaceable>id</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
              Returns: (type = number) 1 if the session exists,
              0 if the session does not exist.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
        <emphasis role="lua">box.session.peer(<replaceable>id</replaceable>) </emphasis>
        </term>
        <listitem>
            <para>
               Parameters: <code>id</code> = the unique identifier of the session.
            </para>
            <para>
              Returns: (type = string) If the specified session exists, the host
              address and port of the session peer, for example "127.0.0.1:55457".
              If the specified session does not exist, "0.0.0.0:0". The command is executed on the server,
              so the "local name" is the server's host and administrative port,
              and the "peer name" is the client's host and port.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term>
           <emphasis role="lua">box.session.storage</emphasis>
        </term>
        <listitem>
            <para>
              A Lua table that can hold arbitrary
              unordered session-specific names and values, which will last until
              the session ends.
            </para>
        </listitem>
    </varlistentry>
</variablelist>

<para>
<bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt><userinput> box.session.peer(session.id())</userinput>
---
 - 127.0.0.1:45129
...
<prompt>tarantool&gt;</prompt><userinput> box.session.storage.random_memorandum = "Don't forget the eggs."</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> box.session.storage.radius_of_mars = 3396</userinput>
---
...

<prompt>tarantool&gt;</prompt><userinput> m = ''</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> for k, v in pairs(box.session.storage) do m = m .. k .. '=' .. v .. ' ' end</userinput>
---
...
<prompt>tarantool&gt;</prompt><userinput> m</userinput>
---
- 'radius_of_mars=3396 random_memorandum=Don''t forget the eggs. '
...</programlisting>
</para>

    <para>
    See <olink targetptr="sp-box-session-triggers">the section "Triggers on connect and disconnect"</olink>
    for instructions about defining triggers for connect and disconnect events
    with <code>box.session.on_connect()</code> and <code>box.session.on_disconnect()</code>.
    See <link linkend="authentication">the section "Authentication and access control"</link>
    for instructions about <code>box.session</code> functions that affect user identification and security.
    </para>
</section>

<section xml:id="sp-box-socket">
    <title>Package <code>socket</code> &mdash; TCP and UDP sockets</title>
<variablelist xml:id="socket">
    <para>
      The <code>socket</code> package allows exchanging data via BSD sockets
      with a local or remote host in connection-oriented (TCP) or datagram-oriented (UDP) mode.
      Semantics of the calls in the <code>socket</code> API closely follow
      semantics of the corresponding POSIX calls. Function names
      and signatures are mostly compatible with
      <link xlink:href="http://w3.impa.br/~diego/software/luasocket/">luasocket</link>.
    </para>
    <para>
     The functions for setting up and connecting are <code>socket</code>, <code>sysconnect</code>, <code>tcp_connect</code>.
     The functions for sending data are <code>send</code>, <code>sendto</code>, <code>write</code>, <code>syswrite</code>.
     The functions for receiving data are <code>recv</code>, <code>recvfrom</code>, <code>read</code>, <code>readline</code>.
      The functions for waiting before sending/receiving data are <code>wait</code>, <code>readable</code>, <code>writable</code>.
     The functions for setting flags are <code>nonblock</code>, <code>setsockopt</code>.
     The functions for stopping and disconnecting are <code>shutdown</code>, <code>close</code>.
     The functions for error checking are <code>errno</code>, <code>error</code>.
    </para>
    <para>
      <table>
      <title xml:id="socket-functions">Socket functions: Names, Purposes</title>
      <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <thead>
      <row><entry>Name</entry><entry>Purpose</entry></row>
      </thead>
      <tbody>
       <row><entry>socket</entry><entry>setup</entry></row>
       <row><entry><link linkend="socket-sysconnect">sysconnect</link></entry><entry>setup</entry></row>
       <row><entry><link linkend="socket-tcpconnect">tcp_connect</link></entry><entry>setup</entry></row>
       <row><entry><link linkend="socket-send">send</link></entry><entry>sending</entry></row>
       <row><entry><link linkend="socket-sendto">sendto</link></entry><entry>sending</entry></row>
       <row><entry><link linkend="socket-send">write</link></entry><entry>sending</entry></row>
       <row><entry><link linkend="socket-syswrite">syswrite</link></entry><entry>sending</entry></row>
       <row><entry><link linkend="socket-recv">recv</link></entry><entry>receiving</entry></row>
       <row><entry><link linkend="socket-recvfrom">recvfrom</link></entry><entry>receiving</entry></row>
       <row><entry><link linkend="socket-read">read</link></entry><entry>receiving</entry></row>
       <row><entry><link linkend="socket-readline">readline</link></entry><entry>receiving</entry></row>
       <row><entry><link linkend="socket-nonblock">nonblock</link></entry><entry>flag setting  </entry></row>
       <row><entry><link linkend="socket-setsockopt">setsockopt</link></entry><entry>flag setting  </entry></row>
       <row><entry><link linkend="socket-linger">linger</link></entry><entry>flag setting</entry></row>
       <row><entry><link linkend="socket-listen">listen</link></entry><entry>client/server</entry></row>
       <row><entry><link linkend="socket-accept">accept</link></entry><entry>client/server</entry></row>
       <row><entry><link linkend="socket-shutdown">shutdown</link></entry><entry>teardown</entry></row>
       <row><entry><link linkend="socket-close">close</link></entry><entry>teardown</entry></row>
       <row><entry><link linkend="socket-error">errno</link></entry><entry>serror checking</entry></row>
       <row><entry><link linkend="socket-error">error</link></entry><entry>error checking</entry></row>
       <row><entry><link linkend="socket-getaddrinfo">getaddrinfo</link></entry><entry>information</entry></row>
       <row><entry><link linkend="socket-getsockopt">getsockopt</link></entry><entry>information</entry></row>
       </tbody>
      </tgroup>
      </table>
    </para>
    <para>
      Typically a socket session will begin with the setup functions,
      will set one or more flags, will have a loop with sending and receiving functions,
      will end with the teardown functions -- as an example at the end of this section will show.
      Throughout, there may be error-checking and waiting functions for synchronization.
      Some functions may "block" if a non-default option flag is set,
      therefore the fiber that they are in will yield so that other processes may take
      over, as is the norm for cooperative multitasking.
    </para>
    <para>
     For all examples in this section the socket name will be <code>sock</code>
     and the function invocations will look like <code>sock:<replaceable>function_name</replaceable>(...)</code>.
    </para>

    <varlistentry>
        <term xml:id="socket-socket" xreflabel="socket-socket"><emphasis role="lua">socket(<replaceable>domain</replaceable>, <replaceable>type</replaceable>, <replaceable>protocol</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Create a new TCP or UDP socket.
                The argument values are the same as in the <link xlink:href="http://man7.org/linux/man-pages/man2/socket.2.html">Linux man page</link>.
            </para>
            <para>
                Returns: (type = userdata) a new socket, or <code>nil</code>.
            </para>
            <para>
                Example: <code>socket = require('socket'); sock = socket('AF_INET', 'SOCK_STREAM', 'tcp')</code>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-sysconnect" xreflabel="socket-sysconnect"><emphasis role="lua"><replaceable>sock</replaceable>:sysconnect(<replaceable>host, port</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Connect a socket to a remote host.
                The argument values are the same as in the <link xlink:href="http://man7.org/linux/man-pages/man2/connect.2.html">Linux man page</link>.
                The host must be an IP address.
            </para>
            <para>
                Parameters: Either: <code>host</code> -- a string representation of an IPv4 address or an IPv6 address; <code>port</code> -- a number.
                Or: <code>host</code> -- a string containing "unix/"; <code>port</code> -- a string containing a path to a unix socket.
                Or: <code>host</code> -- a number, 0 (zero), meaning "all local interfaces"; <code>port</code> -- a number.
                If a port number is 0 (zero), the socket will be bound to a random local port.
            </para>
            <para>
                Returns: (type = userdata) a connected socket, if no error.
            </para>
            <para>
                Example: <code>sock:sysconnect('127.0.0.1', 80)</code>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-tcpconnect" xreflabel="socket-tcpconnect"><emphasis role="lua">socket.tcp_connect(<replaceable>host, port</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Connect a socket to a remote host.
            </para>
            <para>
                Parameters: <code>host</code>, <code>port</code>. The host may be a URL rather than an IP address.
            </para>
            <para>
                Returns: (type = userdata) a connected socket, if no error.
            </para>
            <para>
                Example: <code>socket.tcp_connect('tarantool.org', 80)</code>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-send" xreflabel="socket-send"><emphasis role="lua"><replaceable>sock</replaceable>:send(<replaceable>data</replaceable>)</emphasis></term>
        <listitem>
            <para>
             Send data over a connected socket.
            </para>
            <para>
             Parameters: <code>data</code>.
            </para>
            <para>
             Returns: true if success, false if error.
            </para>
            <para>
             Notes: The function <code>sock:write(...)</code> has the same parameters and same effect.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term xml:id="socket-syswrite" xreflabel="socket-syswrite"><emphasis role="lua"><replaceable>sock</replaceable>:syswrite(<replaceable>size</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Write as much as possible data to the socket buffer if non-blocking.
              Rarely used. For details see  <link xlink:href="https://github.com/tarantool/tarantool/wiki/sockets%201.6">this description</link>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-recv" xreflabel="socket-recv"><emphasis role="lua">sock:recv(<replaceable>size</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Read <code>size</code> bytes from a connected socket.
              An internal read-ahead buffer is used to reduce the cost
              of this call.
            </para>
            <para>
              Parameters: <code>size</code>.
            </para>
            <para>
              Returns: (type = string) a string of the requested length on success.
              On error, returns an empty string, followed
              by <code>status, errno, errstr</code>.
              In case the writing side has closed its end, returns the remainder
              read from the socket (possibly an empty string),
              followed by <code>"eof"</code> status.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-readline" xreflabel="socket-readline"><emphasis role="lua"><replaceable>sock</replaceable>:readline(<replaceable>[limit] [, separator list]</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Read a line from a connected socket.
            </para>
            <para>
                <code>sock:readline()</code> with no arguments reads data from a socket
                until '\n' (line feed) or eof (end of transmission).
            </para>
            <para>
              Parameters: <code>limit</code> &mdash; maximum number of bytes to read. The function reads
              until a separator is seen, or until (limit) bytes have been read. The default is "no limit".
              <code>separator list</code> &mdash; a Lua table containing one or more separators.
              The function reads until one of the separators is seen. The default is a Lua table containing '\n'.
            </para>
            <para>
                Returns:
                (type = string) A Lua string with data if success,
                an empty string if error. If multiple separators were passed in <code>separator list</code>,
                the separator which matched is also shown, as the third part of the return.
                <table>
                    <title><code>readline()</code> returns</title>
                    <tgroup cols="2" align="left" colsep="1" rowsep="1">
                      <tbody>
                        <row>
                          <entry><code>data, nil, separator</code></entry><entry>success</entry>
                        </row>
                        <row>
                          <entry><code>"", "timeout", ETIMEDOUT, errstr</code></entry><entry>timeout</entry>
                        </row>
                        <row>
                          <entry><code>"", "error", errno, errstr</code></entry><entry>error</entry>
                        </row>
                        <row>
                          <entry><code>data, "limit"</code></entry><entry>limit</entry>
                        </row>
                        <row>
                          <entry><code>data, "eof"</code></entry><entry>eof</entry>
                        </row>
                      </tbody>
                    </tgroup>
                </table>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
     <term xml:id="socket-read" xreflabel="socket-read"><emphasis role="lua"><replaceable>sock</replaceable>:read(<replaceable>size</replaceable>)</emphasis></term>
        <listitem>
            <para>
             Read data on a socket, until <code>size</code> bytes have been read,
             or until there is nothing more to read, or until an error occurs.
             Similar to sock:readline(), except for the fact that there is no list of separators.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-sysread" xreflabel="socket-sysread"><emphasis role="lua"><replaceable>sock</replaceable>:sysread(<replaceable>size</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Return all available data from the socket buffer if non-blocking.
              Rarely used. For details see  <link xlink:href="https://github.com/tarantool/tarantool/wiki/sockets%201.6">this description</link>.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-bind" xreflabel="socket-bind"><emphasis role="lua"><replaceable>sock</replaceable>:bind(<replaceable>host, port</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Bind a socket to the given host/port.
                A UDP socket after binding can be used
                to receive data (see <code>recvfrom()</code>). A TCP socket
                can be used to accept new connections, after it's
                been put in listen mode.
            </para>
            <para>
              Parameters: <code>host</code>, <code>port</code>.
            </para>
            <para>
               Returns: (type = userdata) a socket object on success, <code>nil, status, errno, errstr</code> on error.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-listen" xreflabel="socket-listen"><emphasis role="lua"><replaceable>sock</replaceable>:listen(backlog)</emphasis></term>
        <listitem>
            <para>
                Start listening for incoming connections.
            </para>
            <para>
                On Linux the listen <code>backlog</code>
                backlog may be from <filename>/proc/sys/net/core/somaxconn</filename>,
                on BSD the backlog may be <constant>SOMAXCONN</constant>.
            </para>
            <para>
               Returns: true for success, false for error.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-accept" xreflabel="socket-accept"><emphasis role="lua"><replaceable>sock</replaceable>:accept()</emphasis></term>
        <listitem>
            <para>
                Accept a new client connection and create a new connected socket.
                It is good practice to set the socket's blocking mode explicitly after accepting.
            </para>
            <para>
               Returns: new socket if success, null if error.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-sendto" xreflabel="socket-sendto"><emphasis role="lua"><replaceable>sock</replaceable>:sendto(<replaceable>data, host, port</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Send a message on a UDP socket to a specified host.
            </para>
            <para>
               Parameters: <code>data</code>, <code>host</code>.
            </para>
            <para>
               Returns: (type = number) the number of bytes sent on success, <code>0, status, errno, errstr</code>
                on error.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-recvfrom" xreflabel="socket-recvfrom"><emphasis role="lua"><replaceable>sock</replaceable>:recvfrom(<replaceable>limit</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Receive a message on a UDP socket.
            </para>
            <para>
                Parameters: <code>limit</code>, <code>timeout</code>.
            </para>
            <para>
                Returns: (type = string) Message, <code>nil</code>, client address, client port on success,
                <code>"", status, errno, errstr</code> on error or timeout.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-shutdown" xreflabel="socket-shutdown"><emphasis role="lua"><replaceable>sock</replaceable>:shutdown(<replaceable>how</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Shutdown a reading end, a writing end, or both ends of a socket.
            </para>
            <para>
               Parameters: <code>how</code> = socket.SHUT_RD, socket.SHUT_WR,
               or socket.SHUT_RDWR.
            </para>
            <para>
               Returns: true or false.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-close" xreflabel="socket-close"><emphasis role="lua"><replaceable>sock</replaceable>:close()</emphasis></term>
        <listitem>
            <para>
                Close (destroy) a socket.
                A closed socket should not be used any more.
                A socket is closed automatically 
                when its userdata is garbage collected by Lua.
            </para>
            <para>
               Returns: (type = boolean) true on success, false on error.
               For example, if sock is already closed, sock:close() returns false.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-error" xreflabel="socket-error"><emphasis role="lua"><replaceable>sock</replaceable>:error() and <replaceable>sock</replaceable>:errno()</emphasis></term>
        <listitem>
            <para>
                Retrieve information about the last error that occurred on a socket, if any.
                Errors do not cause throwing of exceptions so these functions are usually necessary.
            </para>
            <para>
             Returns:(type = number) result for sock:errno(), (type = string) result for sock:error().
             If there is no error, then sock:errno() will return 0 and sock:error() will return null.
            </para>
            <para>
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term xml:id="socket-setsockopt" xreflabel="socket-setsockopt"><emphasis role="lua"><replaceable>sock</replaceable>:setsockopt(<replaceable>level, name, value</replaceable>)</emphasis></term>
        <listitem>
            <para>
             Set socket flags. The argument values are the same as in the <link xlink:href="http://man7.org/linux/man-pages/man2/setsockopt.2.html">Linux man page</link>.
             The ones that Tarantool accepts are            
             SO_ACCEPTCONN, SO_BINDTODEVICE, SO_BROADCAST, SO_BSDCOMPAT, SO_DEBUG,
             SO_DOMAIN, SO_ERROR, SO_DONTROUTE, SO_KEEPALIVE, SO_MARK, SO_OOBINLINE,
             SO_PASSCRED, SO_PEERCRED, SO_PRIORITY, SO_PROTOCOL, SO_RCVBUF, SO_RCVBUFFORCE,
             SO_RCVLOWAT, SO_SNDLOWAT, SO_RCVTIMEO, SO_SNDTIMEO, SO_REUSEADDR, SO_SNDBUF,
             SO_SNDBUFFORCE, SO_TIMESTAMP, and SO_TYPE.
             Setting SO_LINGER is done with sock:linger(active), see below.
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-getsockopt" xreflabel="socket-getsockopt"><emphasis role="lua"><replaceable>sock</replaceable>:getsockopt(<replaceable>level, name</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Get socket flags. For a list of possible flags see description of the previous function,
              sock:setsockopt().
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term xml:id="socket-linger" xreflabel="socket-linger"><emphasis role="lua"><replaceable>sock</replaceable>:linger([<replaceable>active</replaceable>])</emphasis></term>
        <listitem>
            <para>
              Set or clear the SO_LINGER flag. For a description of the flag, see  <link xlink:href="http://man7.org/linux/man-pages/man1/loginctl.1.html">Linux man page</link>.
            </para>
            <para>
              Parameters: <code>active</code>.
            </para>
            <para>
              Returns: new active and timeout values.
             </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term xml:id="socket-nonblock" xreflabel="socket-nonblock"><emphasis role="lua"><replaceable>sock</replaceable>:nonblock([<replaceable>flag</replaceable>])</emphasis></term>
        <listitem>
            <para>
             <code>sock:nonblock()</code> returns the current flag value.
             <code>sock:nonblock(true)</code> sets the flag to false and returns false.
             <code>sock:nonblock(true)</code> sets the flag to true and returns true.
             This function may be useful before invoking a function which might otherwise block indefinitely.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
     <term xml:id="socket-readable" xreflabel="socket-readable"><emphasis role="lua"><replaceable>sock</replaceable>:readable([<replaceable>timeout</replaceable>])</emphasis>, <emphasis>sock:writable([<replaceable>timeout</replaceable>])</emphasis>, <emphasis>sock:wait([<replaceable>timeout</replaceable>])</emphasis></term>
        <listitem>
            <para>
               <code>sock:readable()</code> waits until something is readable, or until a timeout value expires.
               <code>sock:writable()</code> waits until something is writable, or until a timeout value expires.
               <code>sock:wait()</code> waits until something is either readable or writable, or until a timeout value expires.
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
     <term xml:id="socket-getaddrinfo" xreflabel="socket-getaddrinfo"><emphasis role="lua">socket.getaddrinfo(<replaceable>host</replaceable>, <replaceable>type</replaceable> [, <replaceable>{option-list}</replaceable>)</emphasis></term>
        <listitem>
            <para>
             The <code>socket.getaddrinfo()</code> function is useful for finding
             information about a remote site so that the correct arguments for
             <code>sock:sysconnect()</code> can be passed.
            </para>
            <para>
             Returns: An array containing "host:", "family", "type:", "protocol:", and "port:" fields.
            </para>
            <para>
             Example: <code>socket.getaddrinfo('tarantool.org', 'http')</code> will return variable information
             such as "- - host: 188.93.56.70, family: AF_INET, type: SOCK_STREAM, protocol: tcp, port: 80".
            </para>
        </listitem>
    </varlistentry>

</variablelist>


 <bridgehead renderas="sect4">Example showing use of socket over the Internet</bridgehead>
 <para>
 In this example a connection is made over the internet between the Tarantool server
 and <link xlink:href="http://tarantool.org">tarantool.org</link>,
 then an HTTP "head" message is sent, and a response is received: "HTTP/1.1 200 OK".
 This is not a useful way to communicate with this particular site,
 but shows that the system works.
<programlisting>
 <prompt>tarantool&gt;</prompt> <userinput>socket = require('socket')</userinput>
---
...

<prompt>tarantool&gt;</prompt> <userinput>sock = socket.tcp_connect('tarantool.org', 80)</userinput>
---
...

<prompt>tarantool&gt;</prompt> <userinput>type(sock)</userinput>
---
- table
...

<prompt>tarantool&gt;</prompt> <userinput>sock:error()</userinput>
---
- null
...

<prompt>tarantool&gt;</prompt> <userinput>sock:send("HEAD / HTTP/1.0\r\nHost: tarantool.org\r\n\r\n")</userinput>
---
- true
...

<prompt>tarantool&gt;</prompt> <userinput>sock:read(17)</userinput>
---
- "HTTP/1.1 200 OK\r\n"
...

<prompt>tarantool&gt;</prompt> <userinput>sock:close()</userinput>
---
- true
...
</programlisting>
</para>

</section>

<section xml:id="sp-fio">
<title>package <code>fio -- Cooperative File I/O</code></title>
  <para>
    Tarantool supports file input/output with an API that is similar to POSIX syscalls.
    All operations are performed asynchronously.
    Multiple fibers can access the same file simultaneously.
  </para>
  <variablelist>

  <varlistentry>
  <term><emphasis role="lua">fio.pathjoin(<replaceable>partial-string [, partial-string ...]</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Concatenate partial strings, separated by '/', to form a path name.
      </para>
      <para>
        Parameters: (type = string) one or more strings to be concatenated.
      </para>
      <para>
        Returns: path name
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.pathjoin('/etc', 'default', 'myfile')</userinput>
---
- /etc/default/myfile
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua">fio.basename(<replaceable>path-name</replaceable>[, <replaceable>suffix</replaceable>])</emphasis></term>
    <listitem>
      <para>
        Given a full path name, remove all but the final part (the file name).
        Also remove the suffix, if it is passed.
      </para>
      <para>
        Parameters: (type = string) path name, (type = string) suffix.
      </para>
      <para>
        Returns: file name.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.basename('/path/to/my.lua', '.lua')</userinput>
---
- my
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.umask(<replaceable>mask-bits</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Set the mask bits used when creating files or directories. For a detailed description type "man 2 umask".
      </para>
      <para>
        Parameters: (type = number) mask bits.
      </para>
      <para>
        Returns: (type = number) previous mask bits.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.umask(tonumber('755', 8)) -- pass 755 octal</userinput>
---
- 493
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.lstat or fio.stat(<replaceable>path-name</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Returns information about a file object.
        For details type "man 2 lstat" or "man 2 stat".
      </para>
      <para>
        Parameters: (string) path-name of file.
      </para>
      <para>
        Returns: (type = table) fields which describe the file's block size, creation time, size, and other attributes.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.lstat('/tarantool-master/src/tarantool')</userinput>
---
- inode: 739885
  rdev: 0
  size: 4516886
  atime: 1409423158
  mode: 33277
  mtime: 1409419499
  nlink: 1
  uid: 1000
  blksize: 4096
  gid: 1000
  ctime: 1409419499
  dev: 2049
  blocks: 8848
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.mkdir or fio.rmdir(<replaceable>path-name</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Create or delete a directory. For details type "man 2 mkdir" or "man 2 rmdir".
      </para>
      <para>
        Parameters: (type = string) path of directory.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.mkdir('/etc')</userinput>
---
- false
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.glob(<replaceable>path-name</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Return a list of files that match an input string.
        The list is constructed with a single flag that controls the behavior of the function: GLOB_NOESCAPE.
        For details type "man 3 glob".
      </para>
      <para>
        Parameters: (type = string) path-name, which may contain wildcard characters.
      </para>
      <para>
        Returns: (type = table) list of files whose names match the input string, or nil if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.glob('/etc/x*')</userinput>
---
- - /etc/xdg
  - /etc/xml
  - /etc/xul-ext
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua">fio.link or fio.symlink or fio.readlink or fio.unlink(<replaceable>path-name</replaceable> [, <replaceable>path-name</replaceable>])</emphasis></term>
    <listitem>
      <para>
        Functions to create and delete links.
        For details type "man readlink", "man 2 link", "man 2 symlink", "man 2 unlink"..
      </para>
      <para>
        Parameters: (type = string) existing file name, (type = string) linked name.
      </para>
      <para>
        Returns: <code>fio.link</code> and <code>fio.symlink</code> and <code>fio.unlink</code> return true if success, false if failure. <code>fio.readlink</code> returns the link value if success, nil if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.link('/home/username/tmp.txt', '/home/username/tmp.txt2')</userinput>
---
- true
...
<prompt>tarantool&gt;</prompt> <userinput>fio.unlink('/home/pgulutzan/tmp.txt2')</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.rename(<replaceable>path-name</replaceable>, <replaceable>new-path-name</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Rename a file or directory.
        For details type "man 2 rename".
      </para>
      <para>
        Parameters: (type = string) original name, (type = string) new name.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.rename('/home/username/tmp.txt', '/home/username/tmp.txt2')</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.chown or fio.chmod(<replaceable>path-name</replaceable>,<replaceable>new rights or new owner</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Manage the rights to file objects, or ownership of file objects. For details type "man 2 chown" or "man 2 chmod".
      </para>
      <para>
        Parameters: (for chown) number (uid, gid) and group group name or user name.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.chmod('/home/username/tmp.txt', tonumber('0755', 8))</userinput>
---
- true
...
 <userinput>fio.chown('/home/username/tmp.txt', 'username', 'username')</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.truncate(<replaceable>path-name</replaceable>,<replaceable>new-size</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Reduce file size to a specified value. For details type "man 2 truncate".
      </para>
      <para>
        Parameters: (type = string) path-name, (type = number) new-size.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.truncate('/home/username/tmp.txt', 99999)</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.sync()</emphasis></term>
    <listitem>
      <para>
        Ensure that changes are written to disk. For details type "man 2 sync".
      </para>
      <para>
        Parameters: none
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fio.sync()</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><emphasis role="lua">fio.open(<replaceable>path-name</replaceable>, <replaceable>flags</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Open a file in preparation for reading or writing or seeking.
      </para>
      <para>
        Parameters: (string) path-name, (number) flags. Flags can be passed as a number or as string constants, for example 'O_RDONLY', 'O_WRONLY', 'O_RDWR'.
        Flags can be combined by enclosing them in braces.
      </para>
      <para>
        Returns: (type = table) if success = a file handle (referred to in later examples as "fh"), if failure = nil.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh = fio.open('/home/username/tmp.txt', {'O_RDWR', 'O_APPEND'})</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>fh -- display file handle returned by fio.open</userinput>
---
- fh: 11
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua"><replaceable>file-handle</replaceable>:close()</emphasis></term>
    <listitem>
      <para>
        Close a file that was opened with fio.open. For details type "man 2 close".
      </para>
      <para>
        Parameters: (type = table) file handle as returned by <code>fio.open()</code>.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:close() -- where fh = file-handle</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua"><replaceable>file-handle</replaceable>:pread or <replaceable>file-handle></replaceable>:pwrite(<replaceable>count or new string</replaceable>, <replaceable>offset</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Perform read/write random-access operation on a file, without affecting the current seek position of the file.
        For details type "man 2 pread" or "man 2 pwrite".
      </para>
      <para>
       Parameters: (type = table) file-handle as returned by <code>fio.open</code>,
       (type = string) value to write or (type = number) number of bytes to read,
       (type = number) offset within file where reading or writing begins.
      </para>
      <para>
       Returns: <code>pwrite</code> returns true if success, false if failure. <code>pread</code> returns the data that was read, or nil if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:read(25, 25)</userinput>
---
- |-
  elete from t8//
  insert in
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua"><replaceable>file-handle</replaceable>:read or <replaceable>file-handle></replaceable>:write(<replaceable>count or new string</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Perform non-random-access read or write on a file. For details type "man 2 read" or "man 2 write".
        Important: <code>read</code> and <code>write</code> affect the seek position within the file,
        and this must be taken into account when working on the same file from multiple fibers.
        It is possible to limit or prevent or prevent file access from other fibers with <code>fiber.ipc</code>.
       </para>
      <para>
        Parameters: (type = table) file-handle as returned by <code>fio.open</code>, (type = string) value to write or (type = number) number of bytes to read.
      </para>
      <para>
        Returns: <code>write</code> returns true if success, false if failure. <code>read</code> returns the data that was read, or nil if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:write('new data')</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
    <term><emphasis role="lua"><replaceable>file-handle</replaceable>:truncate(<replaceable>new-size</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Change the size of an open file.
        Differs from <code>fio.truncate</code>, which changes the size of a closed file.
      </para>
      <para>
       Parameters: (type = table) file-handle as returned by <code>fio.open</code>, (type = number) new file size.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <para>
       Possible errors:
     </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:truncate(0)</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
    <term><emphasis role="lua"><replaceable>file-handle</replaceable>:seek(<replaceable>position</replaceable> [, <replaceable>offset-from</replaceable>)</emphasis></term>
    <listitem>
      <para>
        Shift position in the file to the specified position.
        For details type "man 2 seek".
      </para>
      <para>
       Parameters: (type = table) file handle as returned by <code>fio.open</code>,
       (type = number) position to seek to, (type = constant string) 'SEEK_END' = end of file,
        'SEEK_CUR' = current position, 'SEEK_SET' = start of file.
      </para>
      <para>
        Returns: (type = number) the new position if success, nil if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:seek(20, 'SEEK_SET')</userinput>
---
- 20
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua"><replaceable>file-handle</replaceable>:stat()</emphasis></term>
    <listitem>
      <para>
        Return statistics about an open file.
        This differs from <code>fio.stat</code> which return statistics about a closed file.
        For details type "man 2 stat".
      </para>
      <para>
        Parameters: (type = table) file handle as returned by <code>fio.open()</code>.
      </para>
      <para>
        Returns: (type = table) details about the file.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:stat()</userinput>
---
- inode: 729866
  rdev: 0
  size: 100
  atime: 1409429855
  mode: 33261
  mtime: 1409430660
  nlink: 1
  uid: 1000
  blksize: 4096
  gid: 1000
  ctime: 1409430660
  dev: 2049
  blocks: 8
...
</programlisting>
  </listitem>
  </varlistentry>

  <varlistentry>
   <term><emphasis role="lua"><replaceable>file-handle</replaceable>:fsync or <replaceable>file-handle</replaceable>:fdatasync ()</emphasis></term>
    <listitem>
      <para>
        Ensure that file changes are written to disk, for an open file.
        Compare <code>fio.sync</code>, which is for all files.
        For details type "man 2 fsync" or "man 2 fdatasync".
      </para>
      <para>
        Parameters: (type = table) file-handle, as returned by <code>fio.open()</code>.
      </para>
      <para>
        Returns: (type = boolean) true if success, false if failure.
      </para>
     <bridgehead renderas="sect4">Example</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>fh:fsync()</userinput>
---
- true
...
</programlisting>
  </listitem>
  </varlistentry>

  </variablelist>
</section>


<section xml:id="sp-console">
 <title>package <code>console</code></title>
 
     <para>
    The console package allows one Tarantool server
    to access another Tarantool server, and allows
    one Tarantool server to start listening on an
    administrative host/port.
    </para> 

 
<variablelist>
 
    <varlistentry>
     <term><emphasis role="lua">console.connect(<replaceable>host</replaceable>,<replaceable>port</replaceable>[, <replaceable>options</replaceable>])</emphasis></term>
        <listitem>
            <para>
                Connect to the server at host:port, change the prompt from
                'tarantool' to 'host:port', and act henceforth as a client
                until the user ends the session or types control-D.
            </para>
    <para>
    The console.connect function allows one Tarantool server,
    in interactive mode, to access another Tarantool
    server over a TCP connection. Subsequent requests
    will appear to be handled locally, but in reality
    the requests are being sent to the remote server
    and the local server is acting as a client.
    Once connection is successful, the prompt
    will change and subsequent requests are sent
    to, and executed on, the remote server.
    Results are displayed on the local server.
    To return to local mode, enter control-D.
    </para>
    <para>
    There are no restrictions on the types of requests
    that can be entered, except those which are due to
    privilege restrictions -- by default the login to the remote
    server is done with user name = 'guest'. The remote
    server could allow for this by granting at least
    one privilege:
    <code>box.schema.user.grant('guest','execute','universe')</code>.
    </para>
            <para>
             Parameters: <code>host</code>, <code>port</code>, <code>options</code>.
             The options may be necessary if the Tarantool server at host:port requires
             authentication. In such a case the connection might look something like:
             <code>console.connect('127.0.0.1', port, { user = 'netbox', password = '123' })</code>.
            </para>
            <para>
             Returns: nothing.
            </para>
            <para>
             Possible errors: the connection will fail if the target Tarantool server
             was not initiated with <code>box.cfg{listen=...}</code>.
            </para>
            <para>
             <bridgehead renderas="sect4">Example showing use of console</bridgehead><programlisting>
<prompt>tarantool&gt;</prompt> <userinput>console = require('console')</userinput>
---
...
<prompt>tarantool&gt;</prompt> <userinput>console.connect('198.18.44.44', 3301)</userinput>
---
...
<prompt>198.18.44.44:3301&gt;</prompt> <userinput>-- prompt is telling us that server is remote</userinput></programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
     <term><emphasis role="lua">console.listen(<replaceable>host</replaceable>,<replaceable>port</replaceable>)</emphasis></term>
        <listitem>
            <para>
                Listen on host:port. The primary way of listening for incoming
                requests is via the host and port, or uri, specified in
                <code>box.cfg{listen=...}</code>. The alternative way of
                listening is via the host and port, or uri, specified in
                <code>console.listen(...)</code>. This alternative way is
                called "administrative" or simply "admin port".
           </para>
           <para>
                Parameters: <code>host</code>, <code>port</code>.
                The listening is usually over a local host with a Unix socket,
                specified as host = 'unix/', port = 'path/to/something.sock'.
           </para>
           <para xml:id="admin_port" xreflabel="admin_port">
           The "admin" address is the port or URI to listen on for administrative
           connections. It has no default value, so it must be specified
          if connections will occur via telnet. It is not used unless
          assigned a value. The parameters may be expressed with URI = Universal
          Resource Identifier format, for example "unix://unix_domain_socket",
          or as a numeric TCP port. Connections are often made with telnet.
          A typical port value is 3313.
          </para>
        </listitem>
    </varlistentry>



   </variablelist>






</section>


<section xml:id="sp-log">
 <title>package <code>log</code></title>
     <para>
     The Tarantool server puts all diagnostic messages in a log file
     specified by the  <link linkend="logger">logger</link>
     configuration parameter. Diagnostic messages may be either
     system-generated by the server's internal code, or user-generated
     with the <code>log.<replaceable>log_level_function_name</replaceable></code> function.
     </para>
<variablelist>
    <varlistentry>
     <term><emphasis role="lua">log.<replaceable>log_level_function_name</replaceable>(<replaceable>log_message</replaceable>)</emphasis></term>
       <listitem>
         <para>
         Output a user-generated message to the <link linkend="logger">log file</link>, given
         log_level_function_name = <code>error</code> or <code>warn</code> or <code>info</code>
         or <code>debug</code> or <code>rotate</code>.
         </para>
         <para>
         Returns: nothing.
         </para>
         <para>
         Parameters: (type = string) log_message. The actual output will be a
         line containing the current timestamp, a module name, 'E' or 'W' or 'I' or 'D' or 'R' depending on
         log_level_function_name, and log_message. Output will not occur if log_level_function_name is for a type greater than
         <link linkend="log_level">log_level</link>.
         </para>
         <para>
         <bridgehead renderas="sect4">Example showing use of log</bridgehead><programlisting>
#From the shell:
#Start the server, do some requests, exit, and display the log, thus:
~/tarantool/src/tarantool
box.cfg{log_level=3, logger='tarantool.txt'}
log = require('log')
log.error('Error')
log.info('Info')
os.exit()
less tarantool.txt
</programlisting>
         The output from the <code>less</code> command will look approximately like this:
<programlisting>
2014-09-21 17:58:40.820 [5257] main/101/interactive C> version 1.6.3-355-ga4f762d
2014-09-21 17:58:40.821 [5257] main/101/interactive C> log level 3
2014-09-21 17:58:40.821 [5261] main/101/spawner C> initialized
2014-09-21 17:58:40.830 [5257] main/101/interactive [C]:-1 E> Error
</programlisting>
         The 'Error' line is visible in tarantool.txt preceded by the letter E.
         The 'Info' line is not present because the log_level is 3.
         </para>
        </listitem>
    </varlistentry>
   </variablelist>
</section>

<section xml:id="sp-tonumber64">
 <title>Lua functions <code>tonumber64</code> and <code>dostring</code></title>

<variablelist>

    <varlistentry>
        <term xml:id="tonumber64" xreflabel="tonumber64"> <emphasis role="lua">tonumber64(<replaceable>value</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Convert a string or a Lua number to a
              64-bit integer. The result can be used in arithmetic,
              and the arithmetic will be 64-bit integer arithmetic
              rather than floating-point arithmetic. (Operations on
              an unconverted Lua number use floating-point arithmetic.)
              The tonumber64() function is added by Tarantool; the name is global.
              <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>type(123456789012345), type(tonumber64(123456789012345))</userinput>
---
- number
- cdata
...
tarantool> <userinput>i = tonumber64('1000000000')</userinput>
---
...
tarantool> <userinput>type(i), i / 2, i - 2, i * 2, i + 2, i % 2, i ^ 2</userinput>
---
 - cdata
 - 500000000
 - 999999998
 - 2000000000
 - 1000000002
 - 0
 - 1000000000000000000
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    
    <varlistentry>
        <term>
            <emphasis role="lua">dostring(<replaceable>lua-chunk-string [, lua-chunk-string-argument ...]</replaceable>)</emphasis>
        </term>
        <listitem>
            <para>
              Parse and execute an arbitrary chunk of Lua code.
              This function is mainly useful to define and run
              Lua code without having to
              introduce changes to the global Lua environment.
            </para>
            <para>
              Parameters: <code>lua-chunk-string</code> = string containing Lua code,
              <code>lua-chunk-string-argument(s)</code> = zero or more scalar values
               which will be appended to, or substitute for, items in the Lua chunk.
             </para>
             <para>
               Returns: whatever is returned by the Lua code chunk.
            </para>
            <para>
               Possible errors: If there is a compilation error,
               it is raised as a Lua error.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool&gt; <userinput>dostring('abc')</userinput>
---
error: '[string "abc"]:1: ''='' expected near ''&lt;eof&gt;'''
...
tarantool&gt; <userinput>dostring('return 1')</userinput>
---
- 1
...
tarantool&gt; <userinput>dostring('return ...', 'hello', 'world')</userinput>
---
- hello
- world
...
tarantool&gt; <userinput>console = require('console'); console.delimiter('!') --<link linkend="utility-tarantool-delim">this</link> means ignore line feeds until next '!'</userinput>
tarantool&gt; <userinput>-- Use <link xlink:href="http://www.lua.org/pil/2.4.html">double square brackets</link> to enclose multi-line literal here!</userinput>
tarantool&gt; <userinput>dostring([[local f = function(key)</userinput>
        -&gt; <userinput>              t = box.space.tester:select{key};</userinput>
        -&gt; <userinput>              if t ~= nil then return t[1] else return nil end</userinput>
        -&gt; <userinput>              end</userinput>
        -&gt; <userinput>              return f(...)]], 1)!</userinput>
---
- null
...
tarantool&gt; <userinput>console.delimiter('')!</userinput>
</programlisting>
            </para>
        </listitem>
    </varlistentry>
    
</variablelist>

</section>


<section xml:id="sp-pickle">
    <title>Package <code>pickle</code></title>
<variablelist xml:id="x-pickle" xreflabel="x-pickle">
    <varlistentry>
        <term><emphasis role="lua">pickle.pack(<replaceable>format, argument [, argument ...]</replaceable>)</emphasis></term>
        <listitem><para>
            To use Tarantool binary protocol primitives from Lua,
            it's necessary to convert Lua variables to binary
            format. The pickle.pack() helper function is prototyped after Perl
            <link xlink:href="http://perldoc.perl.org/functions/pack.html">
             'pack'</link>.
            </para>
            <para>
               Parameters: <code>format</code> = string containing format specifiers, <code>argument(s)</code> = scalar values to be formatted.
            </para>
            <para>
            <bridgehead renderas="sect4">Format specifiers</bridgehead>
            <simplelist>
                <member><code>b</code> or <code>B</code> &mdash; converts Lua
                variable to a 1-byte
                integer, and stores the integer in the resulting
                string,
                </member>
                <member><code>s</code> or <code>S</code> &mdash; converts Lua
                variable to a 2-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>i</code> or <code>I</code> &mdash; converts Lua
                variable to a 4-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>l</code> or <code>L</code> &mdash; converts Lua
                variable to an 8-byte
                integer, and stores the integer in the resulting
                string, low byte first,
                </member>
                <member><code>n</code> or <code>N</code> &mdash; converts Lua
                variable to a 4-byte
                integer, and stores the integer in the resulting
                string, big endian,
                </member>
                <member><code>q</code> or <code>Q</code> &mdash; converts Lua
                variable to an 8-byte
                integer, and stores the integer in the resulting
                string, big endian,
                </member>
                <member><code>f</code> &mdash; converts Lua
                variable to a 4-byte
                float, and stores the float in the resulting
                string,
                </member>
                <member><code>d</code> &mdash; converts Lua
                variable to a 8-byte
                double, and stores the double in the resulting
                string,
                </member>
                <member><code>d</code> &mdash; converts Lua
                variable to a sequence of bytes,
                and stores the sequence in the resulting
                string,
                </member>
            </simplelist>
            </para>
            <para>
              Returns: a binary string containing all arguments, packed
              according to the format specifiers.
            </para>
            <para>
              Possible Errors: Unknown format specifier.
            </para>
            <para>
        <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
tarantool> <userinput>pickle = require('pickle')</userinput>
---
...
tarantool> <userinput>box.space.tester:insert{0, 'hello world'}</userinput>
---
- [0, 'hello world']
...
tarantool> <userinput>box.space.tester:update({0}, {{'=', 2, 'bye world'}})</userinput>
---
- [0, 'bye world']
...
tarantool> <userinput>box.space.tester:update({0}, {{'=', 2, pickle.pack('iiA', 0, 3, 'hello')}})</userinput>
---
- [0, "\0\0\0\0\x03\0\0\0hello"]
...
tarantool> <userinput>box.space.tester:update({0}, {{'=', 2, 4}})</userinput>
---
- [0, 4]
...
tarantool> <userinput>box.space.tester:update({0}, {{'+', 2, 4}})</userinput>
---
- [0, 8]
...
tarantool> <userinput>box.space.tester:update({0}, {{'^', 2, 4}})</userinput>
---
- [0, 12]
...
</programlisting>
            </para>
        </listitem>
    </varlistentry>

    <varlistentry>
        <term><emphasis role="lua">pickle.unpack(<replaceable>format, binary-string</replaceable>)</emphasis></term>
        <listitem>
            <para>
              Counterpart to <code>pickle.pack()</code>.
            </para>
            <para>
              Parameters: <code>format</code>, <code>binary-string</code>.
            </para>
            <para>
             Returns: (type = scalar) A list of strings or numbers.
            </para>
            <para>
            <bridgehead renderas="sect4">Example</bridgehead>
<programlisting>
<prompt>tarantool</prompt> <userinput>pickle = require('pickle')</userinput>
---
...
<prompt>tarantool></prompt> <userinput>console = require('console'); console.delimiter('!') -- this means following commands must end with '!'</userinput>
<prompt>tarantool></prompt> <userinput>tuple = box.space.tester:replace{0}!</userinput>
---
...
<prompt>tarantool></prompt> <userinput>string.len(tuple[1])!</userinput>
---
- 1
...
<prompt>tarantool></prompt> <userinput>pickle.unpack('b', tuple[1])!</userinput>
---
- 48
...
<prompt>tarantool></prompt> <userinput>pickle.unpack('bsi', pickle.pack('bsi', 255, 65535, 4294967295))!</userinput>
---
- 255
- 65535
- 4294967295
...
<prompt>tarantool></prompt> <userinput>pickle.unpack('ls', pickle.pack('ls', tonumber64('18446744073709551615'), 65535))!</userinput>
---
- 18446744073709551615
- 65535
...
<prompt>tarantool></prompt> <userinput>num, str, num64 = pickle.unpack('sAl', pickle.pack('sAl', 666, 'string',</userinput>
<prompt>        -></prompt> <userinput>                  tonumber64('666666666666666')))!</userinput>
---
...
<prompt>tarantool></prompt> <userinput>num, str, num64!</userinput>
---
- 666
- string
- 666666666666666
...
<prompt>tarantool></prompt> <userinput>console.delimiter('') -- back to normal: commands end with line feed!</userinput>
</programlisting>
            </para>
        </listitem>
    </varlistentry>
</variablelist>
</section>


<section xml:id="sp-expirationd">
 <title>expirationd -- the daemon that shifts expired tuples to a long-term archive</title>

<para>
For a commercial-grade example of a Lua rock that works with Tarantool,
let us look at expirationd, which Tarantool supplies on
<link xlink:href="https://github.com/tarantool/expirationd/blob/master/expirationd.lua">GitHub</link>
with an Artistic license. The expirationd.lua program is
lengthy (about 500 lines), so here we will only highlight
the matters that will be enhanced by studying the full source later.
<programlisting>
            task.worker_fiber = fiber.create(worker_loop, task)
            log.info("expiration: task %q restarted", task.name)
            ...
            fiber.sleep(expirationd.constants.check_interval)
            ...
</programlisting>
Whenever one hears "daemon" in Tarantool, one should suspect it's
being done with <olink targetptr="sp-box-fiber">fibers</olink>. The program is making a fiber
and turning control over to it so it runs occasionally, goes to
sleep, then comes back for more.
<programlisting>
    for _, tuple in scan_space.index[0]:pairs(nil, {iterator = box.index.ALL}) do
    ...
            if task.is_tuple_expired(task.args, tuple) then
            task.expired_tuples_count = task.expired_tuples_count + 1
            task.process_expired_tuple(task.space_id, task.args, tuple)
    ...
</programlisting>
The "for" instruction can be translated as "iterate through the index of
the space that is being scanned", and within it, if the tuple is "expired"
(that is, if the tuple has a timestamp field which is less than the current
time), process the tuple as an expired tuple.
<programlisting>
-- put expired tuple in archive
local function put_tuple_to_archive(space_id, args, tuple)
    -- delete expired tuple
    box.space[space_id]:delete{tuple[1]}
    local email = get_field(tuple, 2)
    if args.archive_space_id ~= nil and email ~= nil then
        box.space[args.archive_space_id]:replace{email, os.time()}
    end
end
</programlisting>
Ultimately the tuple-expiry process leads to put_tuple_to_archive()
which does a "delete" of a tuple from its original space, and an
"insert" of the same tuple into another space. Tarantool's "replace"
function is the same as an "insert" function without an error message
if a tuple with the same content already exists in the target space.
<programlisting>
function expirationd.do_test(space_id, archive_space_id)
...
</programlisting>
At this point, if the above explanation is worthwhile, it's clear that
expirationd.lua starts a background routine (fiber) which iterates
through all the tuples in a space, sleeps cooperatively so that other
fibers can operate at the same time, and -- whenever it finds a tuple
that has expired -- deletes it from this space and puts it in another
space. Now the "do_test()" function can be used to create some sample
spaces, let the daemon run for a while, and print results.
</para>
<para>
For those who like to see things run, here are the exact steps to
get expirationd through the test.
</para>
<para>
1. Get expirationd.lua.
   There are standard ways -- it is after all part of a standard rock --
   but for this purpose just copy the contents of
   <link xlink:href="https://github.com/tarantool/expirationd/blob/master/expirationd.lua">https://github.com/tarantool/expirationd/blob/master/expirationd.lua</link>
   to a default directory.
</para>
<para>
2. Start the Tarantool server as described <olink targetptr="getting-started-start-stop">before</olink>.
</para>
<para>
3. Execute these requests:
<programlisting><userinput>
     box.cfg{}
     a = box.schema.create_space('origin')
     a:create_index('first', {type = 'tree', parts = {1, 'NUM'}})
     b = box.schema.create_space('archive')
     b:create_index('first', {type = 'tree', parts = {1, 'STR'}})
     expd = require('expirationd')
     expd._debug = true
     expd.do_test('origin', 'archive')
     os.exit()
</userinput></programlisting>
The database-specific requests (cfg, create_space, create_index)
should already be familiar. The key for getting the rock rolling is
<code>expd = require('expirationd')</code>.
The "require" function is what reads in the program; it will appear
in many later examples in this manual, when it's necessary to get a
package that's not part of the Tarantool kernel. After the Lua
variable expd has been assigned the value of the expirationd package,
it's possible to invoke the package's <code>do_test()</code> function.
</para>
<para>
After a while, when the task has had time to do its iterations through
the spaces, do_test() will print out a report showing the tuples that
were originally in the original space, the tuples that have now been
moved to the archive space, and some statistics. Of course, expirationd
can be customized to do different things by passing different parameters,
which will be evident after looking in more detail at the source code.  
</para> 

</section>

</section>

<!--
vim: tw=66 syntax=docbk
vim: spell spelllang=en_us
-->
