<!DOCTYPE book [
<!ENTITY % tnt SYSTEM "../tnt.ent">
%tnt;
]>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="connectors">

<title>Connectors</title>
<blockquote><para>
  This chapter documents APIs for various programming languages.
</para></blockquote>

<section xml:id="protocol">
 <title>Protocol</title>
  <para>Tarantool protocol was designed with focus on asynchronous
    I/O and easy integration with proxies. Each client
    request starts with a variable-length binary header, containing
    request id, request type, server id, log sequence number, and
    so on.
  </para>

 <para>
    The mandatory length, present in request header simplifies
    client or proxy I/O.  A response to a request is sent to the
    client as soon as it is ready. It always carries in its header
    the same type and id as in the request. The id makes it
    possible to match a request to a response, even if the latter
    arrived out of order.
  </para>

  <para>Unless implementing a client driver, one needn't
    concern oneself with the complications of the binary
    protocol. <olink targetptr="connectors">Language-specific
    drivers</olink> provide a friendly way to store domain
    language data structures in Tarantool.
    A complete description of the binary protocol
    is maintained in annotated Backus-Naur
    form in the source tree: please see
    <link xlink:href="http://tarantool.org/doc/box-protocol.html"><filename>doc/box-protocol.html</filename></link>.
  </para>
</section>

<section xml:id="connector-packet-example">
<title>Packet example</title>
<para>
The Tarantool API exists so that a client program can send a request packet
to the server, and receive a response. Here is an example of a what the client
 would send for <command>box.space[513]:insert{'A', 'BB'}</command>. The BNF description of the components
is in file <link xlink:href="http://tarantool.org/doc/box-protocol.html" xlink:title="A complete BNF of Tarantool client/server protocol">doc/box-protocol.html</link>.
 A third-party contribution written in Lua for unpacking Tarantool messages is in file 
 <link xlink:href="https://github.com/negram/Tnt-dissector/blob/master/tarantool.dis.lua" xlink:title="tarantool.dis.lua">Tnt-dissector</link>.

</para>
                <informaltable frame='topbot'>
                <tgroup cols='5' align='left' colsep='1' rowsep='1'>
                <colspec colname='c1'/>
                <colspec colname='c2'/>
                <colspec colname='c3'/>
                <colspec colname='c4'/>
                <colspec colname='c5'/>
                <thead>
                <row>
                <entry>Component</entry>
                <entry>Byte#0</entry>
                <entry>Byte#1</entry>
                <entry>Byte#2</entry>
                <entry>Byte#3</entry>
                </row>
                </thead>
                      <tbody>
                        <row>
                          <entry>type</entry>
                          <entry>13</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                        </row>
                        <row>
                          <entry>body_length</entry>
                          <entry>17</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                        </row>
                        <row>
                          <entry>request_id</entry>
                          <entry>1</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                        </row>
                        <row>
                          <entry>flags</entry>
                          <entry>2</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                          <entry>0</entry>
                        </row>
                        <row>
                          <entry>map-element count</entry>
                          <entry>82</entry>
                          <entry>10</entry>
                        </row>
                        <row>
                          <entry>2-digit number: space id</entry>
                          <entry>cd</entry>
                          <entry>02</entry>
                          <entry>03</entry>
                        </row>
                        <row>
                          <entry>1-character string: field[1]</entry>
                          <entry>a1</entry>
                          <entry>41</entry>
                        </row>
                        <row>
                          <entry>2-character string: field[2]</entry>
                          <entry>a2</entry>
                          <entry>42</entry>
                          <entry>42</entry>
                        </row>
                       </tbody>
                    </tgroup>
                </informaltable>
<para>
Now, one could send that packet to the tarantool server,
and interpret the response (doc/box-protocol.html has a description
of the packet format for responses as well as requests).
But it would be easier, and less error-prone, if one could
invoke a routine that formats the packet according to typed
parameters. Something like <code>response=tarantool_routine("insert",0,"A","B");</code>.
And that is why APIs exist for drivers for C, Perl, Python, PHP, Ruby, and so on.
</para>
  </section>

  <section xml:id="connector-c">
    <title>C</title>
    <para>
    Here is a complete C program that inserts [99999,'BB'] into space[513] via the C API for the
    binary protocol. To compile, paste the code into a file named example.c and say <code>
    gcc -o example example.c -I/<replaceable>tarantool-directory</replaceable>/connector/c/include</code>
    where tarantool-directory = the directory that contains
    the necessary file <filename>tp.h</filename>, and the default library path contains
    the directory where Tarantool library files were placed at installation time.
    Before trying to run, check that the server
    (tarantool) is running on localhost (127.0.0.1) and its listen address is the default
    (local host, port 3301) and
    space[513]'s primary key type is numeric (space[513].index[0].key_field[1].type = "NUM").
    To run, say <code>./example</code>.
    The program will open a socket connection with the tarantool server at localhost:3301,
    then format a buffer for sending an INSERT request, then send the request, then check if the
    server returned an error, then &mdash; if all is well &mdash; print "Insert succeeded". If the
    row already exists, the program will print <quote>Duplicate key exists in unique index 0</quote>.
    </para>
<programlisting language="cpp">
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#define MP_SOURCE 1   
#include &lt;tp.h&gt;                                                /* the usual Tarantool include */

int main()
{
  struct tp request;                                           /* area for sending to server */
  struct tpgreeting greet;                                     /* area for the server's greeting */
  struct tpresponse response;                                  /* area for translation of reply */
  int fd;                                                      /* file descriptor for socket */
  struct sockaddr_in sock;                                     /* the usual socket address info */
  if ((fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt;= 0)   /* open the socket. abort if failure */
    exit(1);
  memset(&amp;sock, 0, sizeof(sock));                              /* connect to localhost:3301 */
  sock.sin_family = AF_INET;
  sock.sin_addr.s_addr = inet_addr("127.0.0.1");
  sock.sin_port = htons(3301);
  if (connect(fd, (struct sockaddr *)&amp;sock, sizeof(sock)) &lt; 0) /* connect, abort if failure */
    exit(1);
  const int greeting_buffer_size = 128;                        /* handle the server's greeting */
  char greeting_buffer[greeting_buffer_size];
  if (read(fd, greeting_buffer, greeting_buffer_size) != 128)  /* greeting must be 128 bytes long */
    exit(1);
  tp_greeting(&amp;greet, greeting_buffer, 128);                   /* 
  char request_buffer[1024];                                   /* initialize request buffer */
  tp_init(&amp;request, request_buffer, 1024, 0, 0);
  tp_insert(&amp;request, 513);                                    /* append INSERT header. space_no=513 */
  tp_tuple(&amp;request, 2);                                       /* begin appending body, field count = 2 */
  tp_encode_uint(&amp;request, 99999);                             /* append field[1] */
  tp_sz(&amp;request, "BB");                                       /* append field[2] */
  int rc = write(fd, tp_buf(&amp;request), tp_used(&amp;request));     /* send the INSERT request */
  if (rc != tp_used(&amp;request))                                 /* abort if send failed */
    exit(1);
  char reply_buffer[1024];
  int rres = read(fd, reply_buffer, 1024);                     /* get reply */
  if (rres &lt;= 0) exit(1);
  if (tp_reply(&amp;response, reply_buffer, rres) &lt; 0) exit(1);
  if (response.error != 0) {                                   /* display+abort if error e.g. duplicate key */
    printf("Error: %*s\n",
    (int) (response.error_end-response.error),response.error);
    exit(1);
  }
  close(fd);                                                   /* clean up */
  printf("Insert succeeded\n");                                /* congratulate self */
  exit(0);
}
</programlisting>
    <para>
       The example program only shows one command and does not show all that's necessary for
       good practice. For that, please see the <link
       xlink:href="https://github.com/tarantool/tarantool-c"><filename>connector/c</filename></link> source tree.
    </para>
  </section>

  <section xml:id="connector-erlang">
    <title>Erlang</title>
    <para>
       Please see <link xlink:href="https://github.com/tarantool/tarantool-erlang"><filename>https://github.com/tarantool/tarantool-erlang</filename></link>.
    </para>
  </section>

  <section xml:id="connector-java">
    <title>Java</title>
    <para>
       Please see <link xlink:href="http://dgreenru.github.io/tarantool-java/"><filename>http://dgreenru.github.io/tarantool-java/</filename></link>.
    </para>
  </section>

  <section xml:id="connector-node.js">
    <title>node.js</title>
    <para>
       Please see <link xlink:href="https://github.com/devgru/node-tarantool"><filename>http://github.com/devgru/node-tarantool</filename></link>.
    </para>
  </section>

  <section xml:id="connector-perl">
    <title>Perl</title>
    <para>
     The most commonly used Perl driver is <link xlink:href='http://search.cpan.org/~unera/DR-Tarantool/'>DR::Tarantool</link>.
     It is not supplied as part of the Tarantool repository; it must be installed separately.
     The most common way to install it is with <link xlink:href='https://en.wikipedia.org/wiki/Cpan'>CPAN, the Comprehensive Perl Archive Network</link>.
     DR::Tarantool requires other modules which should be installed first.
     For example, on Ubuntu, the installation could look like this:
      <programlisting>
sudo cpan install AnyEvent
sudo cpan install Devel::GlobalDestruction
sudo cpan install Coro
sudo cpan install Test::Pod
sudo cpan install Test::Spelling
sudo cpan install PAR::Dist
sudo cpan install DR::Tarantool
      </programlisting>
     </para>
    <para>
    Here is a complete Perl program that inserts [99999,'BB'] into space[0] via the Perl API.
    Before trying to run, check that the server
    (tarantool) is running on localhost (127.0.0.1) and its listen address is the default
    (local host, port 3301) and
    space[0]'s primary key type is numeric (space[0].index[0].key_field[1].type = "NUM").
    To run, paste the code into a file named example.pl and say <code>perl example.pl</code>.
    The program will connect using an application-specific definition of the space.
    The program will open a socket connection
    with the tarantool server at localhost:3301, then send an INSERT request,
    then &mdash; if all is well &mdash; end without displaying any messages.
    If tarantool is not running on localhost with listen address = port 3301, the program will print
    <quote>Connection refused</quote>.
    </para>
    <para>
     <programlisting language="perl">
#!/usr/bin/perl
use DR::Tarantool ':constant', 'tarantool';
use DR::Tarantool ':all';

my $tnt = tarantool
  host    =&gt; '127.0.0.1',                      # look for tarantool on localhost
  port    =&gt; 3301,                             # assume tarantool listen address = default
  spaces  =&gt; {
    0 =&gt; {                                     # definition of space[0] ...
      name =&gt; 't0',                            #   space[0] name = 't0'
      default_type =&gt; 'STR',                   #   space[0] field type is 'STR' if undefined
      fields =&gt; [ {                            #   definition of space[0].fields ...
          name =&gt; 'k0', type =&gt; 'NUM' } ],     #     space[0].field[1] name='k0',type='NUM'
      indexes =&gt; {                             #   definition of space[0] indexes ...
        0 =&gt; {
          name =&gt; 'k0', fields =&gt; 'k0' } } } };

$tnt-&gt;insert('t0' => [ 99999, 'BB' ]);         # INSERT INTO t0 VALUES (99999,'BB')
     </programlisting>
    </para>
    <para>
       The example program only shows one command and does not show all that's necessary for
       good practice. For that, please see
       <link xlink:href='http://search.cpan.org/~unera/DR-Tarantool/'>DR::Tarantool CPAN repository</link>.
    </para>
  </section>

  <section xml:id="connector-php">
    <title>PHP</title>
    
    <para>
    The PHP driver is <link xlink:href='https://github.com/tarantool/tarantool-php'>tarantool-php</link>.
    It is not supplied as part of the Tarantool repository; it must be installed separately.
    It can be installed with git.
    It requires other modules which should be installed first.
    For example, on Ubuntu, the installation could look like this:
    <programlisting>
sudo apt-get install php5-cli
sudo apt-get install php5-dev
sudo apt-get install php-pear
cd ~
git clone https://github.com/tarantool/tarantool-php.git
cd tarantool-php
phpize
./configure
make
make install
    </programlisting>
    </para>    
    <para>
    At this point there is a file named <filename>~/tarantool-php/modules/tarantool.so</filename>.
    PHP will only find it if the PHP initialization file <filename>php.ini</filename> contains a line like
    <code>extension=./tarantool.so</code>.
    So copy <filename>tarantool.so</filename> to the working directory and tell PHP where
    to find the <filename>php.ini</filename> file that contains that line ...
    <programlisting>
cd ~
cp ./tarantool-php/modules/tarantool.so .
export PHP_INI_SCAN_DIR=~/tarantool-php/test/share
   </programlisting>
    </para>
    <para>
    Here is a complete PHP program that inserts [99999,'BB'] into space[0] via the PHP API.
    Before trying to run, check that the server
    (tarantool) is running on localhost (127.0.0.1) and its listen address is the default
    (local host, port 3301) and
    space[0]'s primary key type is numeric (space[0].index[0].key_field[1].type = "NUM").
    To run, paste the code into a file named example.php and say <code>php example.php</code>.
    The program will open a socket connection
    with the tarantool server at localhost:3301, then send an INSERT request,
    then &mdash; if all is well &mdash; print "Insert succeeded".
    If the tuple already exists, the program will print <quote>Duplicate key exists in unique index 0</quote>.
    </para>
    <para>
    <programlisting>
&lt;?php
$tarantool = new Tarantool("localhost", 3301, 3313);
try {
  $tarantool-&gt;insert(0, array(99999, "BB"), TARANTOOL_FLAGS_ADD);
  print "Insert succeeded\n";
  }
catch (Exception $e) {
  echo "Exception: ", $e-&gt;getMessage(), "\n";
  }
?&gt;
    </programlisting>
    </para>
    <para>
    The example program only shows one command and does not show all that's necessary for
    good practice. For that, please see
    <link
    xlink:href="https://github.com/tarantool/tarantool-php/"><filename>tarantool-php</filename></link> project at GitHub.
    </para>
  </section>

  <section xml:id="connector-python">
    <title>Python</title>
    <para>
    Here is a complete Python program that inserts ['First Tuple','Value','Value'] into space99 via the high-level Python API.
    To prepare, paste the code into a file named example.py and install tarantool-python with either
    <userinput><code>pip install tarantool</code></userinput> to install in <filename>/usr</filename> (requires root privilege)
    or
    <userinput><code>pip install tarantool --user</code></userinput> to install in <filename>~</filename> i.e. user's default directory.
    The program is assuming that the server (tarantool) is running on localhost (127.0.0.1) and its listen address is
    the default (local host, port 3301) and space99's primary key type is string (box.space.space99.index['primary'].key_field[1].type = "STR")
    and user 'guest' has permission to read and write on space99. An administrator could fulfill all those conditions by
    starting the tarantool server and executing these requests:<programlisting>
box.cfg{listen = 3301}
box.schema.create_space('space99') 
box.space.space99:create_index('primary',{parts = {1,'STR'}})
box.schema.user.grant('guest', 'read', 'space', '_space')
box.schema.user.grant('guest', 'read,write', 'space', 'space99')</programlisting>
    To run the program, say <code>python example.py</code>.
    The program will connect to the server, will send the request, and will not throw an exception if all went well.
    If the tuple already exists, the program will throw DatabaseException(“Duplicate key exists in unique index”).
    </para>
<programlisting language="python">
#!/usr/bin/python
from tarantool import Connection

c = Connection("127.0.0.1", 3301)
result = c.insert("space99",('First Tuple','Value', 'Value'))
print result
</programlisting>
    <para>
       The example program only shows one request and does not show all that's necessary for
       good practice. For that, please see
       <link xlink:href="http://tarantool-python.readthedocs.org/en/latest/"><filename>http://tarantool-python.readthedocs.org/en/latest/</filename></link>.
       For an example of a Python API for <link xlink:href="https://github.com/tarantool/queue">Queue managers on Tarantool</link>, see 
       <link xlink:href="https://github.com/tarantool/tarantool-queue-python"><filename>https://github.com/tarantool/tarantool-queue-python</filename></link>.
    </para>
  </section>

  <section xml:id="connector-ruby">
    <title>Ruby</title>
    <para>
       You need <emphasis role="strong">Ruby 1.9</emphasis> or later
       to use this connector. Connector sources are located in <link
       xlink:href="https://github.com/mailru/tarantool-ruby"><filename>http://github.com/mailru/tarantool-ruby</filename></link>.
    </para>
  </section>

</chapter>

<!--
vim: tw=66 syntax=docbk
vim: spell spelllang=en_us
-->
