<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tarantool: src/module.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tarantool
   </div>
   <div id="projectbrief">Get your data in RAM. Get compute close to data. Enjoy the performance.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">module.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;lua.h&quot;</code><br />
</div>
<p><a href="module_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPACKED.html">PACKED</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public representation of a key part definition.  <a href="unionPACKED.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionfield__type__params.html">field_type_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra parameters for parametric types like FIELD_TYPE_DECIMAL32 etc.  <a href="unionfield__type__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbox__decimal.html">box_decimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="structbox__decimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac5f2c7580fd5bf200c5027443420902f" id="r_ac5f2c7580fd5bf200c5027443420902f"><td class="memItemLeft" align="right" valign="top"><a id="ac5f2c7580fd5bf200c5027443420902f" name="ac5f2c7580fd5bf200c5027443420902f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PACKAGE_VERSION_MAJOR</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ac5f2c7580fd5bf200c5027443420902f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package major version - 1 for 1.6.7. <br /></td></tr>
<tr class="separator:ac5f2c7580fd5bf200c5027443420902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab155eaff0a115e522c1faae631196e" id="r_a4ab155eaff0a115e522c1faae631196e"><td class="memItemLeft" align="right" valign="top"><a id="a4ab155eaff0a115e522c1faae631196e" name="a4ab155eaff0a115e522c1faae631196e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PACKAGE_VERSION_MINOR</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a4ab155eaff0a115e522c1faae631196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package minor version - 6 for 1.6.7. <br /></td></tr>
<tr class="separator:a4ab155eaff0a115e522c1faae631196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1dbec4fd6761084d3e0c05afe2b138" id="r_abd1dbec4fd6761084d3e0c05afe2b138"><td class="memItemLeft" align="right" valign="top"><a id="abd1dbec4fd6761084d3e0c05afe2b138" name="abd1dbec4fd6761084d3e0c05afe2b138"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PACKAGE_VERSION_PATCH</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:abd1dbec4fd6761084d3e0c05afe2b138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package patch version - 7 for 1.6.7. <br /></td></tr>
<tr class="separator:abd1dbec4fd6761084d3e0c05afe2b138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa326a05d5e30f9e9a4bb0b4469d5d0c0" id="r_aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa326a05d5e30f9e9a4bb0b4469d5d0c0">PACKAGE_VERSION</a>&#160;&#160;&#160;&quot;3.5.0-entrypoint-101-g0ba7505b96&quot;</td></tr>
<tr class="memdesc:aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string with major-minor-patch-commit-id identifier of the release, e.g.  <br /></td></tr>
<tr class="separator:aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63a17703ee9303be2682b7bb08e7a9f" id="r_ad63a17703ee9303be2682b7bb08e7a9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad63a17703ee9303be2682b7bb08e7a9f">TZDATA_VERSION</a>&#160;&#160;&#160;&quot;2022a&quot;</td></tr>
<tr class="memdesc:ad63a17703ee9303be2682b7bb08e7a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string with tag identifier of the tzdata release, e.g.  <br /></td></tr>
<tr class="separator:ad63a17703ee9303be2682b7bb08e7a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6d1259777e8f56c6260be6faed183e" id="r_adb6d1259777e8f56c6260be6faed183e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adb6d1259777e8f56c6260be6faed183e">SYSCONF_DIR</a>&#160;&#160;&#160;&quot;etc&quot;</td></tr>
<tr class="memdesc:adb6d1259777e8f56c6260be6faed183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:adb6d1259777e8f56c6260be6faed183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643b6b7ac15874197420e2adbea8b6bb" id="r_a643b6b7ac15874197420e2adbea8b6bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a643b6b7ac15874197420e2adbea8b6bb">INSTALL_PREFIX</a>&#160;&#160;&#160;&quot;/usr/local&quot;</td></tr>
<tr class="memdesc:a643b6b7ac15874197420e2adbea8b6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install prefix (e.g.  <br /></td></tr>
<tr class="separator:a643b6b7ac15874197420e2adbea8b6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040141d0f88e012c0b915e3531fef5cc" id="r_a040141d0f88e012c0b915e3531fef5cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a040141d0f88e012c0b915e3531fef5cc">BUILD_TYPE</a>&#160;&#160;&#160;&quot;Debug&quot;</td></tr>
<tr class="memdesc:a040141d0f88e012c0b915e3531fef5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build type, e.g.  <br /></td></tr>
<tr class="separator:a040141d0f88e012c0b915e3531fef5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9f90a1d4b7435c509fd2020e4aa88" id="r_ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac8c9f90a1d4b7435c509fd2020e4aa88">BUILD_INFO</a>&#160;&#160;&#160;&quot;Linux-x86_64-Debug&quot;</td></tr>
<tr class="memdesc:ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">CMake build type signature, e.g.  <br /></td></tr>
<tr class="separator:ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863d95c06ae4d073ea443a8ae48c5b6" id="r_a2863d95c06ae4d073ea443a8ae48c5b6"><td class="memItemLeft" align="right" valign="top"><a id="a2863d95c06ae4d073ea443a8ae48c5b6" name="a2863d95c06ae4d073ea443a8ae48c5b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUILD_OPTIONS</b>&#160;&#160;&#160;&quot;cmake . -DCMAKE_INSTALL_PREFIX=/usr/local -DENABLE_BACKTRACE=TRUE&quot;</td></tr>
<tr class="memdesc:a2863d95c06ae4d073ea443a8ae48c5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line used to run CMake. <br /></td></tr>
<tr class="separator:a2863d95c06ae4d073ea443a8ae48c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835dbb7b4216a8258c588d9781a3b66b" id="r_a835dbb7b4216a8258c588d9781a3b66b"><td class="memItemLeft" align="right" valign="top"><a id="a835dbb7b4216a8258c588d9781a3b66b" name="a835dbb7b4216a8258c588d9781a3b66b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMPILER_INFO</b>&#160;&#160;&#160;&quot;GNU-13.3.0&quot;</td></tr>
<tr class="memdesc:a835dbb7b4216a8258c588d9781a3b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiler ID and version, assuming the C and C++ compiler IDs are equal. <br /></td></tr>
<tr class="separator:a835dbb7b4216a8258c588d9781a3b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc01d1a8b018ef75d112a8f51dde4e27" id="r_adc01d1a8b018ef75d112a8f51dde4e27"><td class="memItemLeft" align="right" valign="top"><a id="adc01d1a8b018ef75d112a8f51dde4e27" name="adc01d1a8b018ef75d112a8f51dde4e27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TARANTOOL_C_FLAGS</b>&#160;&#160;&#160;&quot; -fexceptions -funwind-tables -fasynchronous-unwind-tables -fno-common -msse2 -Wformat -Wformat-security -Werror=format-security -fstack-protector-strong -fPIC -fmacro-prefix-map=/home/runner/work/tarantool/tarantool=. -std=c11 -Wall -Wextra -Wno-gnu-<a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>-expression -fno-gnu89-inline -Wno-cast-function-type -Werror -g -ggdb -O0 &quot;</td></tr>
<tr class="memdesc:adc01d1a8b018ef75d112a8f51dde4e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">C compile flags used to build Tarantool. <br /></td></tr>
<tr class="separator:adc01d1a8b018ef75d112a8f51dde4e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2118c0a1a997878f04f860b4049ca934" id="r_a2118c0a1a997878f04f860b4049ca934"><td class="memItemLeft" align="right" valign="top"><a id="a2118c0a1a997878f04f860b4049ca934" name="a2118c0a1a997878f04f860b4049ca934"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TARANTOOL_CXX_FLAGS</b>&#160;&#160;&#160;&quot; -fexceptions -funwind-tables -fasynchronous-unwind-tables -fno-common -msse2 -Wformat -Wformat-security -Werror=format-security -fstack-protector-strong -fPIC -fmacro-prefix-map=/home/runner/work/tarantool/tarantool=. -std=c++17 -Wall -Wextra -Wno-invalid-<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a> -Wno-gnu-<a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>-expression -Wno-cast-function-type -Werror -g -ggdb -O0 &quot;</td></tr>
<tr class="memdesc:a2118c0a1a997878f04f860b4049ca934"><td class="mdescLeft">&#160;</td><td class="mdescRight">CXX compile flags used to build Tarantool. <br /></td></tr>
<tr class="separator:a2118c0a1a997878f04f860b4049ca934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bca7e3d39f063be25a9d61a0a9d421" id="r_a44bca7e3d39f063be25a9d61a0a9d421"><td class="memItemLeft" align="right" valign="top"><a id="a44bca7e3d39f063be25a9d61a0a9d421" name="a44bca7e3d39f063be25a9d61a0a9d421"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_LIBDIR</b>&#160;&#160;&#160;&quot;/usr/local/lib/tarantool&quot;</td></tr>
<tr class="memdesc:a44bca7e3d39f063be25a9d61a0a9d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to install *.lua module files. <br /></td></tr>
<tr class="separator:a44bca7e3d39f063be25a9d61a0a9d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114e8df5bc35951db601268ec25d600" id="r_a8114e8df5bc35951db601268ec25d600"><td class="memItemLeft" align="right" valign="top"><a id="a8114e8df5bc35951db601268ec25d600" name="a8114e8df5bc35951db601268ec25d600"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_LUADIR</b>&#160;&#160;&#160;&quot;/usr/local/share/tarantool&quot;</td></tr>
<tr class="memdesc:a8114e8df5bc35951db601268ec25d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to install *.so / *.dylib module files. <br /></td></tr>
<tr class="separator:a8114e8df5bc35951db601268ec25d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a42b6eee771a85d83b371c0f22337" id="r_a516a42b6eee771a85d83b371c0f22337"><td class="memItemLeft" align="right" valign="top"><a id="a516a42b6eee771a85d83b371c0f22337" name="a516a42b6eee771a85d83b371c0f22337"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_INCLUDEDIR</b>&#160;&#160;&#160;&quot;/usr/local/include/tarantool&quot;</td></tr>
<tr class="memdesc:a516a42b6eee771a85d83b371c0f22337"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to Lua includes (the same directory where this file is contained) <br /></td></tr>
<tr class="separator:a516a42b6eee771a85d83b371c0f22337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e471f2a326d5e86e09a56f9da3d383f" id="r_a5e471f2a326d5e86e09a56f9da3d383f"><td class="memItemLeft" align="right" valign="top"><a id="a5e471f2a326d5e86e09a56f9da3d383f" name="a5e471f2a326d5e86e09a56f9da3d383f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_LUAPATH</b>&#160;&#160;&#160;&quot;/usr/local/share/tarantool/?.lua;/usr/local/share/tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/init.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua&quot;</td></tr>
<tr class="memdesc:a5e471f2a326d5e86e09a56f9da3d383f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant added to package.path in Lua to find *.lua module files. <br /></td></tr>
<tr class="separator:a5e471f2a326d5e86e09a56f9da3d383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a0a80ad0559e26298ce670050609e2" id="r_a83a0a80ad0559e26298ce670050609e2"><td class="memItemLeft" align="right" valign="top"><a id="a83a0a80ad0559e26298ce670050609e2" name="a83a0a80ad0559e26298ce670050609e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_LIBPATH</b>&#160;&#160;&#160;&quot;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/lib/x86_64-linux-gnu/lua/luarocks/lib/tarantool/?.so;/usr/lib/x86_64-linux-gnu/tarantool/?.so;/usr/local/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/lib/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/luarocks/lib/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so&quot;</td></tr>
<tr class="memdesc:a83a0a80ad0559e26298ce670050609e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant added to package.cpath in Lua to find *.so module files. <br /></td></tr>
<tr class="separator:a83a0a80ad0559e26298ce670050609e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894125cfa770b79267d0eb49e83c2279" id="r_a894125cfa770b79267d0eb49e83c2279"><td class="memItemLeft" align="right" valign="top"><a id="a894125cfa770b79267d0eb49e83c2279" name="a894125cfa770b79267d0eb49e83c2279"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MODULE_LIBSUFFIX</b>&#160;&#160;&#160;&quot;.so&quot;</td></tr>
<tr class="memdesc:a894125cfa770b79267d0eb49e83c2279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared library suffix - ".so" on Linux, ".dylib" on Mac. <br /></td></tr>
<tr class="separator:a894125cfa770b79267d0eb49e83c2279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af989845e24678c452b9222afdac95e7f" id="r_af989845e24678c452b9222afdac95e7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af989845e24678c452b9222afdac95e7f">__has_feature</a>(x)&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:af989845e24678c452b9222afdac95e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:af989845e24678c452b9222afdac95e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447121dcab4275b7839a56082b7a1ab8" id="r_a447121dcab4275b7839a56082b7a1ab8"><td class="memItemLeft" align="right" valign="top"><a id="a447121dcab4275b7839a56082b7a1ab8" name="a447121dcab4275b7839a56082b7a1ab8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_builtin</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a447121dcab4275b7839a56082b7a1ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special operator __has_builtin (operand) may be used in constant integer contexts and in preprocessor "#if" and "#elif" expressions to test whether the symbol named by its operand is recognized as a built-in function by GCC in the current language and conformance mode. <br /></td></tr>
<tr class="separator:a447121dcab4275b7839a56082b7a1ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2d7742701f3f112afbcd8d4f9ccdb" id="r_a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memItemLeft" align="right" valign="top"><a id="a54d2d7742701f3f112afbcd8d4f9ccdb" name="a54d2d7742701f3f112afbcd8d4f9ccdb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_attribute</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special operator __has_attribute (operand) may be used in "#if" and "#elif" expressions to test whether the attribute referenced by its operand is recognized by GCC. <br /></td></tr>
<tr class="separator:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed0a618f017e128a5d8654754f792db" id="r_aeed0a618f017e128a5d8654754f792db"><td class="memItemLeft" align="right" valign="top"><a id="aeed0a618f017e128a5d8654754f792db" name="aeed0a618f017e128a5d8654754f792db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_cpp_attribute</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aeed0a618f017e128a5d8654754f792db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The special operator __has_cpp_attribute (operand) may be used in "#if" and "#elif" expressions in C++ code to test whether the attribute referenced by it operand is recognized by GCC. <br /></td></tr>
<tr class="separator:aeed0a618f017e128a5d8654754f792db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a0bd562b98ae8c2ffce44935351e1" id="r_a217a0bd562b98ae8c2ffce44935351e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a217a0bd562b98ae8c2ffce44935351e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiler-independent built-ins.  <br /></td></tr>
<tr class="separator:a217a0bd562b98ae8c2ffce44935351e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c45889010c1bd68631771b64f18101" id="r_ac6c45889010c1bd68631771b64f18101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:ac6c45889010c1bd68631771b64f18101"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may use <a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1" title="Compiler-independent built-ins.">likely()</a>/unlikely() to provide the compiler with branch prediction information.  <br /></td></tr>
<tr class="separator:ac6c45889010c1bd68631771b64f18101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6458adcc00e90c64bc87db324d1602" id="r_add6458adcc00e90c64bc87db324d1602"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#add6458adcc00e90c64bc87db324d1602">prefetch</a>(addr, ...)&#160;&#160;&#160;((void) addr)</td></tr>
<tr class="memdesc:add6458adcc00e90c64bc87db324d1602"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed.  <br /></td></tr>
<tr class="separator:add6458adcc00e90c64bc87db324d1602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d08c1b23d67eca942da0ac012d89f3" id="r_a86d08c1b23d67eca942da0ac012d89f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3">unreachable</a>()&#160;&#160;&#160;(assert(0))</td></tr>
<tr class="memdesc:a86d08c1b23d67eca942da0ac012d89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If control flow reaches the point of the <a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3" title="If control flow reaches the point of the unreachable(), the program is undefined.">unreachable()</a>, the program is undefined.  <br /></td></tr>
<tr class="separator:a86d08c1b23d67eca942da0ac012d89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd049f7ad59dbe455f460807475c2841" id="r_afd049f7ad59dbe455f460807475c2841"><td class="memItemLeft" align="right" valign="top"><a id="afd049f7ad59dbe455f460807475c2841" name="afd049f7ad59dbe455f460807475c2841"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>offsetof</b>(type,  member)&#160;&#160;&#160;((size_t)&amp;((type *)0)-&gt;member)</td></tr>
<tr class="memdesc:afd049f7ad59dbe455f460807475c2841"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macro offsetof expands to an integral constant expression of type size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any. <br /></td></tr>
<tr class="separator:afd049f7ad59dbe455f460807475c2841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c317a42292b61c93aae91e59118a46" id="r_af8c317a42292b61c93aae91e59118a46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>(ptr,  type,  member)</td></tr>
<tr class="memdesc:af8c317a42292b61c93aae91e59118a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to retrieve an enclosing structure from a pointer to a nested element.  <br /></td></tr>
<tr class="separator:af8c317a42292b61c93aae91e59118a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f3cf1114cea323f428ee90a531c62" id="r_a131f3cf1114cea323f428ee90a531c62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a131f3cf1114cea323f428ee90a531c62">alignas</a>(_n)</td></tr>
<tr class="memdesc:a131f3cf1114cea323f428ee90a531c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11/C++11 keyword.  <br /></td></tr>
<tr class="separator:a131f3cf1114cea323f428ee90a531c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed9482331696beaadb8ab2e6b4dfead" id="r_a3ed9482331696beaadb8ab2e6b4dfead"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>(_T)&#160;&#160;&#160;<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(struct { char c; _T member; }, member)</td></tr>
<tr class="memdesc:a3ed9482331696beaadb8ab2e6b4dfead"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11/C++11 operator.  <br /></td></tr>
<tr class="separator:a3ed9482331696beaadb8ab2e6b4dfead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d932791f722cd5b75c111e51ef2023" id="r_a07d932791f722cd5b75c111e51ef2023"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a07d932791f722cd5b75c111e51ef2023">MAYBE_UNUSED</a></td></tr>
<tr class="memdesc:a07d932791f722cd5b75c111e51ef2023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built-ins }}}.  <br /></td></tr>
<tr class="separator:a07d932791f722cd5b75c111e51ef2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13e44576a768044e199191d4f26f7e" id="r_abf13e44576a768044e199191d4f26f7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abf13e44576a768044e199191d4f26f7e">NODISCARD</a></td></tr>
<tr class="memdesc:abf13e44576a768044e199191d4f26f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagnostic is generated when a function is marked with NODISCARD and the function call appears as a potentially-evaluated discarded-value expression that is not explicitly cast to void.  <br /></td></tr>
<tr class="separator:abf13e44576a768044e199191d4f26f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b173d22e57d9395897acbd8de62d505" id="r_a1b173d22e57d9395897acbd8de62d505"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1b173d22e57d9395897acbd8de62d505">NOINLINE</a></td></tr>
<tr class="memdesc:a1b173d22e57d9395897acbd8de62d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attribute prevents a function from being considered for inlining.  <br /></td></tr>
<tr class="separator:a1b173d22e57d9395897acbd8de62d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dec568e79152c892dcf63f445cbd7a" id="r_aa1dec568e79152c892dcf63f445cbd7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a>&#160;&#160;&#160;inline</td></tr>
<tr class="memdesc:aa1dec568e79152c892dcf63f445cbd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the 'always_inline' attribute to the function if it's supported.  <br /></td></tr>
<tr class="separator:aa1dec568e79152c892dcf63f445cbd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1728270d73c5d1598de1fd691762eb1" id="r_aa1728270d73c5d1598de1fd691762eb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa1728270d73c5d1598de1fd691762eb1">NORETURN</a></td></tr>
<tr class="memdesc:aa1728270d73c5d1598de1fd691762eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function declared as NORETURN shall not return to its caller.  <br /></td></tr>
<tr class="separator:aa1728270d73c5d1598de1fd691762eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033c6face33bc7db165c0ba591696fcc" id="r_a033c6face33bc7db165c0ba591696fcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a033c6face33bc7db165c0ba591696fcc">DEPRECATED</a>(_msg)</td></tr>
<tr class="memdesc:a033c6face33bc7db165c0ba591696fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DEPRECATED attribute can be applied to a function, a variable, or a type.  <br /></td></tr>
<tr class="separator:a033c6face33bc7db165c0ba591696fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3652cae8b48c1ad174f0b06bbd06d0" id="r_a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="memItemLeft" align="right" valign="top"><a id="a5e3652cae8b48c1ad174f0b06bbd06d0" name="a5e3652cae8b48c1ad174f0b06bbd06d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>API_EXPORT</b>&#160;&#160;&#160;extern</td></tr>
<tr class="memdesc:a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API_EXPORT attribute declares public C API function. <br /></td></tr>
<tr class="separator:a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df7795fe4158ac681564ae0520d975" id="r_a75df7795fe4158ac681564ae0520d975"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a75df7795fe4158ac681564ae0520d975">CFORMAT</a>(archetype,  stringindex,  firsttocheck)</td></tr>
<tr class="memdesc:a75df7795fe4158ac681564ae0520d975"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CFORMAT attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments that should be type-checked against a format string.  <br /></td></tr>
<tr class="separator:a75df7795fe4158ac681564ae0520d975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d525cf4d116b2fe4ecc00222b256f1" id="r_a36d525cf4d116b2fe4ecc00222b256f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a36d525cf4d116b2fe4ecc00222b256f1">PACKED</a></td></tr>
<tr class="memdesc:a36d525cf4d116b2fe4ecc00222b256f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="unionPACKED.html" title="Public representation of a key part definition.">PACKED</a> qualifier is useful to map a structure to an external data structure, or for accessing unaligned data, but it is generally not useful to save data size because of the relatively high cost of unaligned access on some architectures.  <br /></td></tr>
<tr class="separator:a36d525cf4d116b2fe4ecc00222b256f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b1282ba1eedeb002fd3bb325d3570b" id="r_a69b1282ba1eedeb002fd3bb325d3570b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a69b1282ba1eedeb002fd3bb325d3570b">NO_SANITIZE_ADDRESS</a></td></tr>
<tr class="memdesc:a69b1282ba1eedeb002fd3bb325d3570b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NO_SANITIZE_ADDRESS attribute disables AddressSanitizer for a given function.  <br /></td></tr>
<tr class="separator:a69b1282ba1eedeb002fd3bb325d3570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf2d82c57a09723ab59e6f4dcc45b84" id="r_a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0cf2d82c57a09723ab59e6f4dcc45b84">FALLTHROUGH</a></td></tr>
<tr class="memdesc:a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Attributes }}}.  <br /></td></tr>
<tr class="separator:a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82e9747a226e287b0355deecfee5d1" id="r_aed82e9747a226e287b0355deecfee5d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aed82e9747a226e287b0355deecfee5d1">say_file_line</a>(level,  file,  line,  error,  format, ...)</td></tr>
<tr class="memdesc:aed82e9747a226e287b0355deecfee5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <br /></td></tr>
<tr class="separator:aed82e9747a226e287b0355deecfee5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2bb360001f6dfb4f946335950cabbf" id="r_a5b2bb360001f6dfb4f946335950cabbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(level,  error,  format, ...)</td></tr>
<tr class="memdesc:a5b2bb360001f6dfb4f946335950cabbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <br /></td></tr>
<tr class="separator:a5b2bb360001f6dfb4f946335950cabbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d66a81cb7c12fdb2bf2c16b9c563e" id="r_a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0a7d66a81cb7c12fdb2bf2c16b9c563e">say_error</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_ERROR, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <br /></td></tr>
<tr class="separator:a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7971b0f41c615be5a0b7100b5e42dcb3" id="r_a7971b0f41c615be5a0b7100b5e42dcb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7971b0f41c615be5a0b7100b5e42dcb3">say_crit</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_CRIT, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a7971b0f41c615be5a0b7100b5e42dcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:a7971b0f41c615be5a0b7100b5e42dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea95f80b8aa81fe56ca4291814b8a3" id="r_ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac1ea95f80b8aa81fe56ca4291814b8a3">say_warn</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_WARN, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d530f5d4ff18fd7786c3648dac2cf" id="r_ae02d530f5d4ff18fd7786c3648dac2cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_INFO, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ae02d530f5d4ff18fd7786c3648dac2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:ae02d530f5d4ff18fd7786c3648dac2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a0037b2d3389e850c9bd7d66996b42" id="r_a01a0037b2d3389e850c9bd7d66996b42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a01a0037b2d3389e850c9bd7d66996b42">say_verbose</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_VERBOSE, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a01a0037b2d3389e850c9bd7d66996b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:a01a0037b2d3389e850c9bd7d66996b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab318c2435df2b04c7180df57a3c217ae" id="r_ab318c2435df2b04c7180df57a3c217ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab318c2435df2b04c7180df57a3c217ae">say_debug</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_DEBUG, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ab318c2435df2b04c7180df57a3c217ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:ab318c2435df2b04c7180df57a3c217ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39929109aefade22a76048b9ac73bd8d" id="r_a39929109aefade22a76048b9ac73bd8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a39929109aefade22a76048b9ac73bd8d">say_syserror</a>(format, ...)</td></tr>
<tr class="memdesc:a39929109aefade22a76048b9ac73bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.    <br /></td></tr>
<tr class="separator:a39929109aefade22a76048b9ac73bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ca483733f06b223d2619bdd00d88eb" id="r_aa4ca483733f06b223d2619bdd00d88eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa4ca483733f06b223d2619bdd00d88eb">SYSTEM_SPACES</a>(_)</td></tr>
<tr class="memdesc:aa4ca483733f06b223d2619bdd00d88eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:aa4ca483733f06b223d2619bdd00d88eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d431f403e328f17179166f8aee01d34" id="r_a1d431f403e328f17179166f8aee01d34"><td class="memItemLeft" align="right" valign="top"><a id="a1d431f403e328f17179166f8aee01d34" name="a1d431f403e328f17179166f8aee01d34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSTEM_SPACE_MEMBER</b>(name,  id, ...)&#160;&#160;&#160;BOX_ ## name ## _ID = id,</td></tr>
<tr class="memdesc:a1d431f403e328f17179166f8aee01d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">System space identifier definition. <br /></td></tr>
<tr class="separator:a1d431f403e328f17179166f8aee01d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef61141a7db6fda3c9710bbc8c340e2e" id="r_aef61141a7db6fda3c9710bbc8c340e2e"><td class="memItemLeft" align="right" valign="top"><a id="aef61141a7db6fda3c9710bbc8c340e2e" name="aef61141a7db6fda3c9710bbc8c340e2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>box_error_raise</b>(code,  format, ...)&#160;&#160;&#160;	<a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b">box_error_set</a>(__FILE__, __LINE__, code, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:aef61141a7db6fda3c9710bbc8c340e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A backward-compatible API define. <br /></td></tr>
<tr class="separator:aef61141a7db6fda3c9710bbc8c340e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0415940d06f795e1f4dcfd40dd6c5b" id="r_afd0415940d06f795e1f4dcfd40dd6c5b"><td class="memItemLeft" align="right" valign="top"><a id="afd0415940d06f795e1f4dcfd40dd6c5b" name="afd0415940d06f795e1f4dcfd40dd6c5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOX_DECIMAL_STRING_BUFFER_SIZE</b>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:afd0415940d06f795e1f4dcfd40dd6c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer of this size is enough to hold any <a class="el" href="module_8h.html#a7a20acf8704e0a8de6b2c6e70cabda94" title="Write the decimal as a string into the passed buffer.">box_decimal_to_string()</a> result. <br /></td></tr>
<tr class="separator:afd0415940d06f795e1f4dcfd40dd6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24a548551bdc95d156210ec216ded4f9" id="r_a24a548551bdc95d156210ec216ded4f9"><td class="memItemLeft" align="right" valign="top"><a id="a24a548551bdc95d156210ec216ded4f9" name="a24a548551bdc95d156210ec216ded4f9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>sayfunc_t</b>) (int, const char *, int, const char *, const char *,...)</td></tr>
<tr class="memdesc:a24a548551bdc95d156210ec216ded4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a24a548551bdc95d156210ec216ded4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94849dd4556ce6560a898d5af2d20779" id="r_a94849dd4556ce6560a898d5af2d20779"><td class="memItemLeft" align="right" valign="top"><a id="a94849dd4556ce6560a898d5af2d20779" name="a94849dd4556ce6560a898d5af2d20779"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>fiber_func</b>) (va_list)</td></tr>
<tr class="memdesc:a94849dd4556ce6560a898d5af2d20779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber - contains information about fiber. <br /></td></tr>
<tr class="separator:a94849dd4556ce6560a898d5af2d20779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba432143f6c7876ea8704638e9c9e5d" id="r_abba432143f6c7876ea8704638e9c9e5d"><td class="memItemLeft" align="right" valign="top"><a id="abba432143f6c7876ea8704638e9c9e5d" name="abba432143f6c7876ea8704638e9c9e5d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tnt_tx_func_f</b>) (void *)</td></tr>
<tr class="memdesc:abba432143f6c7876ea8704638e9c9e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:abba432143f6c7876ea8704638e9c9e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cb16b1acef0772ea4192316f742aa8" id="r_ae1cb16b1acef0772ea4192316f742aa8"><td class="memItemLeft" align="right" valign="top"><a id="ae1cb16b1acef0772ea4192316f742aa8" name="ae1cb16b1acef0772ea4192316f742aa8"></a>
typedef struct ibuf&#160;</td><td class="memItemRight" valign="bottom"><b>box_ibuf_t</b></td></tr>
<tr class="memdesc:ae1cb16b1acef0772ea4192316f742aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:ae1cb16b1acef0772ea4192316f742aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab230ff08fb24d580407126fc905cc271" id="r_ab230ff08fb24d580407126fc905cc271"><td class="memItemLeft" align="right" valign="top"><a id="ab230ff08fb24d580407126fc905cc271" name="ab230ff08fb24d580407126fc905cc271"></a>
typedef struct tuple_format&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_format_t</b></td></tr>
<tr class="memdesc:ab230ff08fb24d580407126fc905cc271"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:ab230ff08fb24d580407126fc905cc271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880c3e1e8e63b9a12353853fb6aefa3f" id="r_a880c3e1e8e63b9a12353853fb6aefa3f"><td class="memItemLeft" align="right" valign="top"><a id="a880c3e1e8e63b9a12353853fb6aefa3f" name="a880c3e1e8e63b9a12353853fb6aefa3f"></a>
typedef struct tuple&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_t</b></td></tr>
<tr class="memdesc:a880c3e1e8e63b9a12353853fb6aefa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple. <br /></td></tr>
<tr class="separator:a880c3e1e8e63b9a12353853fb6aefa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289ab037764b9f065d4b683cb186bda" id="r_aa289ab037764b9f065d4b683cb186bda"><td class="memItemLeft" align="right" valign="top"><a id="aa289ab037764b9f065d4b683cb186bda" name="aa289ab037764b9f065d4b683cb186bda"></a>
typedef struct tuple_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_iterator_t</b></td></tr>
<tr class="memdesc:aa289ab037764b9f065d4b683cb186bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple iterator. <br /></td></tr>
<tr class="separator:aa289ab037764b9f065d4b683cb186bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe4043908ad1b4a106689ad2da8814" id="r_acfbe4043908ad1b4a106689ad2da8814"><td class="memItemLeft" align="right" valign="top"><a id="acfbe4043908ad1b4a106689ad2da8814" name="acfbe4043908ad1b4a106689ad2da8814"></a>
typedef struct key_def&#160;</td><td class="memItemRight" valign="bottom"><b>box_key_def_t</b></td></tr>
<tr class="memdesc:acfbe4043908ad1b4a106689ad2da8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:acfbe4043908ad1b4a106689ad2da8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302d3f85cf14f03ace911e9541c95c4d" id="r_a302d3f85cf14f03ace911e9541c95c4d"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionPACKED.html">PACKED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a></td></tr>
<tr class="memdesc:a302d3f85cf14f03ace911e9541c95c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public representation of a key part definition.  <br /></td></tr>
<tr class="separator:a302d3f85cf14f03ace911e9541c95c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37ca06842be0fe827d5272493e2311f" id="r_aa37ca06842be0fe827d5272493e2311f"><td class="memItemLeft" align="right" valign="top"><a id="aa37ca06842be0fe827d5272493e2311f" name="aa37ca06842be0fe827d5272493e2311f"></a>
typedef struct box_function_ctx&#160;</td><td class="memItemRight" valign="bottom"><b>box_function_ctx_t</b></td></tr>
<tr class="memdesc:aa37ca06842be0fe827d5272493e2311f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:aa37ca06842be0fe827d5272493e2311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dc8ff47cfc25ee92d0f74cdf459070" id="r_a19dc8ff47cfc25ee92d0f74cdf459070"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a>) (const char *header, const char *header_end, const char *body, const char *body_end, void *ctx)</td></tr>
<tr class="memdesc:a19dc8ff47cfc25ee92d0f74cdf459070"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPROTO request handler signature: receives MsgPack encoded header and body, a context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a>, and must return one of the status codes from iproto_handler_status.  <br /></td></tr>
<tr class="separator:a19dc8ff47cfc25ee92d0f74cdf459070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb59c79a9b32bb8a23204e89bced9d" id="r_aa9eb59c79a9b32bb8a23204e89bced9d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a>) (void *ctx)</td></tr>
<tr class="memdesc:aa9eb59c79a9b32bb8a23204e89bced9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPROTO request handler destructor called when the corresponding handler is removed.  <br /></td></tr>
<tr class="separator:aa9eb59c79a9b32bb8a23204e89bced9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b04d0397e455b7ed42b530c1c1ea9e6" id="r_a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="memItemLeft" align="right" valign="top"><a id="a2b04d0397e455b7ed42b530c1c1ea9e6" name="a2b04d0397e455b7ed42b530c1c1ea9e6"></a>
typedef struct iterator&#160;</td><td class="memItemRight" valign="bottom"><b>box_iterator_t</b></td></tr>
<tr class="memdesc:a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49d5e355555804f6b46b79513715be8" id="r_ad49d5e355555804f6b46b79513715be8"><td class="memItemLeft" align="right" valign="top"><a id="ad49d5e355555804f6b46b79513715be8" name="ad49d5e355555804f6b46b79513715be8"></a>
typedef struct error&#160;</td><td class="memItemRight" valign="bottom"><b>box_error_t</b></td></tr>
<tr class="memdesc:ad49d5e355555804f6b46b79513715be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error - contains information about error. <br /></td></tr>
<tr class="separator:ad49d5e355555804f6b46b79513715be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d13f137e4bdb8c852ea04637da58d" id="r_a923d13f137e4bdb8c852ea04637da58d"><td class="memItemLeft" align="right" valign="top">typedef struct box_latch&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a></td></tr>
<tr class="memdesc:a923d13f137e4bdb8c852ea04637da58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a923d13f137e4bdb8c852ea04637da58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d26cf0c54dfa5e878e95ca0f73202a" id="r_a90d26cf0c54dfa5e878e95ca0f73202a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structbox__decimal.html">box_decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a></td></tr>
<tr class="memdesc:a90d26cf0c54dfa5e878e95ca0f73202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a decimal number.  <br /></td></tr>
<tr class="separator:a90d26cf0c54dfa5e878e95ca0f73202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af667a90dfe6a8cc25b510af73d98bb82" id="r_af667a90dfe6a8cc25b510af73d98bb82"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a> { <br />
&#160;&#160;<b>S_FATAL</b>
, <br />
&#160;&#160;<b>S_SYSERROR</b>
, <br />
&#160;&#160;<b>S_ERROR</b>
, <br />
&#160;&#160;<b>S_CRIT</b>
, <br />
&#160;&#160;<b>S_WARN</b>
, <br />
&#160;&#160;<b>S_INFO</b>
, <br />
&#160;&#160;<b>S_VERBOSE</b>
, <br />
&#160;&#160;<b>S_DEBUG</b>
, <br />
&#160;&#160;<b>say_level_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:af667a90dfe6a8cc25b510af73d98bb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">More...</a><br /></td></tr>
<tr class="separator:af667a90dfe6a8cc25b510af73d98bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0789f1bee95be5f9005c6ff4e0b2ad" id="r_ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="memItemLeft" align="right" valign="top"><a id="ade0789f1bee95be5f9005c6ff4e0b2ad" name="ade0789f1bee95be5f9005c6ff4e0b2ad"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ade0789f1bee95be5f9005c6ff4e0b2ad">say_format</a> { <br />
&#160;&#160;<b>SF_PLAIN</b>
, <br />
&#160;&#160;<b>SF_JSON</b>
, <br />
&#160;&#160;<b>say_format_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log formats. <br /></td></tr>
<tr class="separator:ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b" id="r_a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4e556d3f75a54e162feaa8e9451cfce7">COIO_READ</a> = 0x1
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba9ccd504861956d107f717efa66b3f1b7">COIO_WRITE</a> = 0x2
<br />
 }</td></tr>
<tr class="memdesc:a06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55b">More...</a><br /></td></tr>
<tr class="separator:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d527c62a52f85cb173c79c31d20ce1" id="r_af2d527c62a52f85cb173c79c31d20ce1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">txn_isolation_level</a> { <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a4f9fb36818af61558b13124ca0e02363">TXN_ISOLATION_DEFAULT</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a351aceaaa55693a90f5e33103d051947">TXN_ISOLATION_READ_COMMITTED</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1ab2411f8d6a9d68367da464d9fcff932f">TXN_ISOLATION_READ_CONFIRMED</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1afa0bc338b3e678625a61d16254991c7b">TXN_ISOLATION_BEST_EFFORT</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a6236950c80e86644457d27e158639b60">TXN_ISOLATION_LINEARIZABLE</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a8e225c05de0c630a787eb113f64e3af4">txn_isolation_level_MAX</a>
<br />
 }</td></tr>
<tr class="memdesc:af2d527c62a52f85cb173c79c31d20ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">More...</a><br /></td></tr>
<tr class="separator:af2d527c62a52f85cb173c79c31d20ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf764cbdea00d65edcd07bb9953ad2b7" id="r_adf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top"><a id="adf764cbdea00d65edcd07bb9953ad2b7" name="adf764cbdea00d65edcd07bb9953ad2b7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BOX_KEY_PART_DEF_IS_NULLABLE</b> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<b>BOX_KEY_PART_DEF_EXCLUDE_NULL</b> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<b>BOX_KEY_PART_DEF_SORT_ORDER_DESC</b> = 1 &lt;&lt; 2
<br />
 }</td></tr>
<tr class="memdesc:adf764cbdea00d65edcd07bb9953ad2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key part definition flags. <br /></td></tr>
<tr class="separator:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb83031ce9923c84392b4e92f956b5" id="r_a99fb83031ce9923c84392b4e92f956b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="module_8h.html#a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433">BOX_KEY_PART_DEF_T_SIZE</a> = 64
 }</td></tr>
<tr class="memdesc:a99fb83031ce9923c84392b4e92f956b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is recommended to verify size of box_key_part_def_t against this constant on the module side at build time.  <a href="module_8h.html#a99fb83031ce9923c84392b4e92f956b5">More...</a><br /></td></tr>
<tr class="separator:a99fb83031ce9923c84392b4e92f956b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e6ca114114786cc23f3d5a1f8d14bf" id="r_af4e6ca114114786cc23f3d5a1f8d14bf"><td class="memItemLeft" align="right" valign="top"><a id="af4e6ca114114786cc23f3d5a1f8d14bf" name="af4e6ca114114786cc23f3d5a1f8d14bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af4e6ca114114786cc23f3d5a1f8d14bf">field_type</a> { <br />
&#160;&#160;<b>FIELD_TYPE_ANY</b> = 0
, <br />
&#160;&#160;<b>FIELD_TYPE_UNSIGNED</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_STRING</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_NUMBER</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DOUBLE</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INTEGER</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_BOOLEAN</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_VARBINARY</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_SCALAR</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UUID</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DATETIME</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INTERVAL</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_ARRAY</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_MAP</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INT8</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UINT8</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INT16</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UINT16</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INT32</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UINT32</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INT64</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UINT64</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_FLOAT32</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_FLOAT64</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL32</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL64</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL128</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL256</b>
, <br />
&#160;&#160;<b>field_type_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:af4e6ca114114786cc23f3d5a1f8d14bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:af4e6ca114114786cc23f3d5a1f8d14bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b7e2d98df6589252f8ede07932619" id="r_ac42b7e2d98df6589252f8ede07932619"><td class="memItemLeft" align="right" valign="top"><a id="ac42b7e2d98df6589252f8ede07932619" name="ac42b7e2d98df6589252f8ede07932619"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac42b7e2d98df6589252f8ede07932619">on_conflict_action</a> { <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_NONE</b> = 0
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_ROLLBACK</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_ABORT</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_FAIL</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_IGNORE</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_REPLACE</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_DEFAULT</b>
, <br />
&#160;&#160;<b>on_conflict_action_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:ac42b7e2d98df6589252f8ede07932619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible actions on conflict. <br /></td></tr>
<tr class="separator:ac42b7e2d98df6589252f8ede07932619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6126af1d45847bc59afa0aa3216b04" id="r_abc6126af1d45847bc59afa0aa3216b04"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a05cae1bfc9671a38779ffd9dde4d7f58">BOX_SYSTEM_ID_MIN</a> = 256
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04abb87df1b61192ee3aea178534071b9cd">BOX_SYSTEM_ID_MAX</a> = 511
, <br />
&#160;&#160;<b>BOX_ID_NIL</b> = 2147483647
<br />
 }</td></tr>
<tr class="separator:abc6126af1d45847bc59afa0aa3216b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dab01cb6470a8177e9618558523ff7b" id="r_a4dab01cb6470a8177e9618558523ff7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a> { <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7ba964fc0581c3169c5047abaebcbc6a190">IPROTO_HANDLER_OK</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7ba3838e3dc0206744064024e6948f5f214">IPROTO_HANDLER_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7badb3e2b86bb68c8ef55af839fc59a63a5">IPROTO_HANDLER_FALLBACK</a>
<br />
 }</td></tr>
<tr class="memdesc:a4dab01cb6470a8177e9618558523ff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes for IPROTO request handlers.  <a href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">More...</a><br /></td></tr>
<tr class="separator:a4dab01cb6470a8177e9618558523ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95be11a839742b838f48a05e15dc96f" id="r_ad95be11a839742b838f48a05e15dc96f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96f">box_slab_info_type</a> { <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96fa5035a467639de7b7878658bb6d5d6759">BOX_SLAB_INFO_ITEMS_SIZE</a> = 0
, <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96fac05e5e1257324755fbb5b69a42a3162f">BOX_SLAB_INFO_ITEMS_USED</a> = 1
, <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96fa011955c844200186269b1728c60072a9">BOX_SLAB_INFO_ARENA_SIZE</a> = 2
, <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96faaf908670201e994b6fbb7a39bd0af778">BOX_SLAB_INFO_ARENA_USED</a> = 3
, <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96fa1d115d2d78ba3a718b37952afc930716">BOX_SLAB_INFO_QUOTA_SIZE</a> = 4
, <br />
&#160;&#160;<a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96fa9727bdf5f628906b49ab0c65682d6a70">BOX_SLAB_INFO_QUOTA_USED</a> = 5
<br />
 }</td></tr>
<tr class="separator:ad95be11a839742b838f48a05e15dc96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2693ce4bd8fa71e8ac1e5272fc64d17e" id="r_a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a> { <br />
&#160;&#160;<b>ITER_EQ</b> = 0
, <br />
&#160;&#160;<b>ITER_REQ</b> = 1
, <br />
&#160;&#160;<b>ITER_ALL</b> = 2
, <br />
&#160;&#160;<b>ITER_LT</b> = 3
, <br />
&#160;&#160;<b>ITER_LE</b> = 4
, <br />
&#160;&#160;<b>ITER_GE</b> = 5
, <br />
&#160;&#160;<b>ITER_GT</b> = 6
, <br />
&#160;&#160;<b>ITER_BITS_ALL_SET</b> = 7
, <br />
&#160;&#160;<b>ITER_BITS_ANY_SET</b> = 8
, <br />
&#160;&#160;<b>ITER_BITS_ALL_NOT_SET</b> = 9
, <br />
&#160;&#160;<b>ITER_OVERLAPS</b> = 10
, <br />
&#160;&#160;<b>ITER_NEIGHBOR</b> = 11
, <br />
&#160;&#160;<b>ITER_NP</b> = 12
, <br />
&#160;&#160;<b>ITER_PP</b> = 13
, <br />
&#160;&#160;<b>iterator_type_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">More...</a><br /></td></tr>
<tr class="separator:a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029e9d16d637a97b37560ccf24c4adce" id="r_a029e9d16d637a97b37560ccf24c4adce"><td class="memItemLeft" align="right" valign="top"><a id="a029e9d16d637a97b37560ccf24c4adce" name="a029e9d16d637a97b37560ccf24c4adce"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce">box_error_code</a> { <br />
&#160;&#160;<b>ER_UNKNOWN</b> = 0
, <br />
&#160;&#160;<b>ER_ILLEGAL_PARAMS</b> = 1
, <br />
&#160;&#160;<b>ER_MEMORY_ISSUE</b> = 2
, <br />
&#160;&#160;<b>ER_TUPLE_FOUND</b> = 3
, <br />
&#160;&#160;<b>ER_UNSUPPORTED</b> = 5
, <br />
&#160;&#160;<b>ER_READONLY</b> = 7
, <br />
&#160;&#160;<b>ER_INJECTION</b> = 8
, <br />
&#160;&#160;<b>ER_CREATE_SPACE</b> = 9
, <br />
&#160;&#160;<b>ER_SPACE_EXISTS</b> = 10
, <br />
&#160;&#160;<b>ER_DROP_SPACE</b> = 11
, <br />
&#160;&#160;<b>ER_ALTER_SPACE</b> = 12
, <br />
&#160;&#160;<b>ER_INDEX_TYPE</b> = 13
, <br />
&#160;&#160;<b>ER_MODIFY_INDEX</b> = 14
, <br />
&#160;&#160;<b>ER_LAST_DROP</b> = 15
, <br />
&#160;&#160;<b>ER_TUPLE_FORMAT_LIMIT</b> = 16
, <br />
&#160;&#160;<b>ER_DROP_PRIMARY_KEY</b> = 17
, <br />
&#160;&#160;<b>ER_KEY_PART_TYPE</b> = 18
, <br />
&#160;&#160;<b>ER_EXACT_MATCH</b> = 19
, <br />
&#160;&#160;<b>ER_INVALID_MSGPACK</b> = 20
, <br />
&#160;&#160;<b>ER_TUPLE_NOT_ARRAY</b> = 22
, <br />
&#160;&#160;<b>ER_FIELD_TYPE</b> = 23
, <br />
&#160;&#160;<b>ER_INDEX_PART_TYPE_MISMATCH</b> = 24
, <br />
&#160;&#160;<b>ER_UPDATE_SPLICE</b> = 25
, <br />
&#160;&#160;<b>ER_UPDATE_ARG_TYPE</b> = 26
, <br />
&#160;&#160;<b>ER_FORMAT_MISMATCH_INDEX_PART</b> = 27
, <br />
&#160;&#160;<b>ER_UNKNOWN_UPDATE_OP</b> = 28
, <br />
&#160;&#160;<b>ER_UPDATE_FIELD</b> = 29
, <br />
&#160;&#160;<b>ER_FUNCTION_TX_ACTIVE</b> = 30
, <br />
&#160;&#160;<b>ER_KEY_PART_COUNT</b> = 31
, <br />
&#160;&#160;<b>ER_PROC_LUA</b> = 32
, <br />
&#160;&#160;<b>ER_NO_SUCH_PROC</b> = 33
, <br />
&#160;&#160;<b>ER_NO_SUCH_TRIGGER</b> = 34
, <br />
&#160;&#160;<b>ER_NO_SUCH_INDEX_ID</b> = 35
, <br />
&#160;&#160;<b>ER_NO_SUCH_SPACE</b> = 36
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NO</b> = 37
, <br />
&#160;&#160;<b>ER_EXACT_FIELD_COUNT</b> = 38
, <br />
&#160;&#160;<b>ER_FIELD_MISSING</b> = 39
, <br />
&#160;&#160;<b>ER_WAL_IO</b> = 40
, <br />
&#160;&#160;<b>ER_MORE_THAN_ONE_TUPLE</b> = 41
, <br />
&#160;&#160;<b>ER_ACCESS_DENIED</b> = 42
, <br />
&#160;&#160;<b>ER_CREATE_USER</b> = 43
, <br />
&#160;&#160;<b>ER_DROP_USER</b> = 44
, <br />
&#160;&#160;<b>ER_NO_SUCH_USER</b> = 45
, <br />
&#160;&#160;<b>ER_USER_EXISTS</b> = 46
, <br />
&#160;&#160;<b>ER_CREDS_MISMATCH</b> = 47
, <br />
&#160;&#160;<b>ER_UNKNOWN_REQUEST_TYPE</b> = 48
, <br />
&#160;&#160;<b>ER_UNKNOWN_SCHEMA_OBJECT</b> = 49
, <br />
&#160;&#160;<b>ER_CREATE_FUNCTION</b> = 50
, <br />
&#160;&#160;<b>ER_NO_SUCH_FUNCTION</b> = 51
, <br />
&#160;&#160;<b>ER_FUNCTION_EXISTS</b> = 52
, <br />
&#160;&#160;<b>ER_BEFORE_REPLACE_RET</b> = 53
, <br />
&#160;&#160;<b>ER_MULTISTATEMENT_TRANSACTION</b> = 54
, <br />
&#160;&#160;<b>ER_TRIGGER_EXISTS</b> = 55
, <br />
&#160;&#160;<b>ER_USER_MAX</b> = 56
, <br />
&#160;&#160;<b>ER_NO_SUCH_ENGINE</b> = 57
, <br />
&#160;&#160;<b>ER_RELOAD_CFG</b> = 58
, <br />
&#160;&#160;<b>ER_CFG</b> = 59
, <br />
&#160;&#160;<b>ER_SAVEPOINT_EMPTY_TX</b> = 60
, <br />
&#160;&#160;<b>ER_NO_SUCH_SAVEPOINT</b> = 61
, <br />
&#160;&#160;<b>ER_UNKNOWN_REPLICA</b> = 62
, <br />
&#160;&#160;<b>ER_REPLICASET_UUID_MISMATCH</b> = 63
, <br />
&#160;&#160;<b>ER_INVALID_UUID</b> = 64
, <br />
&#160;&#160;<b>ER_REPLICASET_UUID_IS_RO</b> = 65
, <br />
&#160;&#160;<b>ER_INSTANCE_UUID_MISMATCH</b> = 66
, <br />
&#160;&#160;<b>ER_REPLICA_ID_IS_RESERVED</b> = 67
, <br />
&#160;&#160;<b>ER_MISSING_REQUEST_FIELD</b> = 69
, <br />
&#160;&#160;<b>ER_IDENTIFIER</b> = 70
, <br />
&#160;&#160;<b>ER_DROP_FUNCTION</b> = 71
, <br />
&#160;&#160;<b>ER_ITERATOR_TYPE</b> = 72
, <br />
&#160;&#160;<b>ER_REPLICA_MAX</b> = 73
, <br />
&#160;&#160;<b>ER_NO_CONNECTION</b> = 77
, <br />
&#160;&#160;<b>ER_TIMEOUT</b> = 78
, <br />
&#160;&#160;<b>ER_ACTIVE_TRANSACTION</b> = 79
, <br />
&#160;&#160;<b>ER_CURSOR_NO_TRANSACTION</b> = 80
, <br />
&#160;&#160;<b>ER_NO_SUCH_ROLE</b> = 82
, <br />
&#160;&#160;<b>ER_ROLE_EXISTS</b> = 83
, <br />
&#160;&#160;<b>ER_CREATE_ROLE</b> = 84
, <br />
&#160;&#160;<b>ER_INDEX_EXISTS</b> = 85
, <br />
&#160;&#160;<b>ER_SESSION_CLOSED</b> = 86
, <br />
&#160;&#160;<b>ER_ROLE_LOOP</b> = 87
, <br />
&#160;&#160;<b>ER_GRANT</b> = 88
, <br />
&#160;&#160;<b>ER_PRIV_GRANTED</b> = 89
, <br />
&#160;&#160;<b>ER_ROLE_GRANTED</b> = 90
, <br />
&#160;&#160;<b>ER_PRIV_NOT_GRANTED</b> = 91
, <br />
&#160;&#160;<b>ER_ROLE_NOT_GRANTED</b> = 92
, <br />
&#160;&#160;<b>ER_MISSING_SNAPSHOT</b> = 93
, <br />
&#160;&#160;<b>ER_CANT_UPDATE_PRIMARY_KEY</b> = 94
, <br />
&#160;&#160;<b>ER_UPDATE_INTEGER_OVERFLOW</b> = 95
, <br />
&#160;&#160;<b>ER_GUEST_USER_PASSWORD</b> = 96
, <br />
&#160;&#160;<b>ER_TRANSACTION_CONFLICT</b> = 97
, <br />
&#160;&#160;<b>ER_UNSUPPORTED_PRIV</b> = 98
, <br />
&#160;&#160;<b>ER_LOAD_FUNCTION</b> = 99
, <br />
&#160;&#160;<b>ER_FUNCTION_LANGUAGE</b> = 100
, <br />
&#160;&#160;<b>ER_RTREE_RECT</b> = 101
, <br />
&#160;&#160;<b>ER_PROC_C</b> = 102
, <br />
&#160;&#160;<b>ER_PROTOCOL</b> = 104
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_RECORD</b> = 106
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_PARTS</b> = 107
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_OPTIONS</b> = 108
, <br />
&#160;&#160;<b>ER_WRONG_SCHEMA_VERSION</b> = 109
, <br />
&#160;&#160;<b>ER_MEMTX_MAX_TUPLE_SIZE</b> = 110
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_OPTIONS</b> = 111
, <br />
&#160;&#160;<b>ER_UNSUPPORTED_INDEX_FEATURE</b> = 112
, <br />
&#160;&#160;<b>ER_VIEW_IS_RO</b> = 113
, <br />
&#160;&#160;<b>ER_NO_TRANSACTION</b> = 114
, <br />
&#160;&#160;<b>ER_SYSTEM</b> = 115
, <br />
&#160;&#160;<b>ER_LOADING</b> = 116
, <br />
&#160;&#160;<b>ER_CONNECTION_TO_SELF</b> = 117
, <br />
&#160;&#160;<b>ER_COMPRESSION</b> = 119
, <br />
&#160;&#160;<b>ER_CHECKPOINT_IN_PROGRESS</b> = 120
, <br />
&#160;&#160;<b>ER_SUB_STMT_MAX</b> = 121
, <br />
&#160;&#160;<b>ER_COMMIT_IN_SUB_STMT</b> = 122
, <br />
&#160;&#160;<b>ER_ROLLBACK_IN_SUB_STMT</b> = 123
, <br />
&#160;&#160;<b>ER_DECOMPRESSION</b> = 124
, <br />
&#160;&#160;<b>ER_INVALID_XLOG_TYPE</b> = 125
, <br />
&#160;&#160;<b>ER_ALREADY_RUNNING</b> = 126
, <br />
&#160;&#160;<b>ER_INDEX_FIELD_COUNT_LIMIT</b> = 127
, <br />
&#160;&#160;<b>ER_LOCAL_INSTANCE_ID_IS_READ_ONLY</b> = 128
, <br />
&#160;&#160;<b>ER_BACKUP_IN_PROGRESS</b> = 129
, <br />
&#160;&#160;<b>ER_READ_VIEW_ABORTED</b> = 130
, <br />
&#160;&#160;<b>ER_INVALID_INDEX_FILE</b> = 131
, <br />
&#160;&#160;<b>ER_INVALID_RUN_FILE</b> = 132
, <br />
&#160;&#160;<b>ER_INVALID_VYLOG_FILE</b> = 133
, <br />
&#160;&#160;<b>ER_CASCADE_ROLLBACK</b> = 134
, <br />
&#160;&#160;<b>ER_VY_QUOTA_TIMEOUT</b> = 135
, <br />
&#160;&#160;<b>ER_PARTIAL_KEY</b> = 136
, <br />
&#160;&#160;<b>ER_TRUNCATE_SYSTEM_SPACE</b> = 137
, <br />
&#160;&#160;<b>ER_LOAD_MODULE</b> = 138
, <br />
&#160;&#160;<b>ER_VINYL_MAX_TUPLE_SIZE</b> = 139
, <br />
&#160;&#160;<b>ER_WRONG_DD_VERSION</b> = 140
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_FORMAT</b> = 141
, <br />
&#160;&#160;<b>ER_CREATE_SEQUENCE</b> = 142
, <br />
&#160;&#160;<b>ER_ALTER_SEQUENCE</b> = 143
, <br />
&#160;&#160;<b>ER_DROP_SEQUENCE</b> = 144
, <br />
&#160;&#160;<b>ER_NO_SUCH_SEQUENCE</b> = 145
, <br />
&#160;&#160;<b>ER_SEQUENCE_EXISTS</b> = 146
, <br />
&#160;&#160;<b>ER_SEQUENCE_OVERFLOW</b> = 147
, <br />
&#160;&#160;<b>ER_NO_SUCH_INDEX_NAME</b> = 148
, <br />
&#160;&#160;<b>ER_SPACE_FIELD_IS_DUPLICATE</b> = 149
, <br />
&#160;&#160;<b>ER_CANT_CREATE_COLLATION</b> = 150
, <br />
&#160;&#160;<b>ER_WRONG_COLLATION_OPTIONS</b> = 151
, <br />
&#160;&#160;<b>ER_NULLABLE_PRIMARY</b> = 152
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NAME_IN_SPACE</b> = 153
, <br />
&#160;&#160;<b>ER_TRANSACTION_YIELD</b> = 154
, <br />
&#160;&#160;<b>ER_NO_SUCH_GROUP</b> = 155
, <br />
&#160;&#160;<b>ER_SQL_BIND_TYPE</b> = 157
, <br />
&#160;&#160;<b>ER_SQL_BIND_PARAMETER_MAX</b> = 158
, <br />
&#160;&#160;<b>ER_SQL_EXECUTE</b> = 159
, <br />
&#160;&#160;<b>ER_UPDATE_DECIMAL_OVERFLOW</b> = 160
, <br />
&#160;&#160;<b>ER_SQL_BIND_NOT_FOUND</b> = 161
, <br />
&#160;&#160;<b>ER_ACTION_MISMATCH</b> = 162
, <br />
&#160;&#160;<b>ER_VIEW_MISSING_SQL</b> = 163
, <br />
&#160;&#160;<b>ER_FOREIGN_KEY_CONSTRAINT</b> = 164
, <br />
&#160;&#160;<b>ER_NO_SUCH_MODULE</b> = 165
, <br />
&#160;&#160;<b>ER_NO_SUCH_COLLATION</b> = 166
, <br />
&#160;&#160;<b>ER_CREATE_FK_CONSTRAINT</b> = 167
, <br />
&#160;&#160;<b>ER_NO_SUCH_CONSTRAINT</b> = 169
, <br />
&#160;&#160;<b>ER_CONSTRAINT_EXISTS</b> = 170
, <br />
&#160;&#160;<b>ER_SQL_TYPE_MISMATCH</b> = 171
, <br />
&#160;&#160;<b>ER_ROWID_OVERFLOW</b> = 172
, <br />
&#160;&#160;<b>ER_DROP_COLLATION</b> = 173
, <br />
&#160;&#160;<b>ER_ILLEGAL_COLLATION_MIX</b> = 174
, <br />
&#160;&#160;<b>ER_SQL_NO_SUCH_PRAGMA</b> = 175
, <br />
&#160;&#160;<b>ER_SQL_CANT_RESOLVE_FIELD</b> = 176
, <br />
&#160;&#160;<b>ER_INDEX_EXISTS_IN_SPACE</b> = 177
, <br />
&#160;&#160;<b>ER_INCONSISTENT_TYPES</b> = 178
, <br />
&#160;&#160;<b>ER_SQL_SYNTAX_WITH_POS</b> = 179
, <br />
&#160;&#160;<b>ER_SQL_STACK_OVERFLOW</b> = 180
, <br />
&#160;&#160;<b>ER_SQL_SELECT_WILDCARD</b> = 181
, <br />
&#160;&#160;<b>ER_SQL_STATEMENT_EMPTY</b> = 182
, <br />
&#160;&#160;<b>ER_SQL_KEYWORD_IS_RESERVED</b> = 183
, <br />
&#160;&#160;<b>ER_SQL_SYNTAX_NEAR_TOKEN</b> = 184
, <br />
&#160;&#160;<b>ER_SQL_UNKNOWN_TOKEN</b> = 185
, <br />
&#160;&#160;<b>ER_SQL_PARSER_GENERIC</b> = 186
, <br />
&#160;&#160;<b>ER_SQL_COLUMN_COUNT_MAX</b> = 188
, <br />
&#160;&#160;<b>ER_HEX_LITERAL_MAX</b> = 189
, <br />
&#160;&#160;<b>ER_INT_LITERAL_MAX</b> = 190
, <br />
&#160;&#160;<b>ER_SQL_PARSER_LIMIT</b> = 191
, <br />
&#160;&#160;<b>ER_INDEX_DEF_UNSUPPORTED</b> = 192
, <br />
&#160;&#160;<b>ER_MULTIKEY_INDEX_MISMATCH</b> = 194
, <br />
&#160;&#160;<b>ER_CREATE_CK_CONSTRAINT</b> = 195
, <br />
&#160;&#160;<b>ER_SQL_COLUMN_COUNT</b> = 197
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_FUNC</b> = 198
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_FORMAT</b> = 199
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_PARTS</b> = 200
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NAME</b> = 201
, <br />
&#160;&#160;<b>ER_FUNC_WRONG_ARG_COUNT</b> = 202
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_READONLY</b> = 203
, <br />
&#160;&#160;<b>ER_SQL_FUNC_WRONG_RET_COUNT</b> = 204
, <br />
&#160;&#160;<b>ER_FUNC_INVALID_RETURN_TYPE</b> = 205
, <br />
&#160;&#160;<b>ER_SQL_PARSER_GENERIC_WITH_POS</b> = 206
, <br />
&#160;&#160;<b>ER_REPLICA_NOT_ANON</b> = 207
, <br />
&#160;&#160;<b>ER_CANNOT_REGISTER</b> = 208
, <br />
&#160;&#160;<b>ER_SESSION_SETTING_INVALID_VALUE</b> = 209
, <br />
&#160;&#160;<b>ER_SQL_PREPARE</b> = 210
, <br />
&#160;&#160;<b>ER_WRONG_QUERY_ID</b> = 211
, <br />
&#160;&#160;<b>ER_SEQUENCE_NOT_STARTED</b> = 212
, <br />
&#160;&#160;<b>ER_NO_SUCH_SESSION_SETTING</b> = 213
, <br />
&#160;&#160;<b>ER_UNCOMMITTED_FOREIGN_SYNC_TXNS</b> = 214
, <br />
&#160;&#160;<b>ER_SYNC_QUORUM_TIMEOUT</b> = 216
, <br />
&#160;&#160;<b>ER_SYNC_ROLLBACK</b> = 217
, <br />
&#160;&#160;<b>ER_TUPLE_METADATA_IS_TOO_BIG</b> = 218
, <br />
&#160;&#160;<b>ER_XLOG_GAP</b> = 219
, <br />
&#160;&#160;<b>ER_TOO_EARLY_SUBSCRIBE</b> = 220
, <br />
&#160;&#160;<b>ER_SQL_CANT_ADD_AUTOINC</b> = 221
, <br />
&#160;&#160;<b>ER_QUORUM_WAIT</b> = 222
, <br />
&#160;&#160;<b>ER_INTERFERING_PROMOTE</b> = 223
, <br />
&#160;&#160;<b>ER_ELECTION_DISABLED</b> = 224
, <br />
&#160;&#160;<b>ER_TXN_ROLLBACK</b> = 225
, <br />
&#160;&#160;<b>ER_NOT_LEADER</b> = 226
, <br />
&#160;&#160;<b>ER_SYNC_QUEUE_UNCLAIMED</b> = 227
, <br />
&#160;&#160;<b>ER_SYNC_QUEUE_FOREIGN</b> = 228
, <br />
&#160;&#160;<b>ER_UNABLE_TO_PROCESS_IN_STREAM</b> = 229
, <br />
&#160;&#160;<b>ER_UNABLE_TO_PROCESS_OUT_OF_STREAM</b> = 230
, <br />
&#160;&#160;<b>ER_TRANSACTION_TIMEOUT</b> = 231
, <br />
&#160;&#160;<b>ER_ACTIVE_TIMER</b> = 232
, <br />
&#160;&#160;<b>ER_TUPLE_FIELD_COUNT_LIMIT</b> = 233
, <br />
&#160;&#160;<b>ER_CREATE_CONSTRAINT</b> = 234
, <br />
&#160;&#160;<b>ER_FIELD_CONSTRAINT_FAILED</b> = 235
, <br />
&#160;&#160;<b>ER_TUPLE_CONSTRAINT_FAILED</b> = 236
, <br />
&#160;&#160;<b>ER_CREATE_FOREIGN_KEY</b> = 237
, <br />
&#160;&#160;<b>ER_FOREIGN_KEY_INTEGRITY</b> = 238
, <br />
&#160;&#160;<b>ER_FIELD_FOREIGN_KEY_FAILED</b> = 239
, <br />
&#160;&#160;<b>ER_COMPLEX_FOREIGN_KEY_FAILED</b> = 240
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_UPGRADE_OPTIONS</b> = 241
, <br />
&#160;&#160;<b>ER_NO_ELECTION_QUORUM</b> = 242
, <br />
&#160;&#160;<b>ER_SSL</b> = 243
, <br />
&#160;&#160;<b>ER_SPLIT_BRAIN</b> = 244
, <br />
&#160;&#160;<b>ER_OLD_TERM</b> = 245
, <br />
&#160;&#160;<b>ER_INTERFERING_ELECTIONS</b> = 246
, <br />
&#160;&#160;<b>ER_ITERATOR_POSITION</b> = 247
, <br />
&#160;&#160;<b>ER_DEFAULT_VALUE_TYPE</b> = 248
, <br />
&#160;&#160;<b>ER_UNKNOWN_AUTH_METHOD</b> = 249
, <br />
&#160;&#160;<b>ER_INVALID_AUTH_DATA</b> = 250
, <br />
&#160;&#160;<b>ER_INVALID_AUTH_REQUEST</b> = 251
, <br />
&#160;&#160;<b>ER_WEAK_PASSWORD</b> = 252
, <br />
&#160;&#160;<b>ER_OLD_PASSWORD</b> = 253
, <br />
&#160;&#160;<b>ER_NO_SUCH_SESSION</b> = 254
, <br />
&#160;&#160;<b>ER_WRONG_SESSION_TYPE</b> = 255
, <br />
&#160;&#160;<b>ER_PASSWORD_EXPIRED</b> = 256
, <br />
&#160;&#160;<b>ER_AUTH_DELAY</b> = 257
, <br />
&#160;&#160;<b>ER_AUTH_REQUIRED</b> = 258
, <br />
&#160;&#160;<b>ER_SQL_SEQ_SCAN</b> = 259
, <br />
&#160;&#160;<b>ER_NO_SUCH_EVENT</b> = 260
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_NOT_UNANIMOUS</b> = 261
, <br />
&#160;&#160;<b>ER_CANT_CHECK_BOOTSTRAP_LEADER</b> = 262
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_CONNECTION_NOT_TO_ALL</b> = 263
, <br />
&#160;&#160;<b>ER_NIL_UUID</b> = 264
, <br />
&#160;&#160;<b>ER_WRONG_FUNCTION_OPTIONS</b> = 265
, <br />
&#160;&#160;<b>ER_MISSING_SYSTEM_SPACES</b> = 266
, <br />
&#160;&#160;<b>ER_CLUSTER_NAME_MISMATCH</b> = 267
, <br />
&#160;&#160;<b>ER_REPLICASET_NAME_MISMATCH</b> = 268
, <br />
&#160;&#160;<b>ER_INSTANCE_NAME_DUPLICATE</b> = 269
, <br />
&#160;&#160;<b>ER_INSTANCE_NAME_MISMATCH</b> = 270
, <br />
&#160;&#160;<b>ER_SCHEMA_NEEDS_UPGRADE</b> = 271
, <br />
&#160;&#160;<b>ER_SCHEMA_UPGRADE_IN_PROGRESS</b> = 272
, <br />
&#160;&#160;<b>ER_DEPRECATED</b> = 273
, <br />
&#160;&#160;<b>ER_UNCONFIGURED</b> = 274
, <br />
&#160;&#160;<b>ER_CREATE_DEFAULT_FUNC</b> = 275
, <br />
&#160;&#160;<b>ER_DEFAULT_FUNC_FAILED</b> = 276
, <br />
&#160;&#160;<b>ER_INVALID_DEC</b> = 277
, <br />
&#160;&#160;<b>ER_IN_ANOTHER_PROMOTE</b> = 278
, <br />
&#160;&#160;<b>ER_SHUTDOWN</b> = 279
, <br />
&#160;&#160;<b>ER_FIELD_VALUE_OUT_OF_RANGE</b> = 280
, <br />
&#160;&#160;<b>ER_REPLICASET_NOT_FOUND</b> = 281
, <br />
&#160;&#160;<b>ER_REPLICASET_NO_WRITABLE</b> = 282
, <br />
&#160;&#160;<b>ER_REPLICASET_MORE_THAN_ONE_WRITABLE</b> = 283
, <br />
&#160;&#160;<b>ER_TXN_COMMIT</b> = 284
, <br />
&#160;&#160;<b>ER_READ_VIEW_BUSY</b> = 285
, <br />
&#160;&#160;<b>ER_READ_VIEW_CLOSED</b> = 286
, <br />
&#160;&#160;<b>ER_WAL_QUEUE_FULL</b> = 287
, <br />
&#160;&#160;<b>ER_INVALID_VCLOCK</b> = 288
, <br />
&#160;&#160;<b>ER_SYNC_QUEUE_FULL</b> = 289
, <br />
&#160;&#160;<b>ER_KEY_PART_VALUE_OUT_OF_RANGE</b> = 290
, <br />
&#160;&#160;<b>ER_REPLICA_GC</b> = 291
, <br />
&#160;&#160;<b>ER_ALIEN_ENGINE</b> = 292
, <br />
&#160;&#160;<b>ER_MVCC_UNAVAILABLE</b> = 293
, <br />
&#160;&#160;<b>ER_CANT_UPGRADE_INDEXED_FIELD</b> = 294
, <br />
&#160;&#160;<b>ER_SYNC_TIMEOUT</b> = 295
, <br />
&#160;&#160;<b>ER_FIELD_IRREPRESENTABLE_VALUE</b> = 296
, <br />
&#160;&#160;<b>box_error_code_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:a029e9d16d637a97b37560ccf24c4adce"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a029e9d16d637a97b37560ccf24c4adce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a35d7a7fe53c673112e06ab78794216" id="r_a4a35d7a7fe53c673112e06ab78794216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4a35d7a7fe53c673112e06ab78794216">box_on_shutdown</a> (void *arg, int(*new_handler)(void *), int(*old_handler)(void *))</td></tr>
<tr class="memdesc:a4a35d7a7fe53c673112e06ab78794216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement Attributes }}}.  <br /></td></tr>
<tr class="separator:a4a35d7a7fe53c673112e06ab78794216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9d5dc245f23922392835e55fccba9" id="r_a11d9d5dc245f23922392835e55fccba9"><td class="memItemLeft" align="right" valign="top"><a id="a11d9d5dc245f23922392835e55fccba9" name="a11d9d5dc245f23922392835e55fccba9"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>say_log_level_is_enabled</b> (int level)</td></tr>
<tr class="memdesc:a11d9d5dc245f23922392835e55fccba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function checks whether passed log level is enabled. <br /></td></tr>
<tr class="separator:a11d9d5dc245f23922392835e55fccba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f14b4a77bc8ce8ba99c67004083d23" id="r_aa0f14b4a77bc8ce8ba99c67004083d23"><td class="memItemLeft" align="right" valign="top"><a id="aa0f14b4a77bc8ce8ba99c67004083d23" name="aa0f14b4a77bc8ce8ba99c67004083d23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CFORMAT</b> (printf, 5, 6) extern <a class="el" href="module_8h.html#a24a548551bdc95d156210ec216ded4f9">sayfunc_t</a> _say</td></tr>
<tr class="memdesc:aa0f14b4a77bc8ce8ba99c67004083d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used to implement <a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf" title="Format and print a message to Tarantool log file.">say()</a> macros. <br /></td></tr>
<tr class="separator:aa0f14b4a77bc8ce8ba99c67004083d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfccf290219d520605e8eaac46b16694" id="r_acfccf290219d520605e8eaac46b16694"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acfccf290219d520605e8eaac46b16694">_say_strerror</a> (int errnum)</td></tr>
<tr class="memdesc:acfccf290219d520605e8eaac46b16694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that implements MT-Safe strerror().  <br /></td></tr>
<tr class="separator:acfccf290219d520605e8eaac46b16694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5d5d65285c98e77cf483a0d2a092f9" id="r_a0c5d5d65285c98e77cf483a0d2a092f9"><td class="memItemLeft" align="right" valign="top">struct fiber_attr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0c5d5d65285c98e77cf483a0d2a092f9">fiber_attr_new</a> (void)</td></tr>
<tr class="memdesc:a0c5d5d65285c98e77cf483a0d2a092f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber attribute container and initialize it with default parameters.  <br /></td></tr>
<tr class="separator:a0c5d5d65285c98e77cf483a0d2a092f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4003e7d28985f1573cf3faf8b4d38ee" id="r_ac4003e7d28985f1573cf3faf8b4d38ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac4003e7d28985f1573cf3faf8b4d38ee">fiber_attr_delete</a> (struct fiber_attr *fiber_attr)</td></tr>
<tr class="memdesc:ac4003e7d28985f1573cf3faf8b4d38ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the fiber_attr and free all allocated resources.  <br /></td></tr>
<tr class="separator:ac4003e7d28985f1573cf3faf8b4d38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f42c1a444922edf2163806c5433ae1a" id="r_a4f42c1a444922edf2163806c5433ae1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4f42c1a444922edf2163806c5433ae1a">fiber_attr_setstacksize</a> (struct fiber_attr *fiber_attr, size_t stack_size)</td></tr>
<tr class="memdesc:a4f42c1a444922edf2163806c5433ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stack size for the fiber attribute.  <br /></td></tr>
<tr class="separator:a4f42c1a444922edf2163806c5433ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad628f573827cf2393f0849c194719a94" id="r_ad628f573827cf2393f0849c194719a94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad628f573827cf2393f0849c194719a94">fiber_attr_getstacksize</a> (struct fiber_attr *fiber_attr)</td></tr>
<tr class="memdesc:ad628f573827cf2393f0849c194719a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stack size from the fiber attribute.  <br /></td></tr>
<tr class="separator:ad628f573827cf2393f0849c194719a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb10631936b53aa4a8fad07f5be22caa" id="r_abb10631936b53aa4a8fad07f5be22caa"><td class="memItemLeft" align="right" valign="top"><a id="abb10631936b53aa4a8fad07f5be22caa" name="abb10631936b53aa4a8fad07f5be22caa"></a>
struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><b>fiber_self</b> (void)</td></tr>
<tr class="memdesc:abb10631936b53aa4a8fad07f5be22caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current fiber. <br /></td></tr>
<tr class="separator:abb10631936b53aa4a8fad07f5be22caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8757a0f2f38964c8f1201768043c7a3c" id="r_a8757a0f2f38964c8f1201768043c7a3c"><td class="memItemLeft" align="right" valign="top">struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8757a0f2f38964c8f1201768043c7a3c">fiber_new</a> (const char *name, <a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a> f)</td></tr>
<tr class="memdesc:a8757a0f2f38964c8f1201768043c7a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber.  <br /></td></tr>
<tr class="separator:a8757a0f2f38964c8f1201768043c7a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa5816817a59a6929404d6ad93f5efc" id="r_a4aa5816817a59a6929404d6ad93f5efc"><td class="memItemLeft" align="right" valign="top">struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4aa5816817a59a6929404d6ad93f5efc">fiber_new_ex</a> (const char *name, const struct fiber_attr *fiber_attr, <a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a> f)</td></tr>
<tr class="memdesc:a4aa5816817a59a6929404d6ad93f5efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber with defined attributes.  <br /></td></tr>
<tr class="separator:a4aa5816817a59a6929404d6ad93f5efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5beb40f119b9400bb57b81820b24ff" id="r_aaa5beb40f119b9400bb57b81820b24ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaa5beb40f119b9400bb57b81820b24ff">fiber_yield</a> (void)</td></tr>
<tr class="memdesc:aaa5beb40f119b9400bb57b81820b24ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return control to another fiber and wait until it'll be woken.  <br /></td></tr>
<tr class="separator:aaa5beb40f119b9400bb57b81820b24ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca18eb68ebf89507d4cf5eb3c402cb2" id="r_abca18eb68ebf89507d4cf5eb3c402cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2">fiber_start</a> (struct fiber *callee,...)</td></tr>
<tr class="memdesc:abca18eb68ebf89507d4cf5eb3c402cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start execution of created fiber.  <br /></td></tr>
<tr class="separator:abca18eb68ebf89507d4cf5eb3c402cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac596a2d875dcfa8477bbfc1ccc7b809d" id="r_ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac596a2d875dcfa8477bbfc1ccc7b809d">fiber_set_ctx</a> (struct fiber *f, void *f_arg)</td></tr>
<tr class="memdesc:ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a pointer to context for the fiber.  <br /></td></tr>
<tr class="separator:ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fc765077a289ff21c2e452c4ca85a6" id="r_af1fc765077a289ff21c2e452c4ca85a6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af1fc765077a289ff21c2e452c4ca85a6">fiber_get_ctx</a> (struct fiber *f)</td></tr>
<tr class="memdesc:af1fc765077a289ff21c2e452c4ca85a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context for the fiber which was set via the fiber_set_ctx function.  <br /></td></tr>
<tr class="separator:af1fc765077a289ff21c2e452c4ca85a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661de7f72aa265ff6ffcb8b3acfafe40" id="r_a661de7f72aa265ff6ffcb8b3acfafe40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40">fiber_wakeup</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a661de7f72aa265ff6ffcb8b3acfafe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt a synchronous wait of a fiber.  <br /></td></tr>
<tr class="separator:a661de7f72aa265ff6ffcb8b3acfafe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5b700b2122f08e6bc1298ac7eb0435" id="r_a9a5b700b2122f08e6bc1298ac7eb0435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435">fiber_cancel</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a9a5b700b2122f08e6bc1298ac7eb0435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the subject fiber.  <br /></td></tr>
<tr class="separator:a9a5b700b2122f08e6bc1298ac7eb0435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4078cbddc22b0ed941548f86672224d9" id="r_a4078cbddc22b0ed941548f86672224d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4078cbddc22b0ed941548f86672224d9">fiber_set_cancellable</a> (bool yesno)</td></tr>
<tr class="memdesc:a4078cbddc22b0ed941548f86672224d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:a4078cbddc22b0ed941548f86672224d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee4e98a4e9c2239b5d7eb98c2b0b208" id="r_a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208">fiber_set_joinable</a> (struct fiber *fiber, bool yesno)</td></tr>
<tr class="memdesc:a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fiber to be joinable (false by default).  <br /></td></tr>
<tr class="separator:a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ac22e89f3fdab0556cc5f6922f0f59" id="r_a58ac22e89f3fdab0556cc5f6922f0f59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a58ac22e89f3fdab0556cc5f6922f0f59">fiber_join</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a58ac22e89f3fdab0556cc5f6922f0f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the fiber is dead and then move its execution status to the caller.  <br /></td></tr>
<tr class="separator:a58ac22e89f3fdab0556cc5f6922f0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e8a263a2592320b7260095f5c10f3" id="r_a676e8a263a2592320b7260095f5c10f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a676e8a263a2592320b7260095f5c10f3">fiber_join_timeout</a> (struct fiber *f, double timeout)</td></tr>
<tr class="memdesc:a676e8a263a2592320b7260095f5c10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the fiber is dead or timeout exceeded.  <br /></td></tr>
<tr class="separator:a676e8a263a2592320b7260095f5c10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab0816e3ddf7e11b448926569e6bc49" id="r_a0ab0816e3ddf7e11b448926569e6bc49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0ab0816e3ddf7e11b448926569e6bc49">fiber_sleep</a> (double s)</td></tr>
<tr class="memdesc:a0ab0816e3ddf7e11b448926569e6bc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current fiber to sleep for at least 's' seconds.  <br /></td></tr>
<tr class="separator:a0ab0816e3ddf7e11b448926569e6bc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d46a2ac9d787bc69b61ce09938587" id="r_a972d46a2ac9d787bc69b61ce09938587"><td class="memItemLeft" align="right" valign="top"><a id="a972d46a2ac9d787bc69b61ce09938587" name="a972d46a2ac9d787bc69b61ce09938587"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fiber_is_cancelled</b> (void)</td></tr>
<tr class="memdesc:a972d46a2ac9d787bc69b61ce09938587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check current fiber for cancellation (it must be checked manually). <br /></td></tr>
<tr class="separator:a972d46a2ac9d787bc69b61ce09938587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077a6068c998d2e548168be5e1a6008f" id="r_a077a6068c998d2e548168be5e1a6008f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a077a6068c998d2e548168be5e1a6008f">fiber_time</a> (void)</td></tr>
<tr class="memdesc:a077a6068c998d2e548168be5e1a6008f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as double (cheap).  <br /></td></tr>
<tr class="separator:a077a6068c998d2e548168be5e1a6008f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e9fb25b47b6090a587c92aaf536aed" id="r_ae1e9fb25b47b6090a587c92aaf536aed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae1e9fb25b47b6090a587c92aaf536aed">fiber_time64</a> (void)</td></tr>
<tr class="memdesc:ae1e9fb25b47b6090a587c92aaf536aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as 64-bit int.  <br /></td></tr>
<tr class="separator:ae1e9fb25b47b6090a587c92aaf536aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c835fac5180f57e01c388a95440d5" id="r_a0e1c835fac5180f57e01c388a95440d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0e1c835fac5180f57e01c388a95440d5">fiber_clock</a> (void)</td></tr>
<tr class="memdesc:a0e1c835fac5180f57e01c388a95440d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as double (cheap).  <br /></td></tr>
<tr class="separator:a0e1c835fac5180f57e01c388a95440d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed4eb4281eaa96a74c6e052995af645" id="r_a8ed4eb4281eaa96a74c6e052995af645"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8ed4eb4281eaa96a74c6e052995af645">fiber_clock64</a> (void)</td></tr>
<tr class="memdesc:a8ed4eb4281eaa96a74c6e052995af645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as 64-bit int.  <br /></td></tr>
<tr class="separator:a8ed4eb4281eaa96a74c6e052995af645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0122a4705796fd32c2a54e218c2ff8" id="r_a1d0122a4705796fd32c2a54e218c2ff8"><td class="memItemLeft" align="right" valign="top"><a id="a1d0122a4705796fd32c2a54e218c2ff8" name="a1d0122a4705796fd32c2a54e218c2ff8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fiber_reschedule</b> (void)</td></tr>
<tr class="memdesc:a1d0122a4705796fd32c2a54e218c2ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule fiber to end of event loop cycle. <br /></td></tr>
<tr class="separator:a1d0122a4705796fd32c2a54e218c2ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1b21447c8f1e31be96d47a293529bb" id="r_a0a1b21447c8f1e31be96d47a293529bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0a1b21447c8f1e31be96d47a293529bb">fiber_set_name_n</a> (struct fiber *fiber, const char *name, uint32_t len)</td></tr>
<tr class="memdesc:a0a1b21447c8f1e31be96d47a293529bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fiber name.  <br /></td></tr>
<tr class="separator:a0a1b21447c8f1e31be96d47a293529bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4238673bb1300b2b3e5ec6af6fe8ccf6" id="r_a4238673bb1300b2b3e5ec6af6fe8ccf6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4238673bb1300b2b3e5ec6af6fe8ccf6">fiber_name</a> (const struct fiber *fiber)</td></tr>
<tr class="memdesc:a4238673bb1300b2b3e5ec6af6fe8ccf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fiber name.  <br /></td></tr>
<tr class="separator:a4238673bb1300b2b3e5ec6af6fe8ccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a115d72a466ab6f33daac6f7e88ff4" id="r_a90a115d72a466ab6f33daac6f7e88ff4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a90a115d72a466ab6f33daac6f7e88ff4">fiber_id</a> (const struct fiber *fiber)</td></tr>
<tr class="memdesc:a90a115d72a466ab6f33daac6f7e88ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fiber id.  <br /></td></tr>
<tr class="separator:a90a115d72a466ab6f33daac6f7e88ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcecceb5c3cb756d858c4fb536efb9f" id="r_a9bcecceb5c3cb756d858c4fb536efb9f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9bcecceb5c3cb756d858c4fb536efb9f">fiber_csw</a> (const struct fiber *fiber)</td></tr>
<tr class="memdesc:a9bcecceb5c3cb756d858c4fb536efb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of context switches of the given fiber.  <br /></td></tr>
<tr class="separator:a9bcecceb5c3cb756d858c4fb536efb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd431e93666009ddd86563809962240" id="r_a6dd431e93666009ddd86563809962240"><td class="memItemLeft" align="right" valign="top">struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6dd431e93666009ddd86563809962240">fiber_find</a> (uint64_t fid)</td></tr>
<tr class="memdesc:a6dd431e93666009ddd86563809962240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a live fiber in the current cord by the given fiber id, which may be used for getting other info about the fiber (name, csw, etc.).  <br /></td></tr>
<tr class="separator:a6dd431e93666009ddd86563809962240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113af82955ade6d52b5a03fc327b266f" id="r_a113af82955ade6d52b5a03fc327b266f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">box_region_used</a> (void)</td></tr>
<tr class="memdesc:a113af82955ade6d52b5a03fc327b266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">box region allocator  <br /></td></tr>
<tr class="separator:a113af82955ade6d52b5a03fc327b266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e232fab2a9b3f2362bde6f03b83f67b" id="r_a1e232fab2a9b3f2362bde6f03b83f67b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1e232fab2a9b3f2362bde6f03b83f67b">box_region_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:a1e232fab2a9b3f2362bde6f03b83f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size bytes from the box region.  <br /></td></tr>
<tr class="separator:a1e232fab2a9b3f2362bde6f03b83f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751fd698cbeca02ecca506f2fcdb1c60" id="r_a751fd698cbeca02ecca506f2fcdb1c60"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a751fd698cbeca02ecca506f2fcdb1c60">box_region_aligned_alloc</a> (size_t size, size_t alignment)</td></tr>
<tr class="memdesc:a751fd698cbeca02ecca506f2fcdb1c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size bytes from the box region with given alignment.  <br /></td></tr>
<tr class="separator:a751fd698cbeca02ecca506f2fcdb1c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6575301cf1bd4df1bfad9a319b80a0b4" id="r_a6575301cf1bd4df1bfad9a319b80a0b4"><td class="memItemLeft" align="right" valign="top"><a id="a6575301cf1bd4df1bfad9a319b80a0b4" name="a6575301cf1bd4df1bfad9a319b80a0b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>box_region_truncate</b> (size_t size)</td></tr>
<tr class="memdesc:a6575301cf1bd4df1bfad9a319b80a0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the box region to the given size. <br /></td></tr>
<tr class="separator:a6575301cf1bd4df1bfad9a319b80a0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed23f85d72dff57249cc6633ef945340" id="r_aed23f85d72dff57249cc6633ef945340"><td class="memItemLeft" align="right" valign="top">struct fiber_cond *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aed23f85d72dff57249cc6633ef945340">fiber_cond_new</a> (void)</td></tr>
<tr class="memdesc:aed23f85d72dff57249cc6633ef945340"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:aed23f85d72dff57249cc6633ef945340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64787aacecdc620e9b7e402babf9ae1e" id="r_a64787aacecdc620e9b7e402babf9ae1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a64787aacecdc620e9b7e402babf9ae1e">fiber_cond_delete</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a64787aacecdc620e9b7e402babf9ae1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the fiber cond object.  <br /></td></tr>
<tr class="separator:a64787aacecdc620e9b7e402babf9ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13caca027d090cc02574e333c78f3c" id="r_a3f13caca027d090cc02574e333c78f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c">fiber_cond_signal</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a3f13caca027d090cc02574e333c78f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake one fiber waiting for the cond.  <br /></td></tr>
<tr class="separator:a3f13caca027d090cc02574e333c78f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbca6fff4cd2ccf2b65528ea5e1e1e39" id="r_abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abbca6fff4cd2ccf2b65528ea5e1e1e39">fiber_cond_broadcast</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up all fibers waiting for the cond.  <br /></td></tr>
<tr class="separator:abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7882234efd30663364ded133ab3fad" id="r_a9e7882234efd30663364ded133ab3fad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad">fiber_cond_wait_timeout</a> (struct fiber_cond *cond, double timeout)</td></tr>
<tr class="memdesc:a9e7882234efd30663364ded133ab3fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the execution of the current fiber (i.e.  <br /></td></tr>
<tr class="separator:a9e7882234efd30663364ded133ab3fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd72e262e9e59a14c1337bc0fa2447c" id="r_a1dd72e262e9e59a14c1337bc0fa2447c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1dd72e262e9e59a14c1337bc0fa2447c">fiber_cond_wait</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a1dd72e262e9e59a14c1337bc0fa2447c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for <a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a>.  <br /></td></tr>
<tr class="separator:a1dd72e262e9e59a14c1337bc0fa2447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c521a569fd78b25f355f3b7525ba9a" id="r_ab9c521a569fd78b25f355f3b7525ba9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab9c521a569fd78b25f355f3b7525ba9a">coio_wait</a> (int fd, int event, double timeout)</td></tr>
<tr class="memdesc:ab9c521a569fd78b25f355f3b7525ba9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until READ or WRITE event on socket (<em>fd</em>).  <br /></td></tr>
<tr class="separator:ab9c521a569fd78b25f355f3b7525ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23dc320746ce4ec9afdf433a66ef596" id="r_af23dc320746ce4ec9afdf433a66ef596"><td class="memItemLeft" align="right" valign="top"><a id="af23dc320746ce4ec9afdf433a66ef596" name="af23dc320746ce4ec9afdf433a66ef596"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>coio_close</b> (int fd)</td></tr>
<tr class="memdesc:af23dc320746ce4ec9afdf433a66ef596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the fd and wake any fiber blocked in <a class="el" href="module_8h.html#ab9c521a569fd78b25f355f3b7525ba9a" title="Wait until READ or WRITE event on socket (fd).">coio_wait()</a> call on this fd. <br /></td></tr>
<tr class="separator:af23dc320746ce4ec9afdf433a66ef596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9433c7d42d7747f1f69b79a0d98df13" id="r_af9433c7d42d7747f1f69b79a0d98df13"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a> (ssize_t(*func)(va_list),...)</td></tr>
<tr class="memdesc:af9433c7d42d7747f1f69b79a0d98df13"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:af9433c7d42d7747f1f69b79a0d98df13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832b67e03175570d9f6fa17ffd77bf83" id="r_a832b67e03175570d9f6fa17ffd77bf83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a832b67e03175570d9f6fa17ffd77bf83">coio_getaddrinfo</a> (const char *host, const char *port, const struct addrinfo *hints, struct addrinfo **res, double timeout)</td></tr>
<tr class="memdesc:a832b67e03175570d9f6fa17ffd77bf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber-friendly version of getaddrinfo(3).  <br /></td></tr>
<tr class="separator:a832b67e03175570d9f6fa17ffd77bf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616f82352b7ba1ee74c02d402dfefc52" id="r_a616f82352b7ba1ee74c02d402dfefc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a616f82352b7ba1ee74c02d402dfefc52">tnt_tx_push</a> (<a class="el" href="module_8h.html#abba432143f6c7876ea8704638e9c9e5d">tnt_tx_func_f</a> func, void *arg)</td></tr>
<tr class="memdesc:a616f82352b7ba1ee74c02d402dfefc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the given callback to be executed in TX thread with the provided argument.  <br /></td></tr>
<tr class="separator:a616f82352b7ba1ee74c02d402dfefc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be466e9dc2ecebafa253b4f1658c7b" id="r_a78be466e9dc2ecebafa253b4f1658c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a78be466e9dc2ecebafa253b4f1658c7b">tnt_tx_flush</a> (void)</td></tr>
<tr class="memdesc:a78be466e9dc2ecebafa253b4f1658c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all the pending callbacks of this thread to TX thread.  <br /></td></tr>
<tr class="separator:a78be466e9dc2ecebafa253b4f1658c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a407327a4c9860b0f088aa677c1a0e7" id="r_a4a407327a4c9860b0f088aa677c1a0e7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4a407327a4c9860b0f088aa677c1a0e7">box_ibuf_reserve</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, size_t size)</td></tr>
<tr class="memdesc:a4a407327a4c9860b0f088aa677c1a0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve requested amount of bytes in ibuf buffer.  <br /></td></tr>
<tr class="separator:a4a407327a4c9860b0f088aa677c1a0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9d369f674c637b476fd92b00d3da5" id="r_a1fb9d369f674c637b476fd92b00d3da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1fb9d369f674c637b476fd92b00d3da5">box_ibuf_read_range</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, char ***rpos, char ***wpos)</td></tr>
<tr class="memdesc:a1fb9d369f674c637b476fd92b00d3da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to read range pointers used [rpos..wpos)  <br /></td></tr>
<tr class="separator:a1fb9d369f674c637b476fd92b00d3da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b2d0e25c3a295f9ae0200a787c432" id="r_ac74b2d0e25c3a295f9ae0200a787c432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac74b2d0e25c3a295f9ae0200a787c432">box_ibuf_write_range</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, char ***wpos, char ***end)</td></tr>
<tr class="memdesc:ac74b2d0e25c3a295f9ae0200a787c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to write range pointers used [wpos..end)  <br /></td></tr>
<tr class="separator:ac74b2d0e25c3a295f9ae0200a787c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9bcfc8296607ac6cbfdd9d44cd7451" id="r_acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acc9bcfc8296607ac6cbfdd9d44cd7451">luaL_iscdata</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf0ae8133e330bcc1ccf9beabf7637" id="r_a71cf0ae8133e330bcc1ccf9beabf7637"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a71cf0ae8133e330bcc1ccf9beabf7637">luaL_pushcdata</a> (struct lua_State *L, uint32_t ctypeid)</td></tr>
<tr class="memdesc:a71cf0ae8133e330bcc1ccf9beabf7637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push cdata of given <em>ctypeid</em> onto the stack.  <br /></td></tr>
<tr class="separator:a71cf0ae8133e330bcc1ccf9beabf7637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6199825fbbd80b6f27ff6bc2f2a1b7" id="r_aad6199825fbbd80b6f27ff6bc2f2a1b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aad6199825fbbd80b6f27ff6bc2f2a1b7">luaL_checkcdata</a> (struct lua_State *L, int idx, uint32_t *ctypeid)</td></tr>
<tr class="memdesc:aad6199825fbbd80b6f27ff6bc2f2a1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the function argument idx is a cdata.  <br /></td></tr>
<tr class="separator:aad6199825fbbd80b6f27ff6bc2f2a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fc5e919f74956a06a9b40fb24f691" id="r_aa62fc5e919f74956a06a9b40fb24f691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa62fc5e919f74956a06a9b40fb24f691">luaL_setcdatagc</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:aa62fc5e919f74956a06a9b40fb24f691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets finalizer function on a cdata object.  <br /></td></tr>
<tr class="separator:aa62fc5e919f74956a06a9b40fb24f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac765ca13d67a265532e8fe4cceb4aa5a" id="r_ac765ca13d67a265532e8fe4cceb4aa5a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac765ca13d67a265532e8fe4cceb4aa5a">luaL_getgctotal</a> (struct lua_State *L)</td></tr>
<tr class="memdesc:ac765ca13d67a265532e8fe4cceb4aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of currently allocated memory.  <br /></td></tr>
<tr class="separator:ac765ca13d67a265532e8fe4cceb4aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1f07b7fe39b8bd9b7a87f7c84d5d73" id="r_a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5d1f07b7fe39b8bd9b7a87f7c84d5d73">luaL_ctypeid</a> (struct lua_State *L, const char *ctypename)</td></tr>
<tr class="memdesc:a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CTypeID (FFI) of given DATA type.  <br /></td></tr>
<tr class="separator:a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498681c0c56f0aebe938004ab8947b0f" id="r_a498681c0c56f0aebe938004ab8947b0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a498681c0c56f0aebe938004ab8947b0f">luaL_cdef</a> (struct lua_State *L, const char *ctypename)</td></tr>
<tr class="memdesc:a498681c0c56f0aebe938004ab8947b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare symbols for FFI.  <br /></td></tr>
<tr class="separator:a498681c0c56f0aebe938004ab8947b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6439d4dd158b27d2567e1bfd6243e084" id="r_a6439d4dd158b27d2567e1bfd6243e084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6439d4dd158b27d2567e1bfd6243e084">luaL_pushuint64</a> (struct lua_State *L, uint64_t val)</td></tr>
<tr class="memdesc:a6439d4dd158b27d2567e1bfd6243e084"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a6439d4dd158b27d2567e1bfd6243e084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcccfbc48bac7e8cf4802e839c2f198" id="r_a1dcccfbc48bac7e8cf4802e839c2f198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1dcccfbc48bac7e8cf4802e839c2f198">luaL_pushint64</a> (struct lua_State *L, int64_t val)</td></tr>
<tr class="memdesc:a1dcccfbc48bac7e8cf4802e839c2f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push int64_t onto the stack.  <br /></td></tr>
<tr class="separator:a1dcccfbc48bac7e8cf4802e839c2f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5247fbc8230e2f49464e25e27b87d35" id="r_ac5247fbc8230e2f49464e25e27b87d35"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac5247fbc8230e2f49464e25e27b87d35">luaL_checkuint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:ac5247fbc8230e2f49464e25e27b87d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a uint64 or a convertible string and returns this number.  <br /></td></tr>
<tr class="separator:ac5247fbc8230e2f49464e25e27b87d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159fe92272b876c3fa7b130f026705bd" id="r_a159fe92272b876c3fa7b130f026705bd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a159fe92272b876c3fa7b130f026705bd">luaL_checkint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a159fe92272b876c3fa7b130f026705bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a int64 or a convertible string and returns this number.  <br /></td></tr>
<tr class="separator:a159fe92272b876c3fa7b130f026705bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e035148bc707412c054291f9b51855" id="r_a20e035148bc707412c054291f9b51855"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a20e035148bc707412c054291f9b51855">luaL_touint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a20e035148bc707412c054291f9b51855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a uint64 or a convertible string and returns this number.  <br /></td></tr>
<tr class="separator:a20e035148bc707412c054291f9b51855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31727f17a0a09ff7fb92ac3d2eaa2dce" id="r_a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a31727f17a0a09ff7fb92ac3d2eaa2dce">luaL_toint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a int64 or a convertible string and returns this number.  <br /></td></tr>
<tr class="separator:a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95f4e99d2f7b5be64ca3918fdc4ccf" id="r_a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4c95f4e99d2f7b5be64ca3918fdc4ccf">luaT_call</a> (lua_State *L, int nargs, int nreturns)</td></tr>
<tr class="memdesc:a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_call(), but with the proper support of Tarantool errors.  <br /></td></tr>
<tr class="separator:a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5310ad259a9b8ea40603a3d7f1946" id="r_aa1a5310ad259a9b8ea40603a3d7f1946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa1a5310ad259a9b8ea40603a3d7f1946">luaT_dostring</a> (struct lua_State *L, const char *str)</td></tr>
<tr class="memdesc:aa1a5310ad259a9b8ea40603a3d7f1946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like luaL_dostring(), but in case of error sets fiber diag instead of putting error on stack.  <br /></td></tr>
<tr class="separator:aa1a5310ad259a9b8ea40603a3d7f1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aafb8aaa59640f2b7130e9281e53ec" id="r_a08aafb8aaa59640f2b7130e9281e53ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08aafb8aaa59640f2b7130e9281e53ec">luaT_cpcall</a> (lua_State *L, lua_CFunction func, void *ud)</td></tr>
<tr class="memdesc:a08aafb8aaa59640f2b7130e9281e53ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_cpcall(), but with the proper support of Tarantool errors.  <br /></td></tr>
<tr class="separator:a08aafb8aaa59640f2b7130e9281e53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d9f428cd77e6beb5c84681ffb7315" id="r_a6f7d9f428cd77e6beb5c84681ffb7315"><td class="memItemLeft" align="right" valign="top"><a id="a6f7d9f428cd77e6beb5c84681ffb7315" name="a6f7d9f428cd77e6beb5c84681ffb7315"></a>
lua_State *&#160;</td><td class="memItemRight" valign="bottom"><b>luaT_state</b> (void)</td></tr>
<tr class="memdesc:a6f7d9f428cd77e6beb5c84681ffb7315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global Lua state used by Tarantool. <br /></td></tr>
<tr class="separator:a6f7d9f428cd77e6beb5c84681ffb7315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95ddc32125234d1fb608b3cb484c6d" id="r_a3c95ddc32125234d1fb608b3cb484c6d"><td class="memItemLeft" align="right" valign="top"><a id="a3c95ddc32125234d1fb608b3cb484c6d" name="a3c95ddc32125234d1fb608b3cb484c6d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>luaT_tolstring</b> (lua_State *L, int idx, size_t *ssize)</td></tr>
<tr class="memdesc:a3c95ddc32125234d1fb608b3cb484c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_tolstring, but supports metatables, booleans and nil properly. <br /></td></tr>
<tr class="separator:a3c95ddc32125234d1fb608b3cb484c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ca887563c2bcd2e17ad199dac627b2" id="r_a08ca887563c2bcd2e17ad199dac627b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08ca887563c2bcd2e17ad199dac627b2">luaL_iscallable</a> (lua_State *L, int idx)</td></tr>
<tr class="memdesc:a08ca887563c2bcd2e17ad199dac627b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a Lua object is a function or has metatable/metatype with a __call field.  <br /></td></tr>
<tr class="separator:a08ca887563c2bcd2e17ad199dac627b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1bdf425a10a3cb4e51f732195e9b39" id="r_aff1bdf425a10a3cb4e51f732195e9b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aff1bdf425a10a3cb4e51f732195e9b39">luaT_toibuf</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:aff1bdf425a10a3cb4e51f732195e9b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value on <em>L</em> stack by index <em>idx</em> is an ibuf object.  <br /></td></tr>
<tr class="separator:aff1bdf425a10a3cb4e51f732195e9b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb6909b96e0c27329d9de8e05e6a805" id="r_adeb6909b96e0c27329d9de8e05e6a805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adeb6909b96e0c27329d9de8e05e6a805">luaL_pushnull</a> (struct lua_State *L)</td></tr>
<tr class="memdesc:adeb6909b96e0c27329d9de8e05e6a805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push ffi's NULL (cdata&lt;void *&gt;: NULL) onto the stack.  <br /></td></tr>
<tr class="separator:adeb6909b96e0c27329d9de8e05e6a805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d39020c975535bd3b17446d866ee4c8" id="r_a9d39020c975535bd3b17446d866ee4c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9d39020c975535bd3b17446d866ee4c8">luaL_isnull</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a9d39020c975535bd3b17446d866ee4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value at Lua stack is ffi's NULL (cdata&lt;void *&gt;: NULL).  <br /></td></tr>
<tr class="separator:a9d39020c975535bd3b17446d866ee4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e643c0eff90628dd8cb09ddd8dfc68" id="r_ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae5e643c0eff90628dd8cb09ddd8dfc68">luaT_error</a> (lua_State *L)</td></tr>
<tr class="memdesc:ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-throws the last Tarantool error as a Lua object.  <br /></td></tr>
<tr class="separator:ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fccc46b7877086aefbcce5535e8b1cf" id="r_a8fccc46b7877086aefbcce5535e8b1cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8fccc46b7877086aefbcce5535e8b1cf">luaT_error_at</a> (lua_State *L, int level)</td></tr>
<tr class="memdesc:a8fccc46b7877086aefbcce5535e8b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as luaT_error but set error trace frame according to given level.  <br /></td></tr>
<tr class="separator:a8fccc46b7877086aefbcce5535e8b1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1740670301221218d3780f2a4df33c6" id="r_aa1740670301221218d3780f2a4df33c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa1740670301221218d3780f2a4df33c6">luaT_push_nil_and_error</a> (lua_State *L)</td></tr>
<tr class="memdesc:aa1740670301221218d3780f2a4df33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return nil as the first return value and an error as the second.  <br /></td></tr>
<tr class="separator:aa1740670301221218d3780f2a4df33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9f0f763644cd5edc43ac632078b471" id="r_aff9f0f763644cd5edc43ac632078b471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aff9f0f763644cd5edc43ac632078b471">luaT_pusherror</a> (struct lua_State *L, struct error *e)</td></tr>
<tr class="memdesc:aff9f0f763644cd5edc43ac632078b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push error to a Lua stack.  <br /></td></tr>
<tr class="separator:aff9f0f763644cd5edc43ac632078b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf484fef1147b9e53323cd5082b505" id="r_a94bf484fef1147b9e53323cd5082b505"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a94bf484fef1147b9e53323cd5082b505">box_txn_id</a> (void)</td></tr>
<tr class="memdesc:a94bf484fef1147b9e53323cd5082b505"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a94bf484fef1147b9e53323cd5082b505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab434c9ba079ac5578be4699220b1860f" id="r_ab434c9ba079ac5578be4699220b1860f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab434c9ba079ac5578be4699220b1860f">box_txn_isolation</a> (void)</td></tr>
<tr class="memdesc:ab434c9ba079ac5578be4699220b1860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get isolation level of current transaction, one of enum txn_isolation_level values (but cannot be TXN_ISOLATION_DEFAULT (which is zero) by design).  <br /></td></tr>
<tr class="separator:ab434c9ba079ac5578be4699220b1860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44f82b5dd34b12026c33baf63ba3fee" id="r_af44f82b5dd34b12026c33baf63ba3fee"><td class="memItemLeft" align="right" valign="top"><a id="af44f82b5dd34b12026c33baf63ba3fee" name="af44f82b5dd34b12026c33baf63ba3fee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>box_txn</b> (void)</td></tr>
<tr class="memdesc:af44f82b5dd34b12026c33baf63ba3fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is an active transaction. <br /></td></tr>
<tr class="separator:af44f82b5dd34b12026c33baf63ba3fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88346fff21ac55ecf5e8e7e8750093ce" id="r_a88346fff21ac55ecf5e8e7e8750093ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a88346fff21ac55ecf5e8e7e8750093ce">box_txn_begin</a> (void)</td></tr>
<tr class="memdesc:a88346fff21ac55ecf5e8e7e8750093ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a transaction in the current fiber.  <br /></td></tr>
<tr class="separator:a88346fff21ac55ecf5e8e7e8750093ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c69864552de6ae21c4edce2bbf949" id="r_a541c69864552de6ae21c4edce2bbf949"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a541c69864552de6ae21c4edce2bbf949">box_txn_commit</a> (void)</td></tr>
<tr class="memdesc:a541c69864552de6ae21c4edce2bbf949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the current transaction.  <br /></td></tr>
<tr class="separator:a541c69864552de6ae21c4edce2bbf949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59188d28eb2a8cd892d48f74041fec45" id="r_a59188d28eb2a8cd892d48f74041fec45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a59188d28eb2a8cd892d48f74041fec45">box_txn_rollback</a> (void)</td></tr>
<tr class="memdesc:a59188d28eb2a8cd892d48f74041fec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rollback the current transaction.  <br /></td></tr>
<tr class="separator:a59188d28eb2a8cd892d48f74041fec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d157a0b9ff004736c655db785486447" id="r_a6d157a0b9ff004736c655db785486447"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6d157a0b9ff004736c655db785486447">box_txn_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:a6d157a0b9ff004736c655db785486447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory on txn memory pool.  <br /></td></tr>
<tr class="separator:a6d157a0b9ff004736c655db785486447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e930976f6e8e73e213f701c3761fce4" id="r_a3e930976f6e8e73e213f701c3761fce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3e930976f6e8e73e213f701c3761fce4">box_txn_set_timeout</a> (double timeout)</td></tr>
<tr class="memdesc:a3e930976f6e8e73e213f701c3761fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>timeout</em> for transaction, when it expires, transaction will be rolled back.  <br /></td></tr>
<tr class="separator:a3e930976f6e8e73e213f701c3761fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24686e9b0f80d53ded039aa69dfd33" id="r_a8a24686e9b0f80d53ded039aa69dfd33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8a24686e9b0f80d53ded039aa69dfd33">box_txn_set_isolation</a> (uint32_t level)</td></tr>
<tr class="memdesc:a8a24686e9b0f80d53ded039aa69dfd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an isolation <em>level</em> for a transaction.  <br /></td></tr>
<tr class="separator:a8a24686e9b0f80d53ded039aa69dfd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2442c7908ecc3c927337bbd3e2da00e9" id="r_a2442c7908ecc3c927337bbd3e2da00e9"><td class="memItemLeft" align="right" valign="top"><a id="a2442c7908ecc3c927337bbd3e2da00e9" name="a2442c7908ecc3c927337bbd3e2da00e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>box_txn_make_sync</b> (void)</td></tr>
<tr class="memdesc:a2442c7908ecc3c927337bbd3e2da00e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the transaction synchronous. <br /></td></tr>
<tr class="separator:a2442c7908ecc3c927337bbd3e2da00e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ff178dd0ab620350f84d8cde8a341" id="r_ad42ff178dd0ab620350f84d8cde8a341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad42ff178dd0ab620350f84d8cde8a341">box_tuple_format_default</a> (void)</td></tr>
<tr class="memdesc:ad42ff178dd0ab620350f84d8cde8a341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple Format.  <br /></td></tr>
<tr class="separator:ad42ff178dd0ab620350f84d8cde8a341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2211f2682d19f564c55f2888e35d6430" id="r_a2211f2682d19f564c55f2888e35d6430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430">box_tuple_ref</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a2211f2682d19f564c55f2888e35d6430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference counter of tuple.  <br /></td></tr>
<tr class="separator:a2211f2682d19f564c55f2888e35d6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d7b12b1afbff0c3cc20726c10cc6cc" id="r_a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc">box_tuple_unref</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the reference counter of tuple.  <br /></td></tr>
<tr class="separator:a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d61b749ed483d35b65025eaa3039e" id="r_a800d61b749ed483d35b65025eaa3039e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a800d61b749ed483d35b65025eaa3039e">box_tuple_field_count</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a800d61b749ed483d35b65025eaa3039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of fields in tuple (the size of MsgPack Array).  <br /></td></tr>
<tr class="separator:a800d61b749ed483d35b65025eaa3039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf51406abdaed2efa950aa428ca3ad1" id="r_a0bf51406abdaed2efa950aa428ca3ad1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0bf51406abdaed2efa950aa428ca3ad1">box_tuple_data</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, size_t *bsize)</td></tr>
<tr class="memdesc:a0bf51406abdaed2efa950aa428ca3ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the raw tuple MsgPack Array data.  <br /></td></tr>
<tr class="separator:a0bf51406abdaed2efa950aa428ca3ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6812d20a87dc1f55648679680d0d2272" id="r_a6812d20a87dc1f55648679680d0d2272"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6812d20a87dc1f55648679680d0d2272">box_tuple_bsize</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a6812d20a87dc1f55648679680d0d2272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes used to store internal tuple data (MsgPack Array).  <br /></td></tr>
<tr class="separator:a6812d20a87dc1f55648679680d0d2272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af520a6742b61a5bcb879b75d09d72f4e" id="r_af520a6742b61a5bcb879b75d09d72f4e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af520a6742b61a5bcb879b75d09d72f4e">box_tuple_to_buf</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, char *buf, size_t size)</td></tr>
<tr class="memdesc:af520a6742b61a5bcb879b75d09d72f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump raw MsgPack data to the memory buffer <em>buf</em> of size <em>size</em>.  <br /></td></tr>
<tr class="separator:af520a6742b61a5bcb879b75d09d72f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5de2d649fd56eacbe7d734643620ea" id="r_afb5de2d649fd56eacbe7d734643620ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afb5de2d649fd56eacbe7d734643620ea">box_tuple_format</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:afb5de2d649fd56eacbe7d734643620ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the associated format.  <br /></td></tr>
<tr class="separator:afb5de2d649fd56eacbe7d734643620ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae249982b4154dfbc763fa6b4c9dc5aa6" id="r_ae249982b4154dfbc763fa6b4c9dc5aa6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae249982b4154dfbc763fa6b4c9dc5aa6">box_tuple_field</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, uint32_t fieldno)</td></tr>
<tr class="memdesc:ae249982b4154dfbc763fa6b4c9dc5aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw tuple field in MsgPack format.  <br /></td></tr>
<tr class="separator:ae249982b4154dfbc763fa6b4c9dc5aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e8bc08352e18e941326d6118b4dbd" id="r_a935e8bc08352e18e941326d6118b4dbd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a935e8bc08352e18e941326d6118b4dbd">box_tuple_field_by_path</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *path, uint32_t path_len, int index_base)</td></tr>
<tr class="memdesc:a935e8bc08352e18e941326d6118b4dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw tuple field in the MsgPack format pointed by a JSON path.  <br /></td></tr>
<tr class="separator:a935e8bc08352e18e941326d6118b4dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5812aa63732b19983fe43c7b436afc2" id="r_af5812aa63732b19983fe43c7b436afc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af5812aa63732b19983fe43c7b436afc2">box_tuple_iterator</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:af5812aa63732b19983fe43c7b436afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tuple iterator.  <br /></td></tr>
<tr class="separator:af5812aa63732b19983fe43c7b436afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbb37bc35f4c2eac665acb61f08da95" id="r_acbbb37bc35f4c2eac665acb61f08da95"><td class="memItemLeft" align="right" valign="top"><a id="acbbb37bc35f4c2eac665acb61f08da95" name="acbbb37bc35f4c2eac665acb61f08da95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_iterator_free</b> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:acbbb37bc35f4c2eac665acb61f08da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free tuple iterator. <br /></td></tr>
<tr class="separator:acbbb37bc35f4c2eac665acb61f08da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24865c6c4138cd6a252f32c55c812c6" id="r_ac24865c6c4138cd6a252f32c55c812c6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:ac24865c6c4138cd6a252f32c55c812c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return zero-based next position in iterator.  <br /></td></tr>
<tr class="separator:ac24865c6c4138cd6a252f32c55c812c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa998b89aa550c51d8576d3b766d1a67" id="r_aaa998b89aa550c51d8576d3b766d1a67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:aaa998b89aa550c51d8576d3b766d1a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind iterator to the initial position.  <br /></td></tr>
<tr class="separator:aaa998b89aa550c51d8576d3b766d1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ab5877a484f94d7454b25737bd11df" id="r_ad7ab5877a484f94d7454b25737bd11df"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad7ab5877a484f94d7454b25737bd11df">box_tuple_seek</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it, uint32_t fieldno)</td></tr>
<tr class="memdesc:ad7ab5877a484f94d7454b25737bd11df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek the tuple iterator.  <br /></td></tr>
<tr class="separator:ad7ab5877a484f94d7454b25737bd11df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80dc63e3007553d4952681f97966146" id="r_ac80dc63e3007553d4952681f97966146"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac80dc63e3007553d4952681f97966146">box_tuple_next</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:ac80dc63e3007553d4952681f97966146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next tuple field from tuple iterator.  <br /></td></tr>
<tr class="separator:ac80dc63e3007553d4952681f97966146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283636709357b346d38a44345a0a7297" id="r_a283636709357b346d38a44345a0a7297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a283636709357b346d38a44345a0a7297">box_tuple_new</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format, const char *data, const char *end)</td></tr>
<tr class="memdesc:a283636709357b346d38a44345a0a7297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tuple from a raw MsgPack Array data.  <br /></td></tr>
<tr class="separator:a283636709357b346d38a44345a0a7297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7828361e1999ca87deec4dba0edf0a96" id="r_a7828361e1999ca87deec4dba0edf0a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7828361e1999ca87deec4dba0edf0a96">box_tuple_update</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *expr, const char *expr_end)</td></tr>
<tr class="memdesc:a7828361e1999ca87deec4dba0edf0a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a tuple.  <br /></td></tr>
<tr class="separator:a7828361e1999ca87deec4dba0edf0a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc32bd58e9b190a5857d022e568743c1" id="r_adc32bd58e9b190a5857d022e568743c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adc32bd58e9b190a5857d022e568743c1">box_tuple_upsert</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *expr, const char *expr_end)</td></tr>
<tr class="memdesc:adc32bd58e9b190a5857d022e568743c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a tuple.  <br /></td></tr>
<tr class="separator:adc32bd58e9b190a5857d022e568743c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05611324090cd538b14e0728cf185a" id="r_a8f05611324090cd538b14e0728cf185a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8f05611324090cd538b14e0728cf185a">box_tuple_validate</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, <a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a8f05611324090cd538b14e0728cf185a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tuple data correspondence to the space format.  <br /></td></tr>
<tr class="separator:a8f05611324090cd538b14e0728cf185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7993cc0cf6aab8047c50911d1e3d91ee" id="r_a7993cc0cf6aab8047c50911d1e3d91ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7993cc0cf6aab8047c50911d1e3d91ee">box_key_def_new</a> (uint32_t *fields, uint32_t *types, uint32_t part_count)</td></tr>
<tr class="memdesc:a7993cc0cf6aab8047c50911d1e3d91ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create key definition with given field numbers and field types.  <br /></td></tr>
<tr class="separator:a7993cc0cf6aab8047c50911d1e3d91ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f751905f893144ead356172137e796" id="r_a52f751905f893144ead356172137e796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a52f751905f893144ead356172137e796">box_key_part_def_create</a> (<a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *part)</td></tr>
<tr class="memdesc:a52f751905f893144ead356172137e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key part with default values.  <br /></td></tr>
<tr class="separator:a52f751905f893144ead356172137e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0eb2d3a12d2588226a2a232f7b718" id="r_a0ee0eb2d3a12d2588226a2a232f7b718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718">box_key_def_new_v2</a> (<a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *parts, uint32_t part_count)</td></tr>
<tr class="memdesc:a0ee0eb2d3a12d2588226a2a232f7b718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key_def from given key parts.  <br /></td></tr>
<tr class="separator:a0ee0eb2d3a12d2588226a2a232f7b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d39b3f4fb10333b555b77d07949d0" id="r_ad06d39b3f4fb10333b555b77d07949d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad06d39b3f4fb10333b555b77d07949d0">box_key_def_dup</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:ad06d39b3f4fb10333b555b77d07949d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate key_def.  <br /></td></tr>
<tr class="separator:ad06d39b3f4fb10333b555b77d07949d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fdf05e0d276baa072123358c29e046" id="r_a82fdf05e0d276baa072123358c29e046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a82fdf05e0d276baa072123358c29e046">box_key_def_delete</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:a82fdf05e0d276baa072123358c29e046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete key definition.  <br /></td></tr>
<tr class="separator:a82fdf05e0d276baa072123358c29e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6445ef676ed2dee9b3aa23efebccd8" id="r_a4b6445ef676ed2dee9b3aa23efebccd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4b6445ef676ed2dee9b3aa23efebccd8">box_key_def_dump_parts</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, uint32_t *part_count_ptr)</td></tr>
<tr class="memdesc:a4b6445ef676ed2dee9b3aa23efebccd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump key part definitions of given key_def.  <br /></td></tr>
<tr class="separator:a4b6445ef676ed2dee9b3aa23efebccd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01aea33b0593fd1b84243be7033469" id="r_a3c01aea33b0593fd1b84243be7033469"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3c01aea33b0593fd1b84243be7033469">box_key_def_validate_tuple</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a3c01aea33b0593fd1b84243be7033469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that tuple fields match with given key definition.  <br /></td></tr>
<tr class="separator:a3c01aea33b0593fd1b84243be7033469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b978e168708341cb358a15c5e42430" id="r_a88b978e168708341cb358a15c5e42430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a88b978e168708341cb358a15c5e42430">box_tuple_compare</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_a, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_b, <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:a88b978e168708341cb358a15c5e42430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare tuples using the key definition.  <br /></td></tr>
<tr class="separator:a88b978e168708341cb358a15c5e42430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fec3862fabe2eb885bb71517b99a5f" id="r_ae8fec3862fabe2eb885bb71517b99a5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae8fec3862fabe2eb885bb71517b99a5f">box_tuple_compare_with_key</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_a, const char *key_b, <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:ae8fec3862fabe2eb885bb71517b99a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare tuple with key using the key definition.  <br /></td></tr>
<tr class="separator:ae8fec3862fabe2eb885bb71517b99a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9eb3e3dc2cdff9ae0dd630cb3b6431" id="r_ada9eb3e3dc2cdff9ae0dd630cb3b6431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ada9eb3e3dc2cdff9ae0dd630cb3b6431">box_key_def_merge</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *first, const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *second)</td></tr>
<tr class="memdesc:ada9eb3e3dc2cdff9ae0dd630cb3b6431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new key_def with a set union of key parts from first and second key defs.  <br /></td></tr>
<tr class="separator:ada9eb3e3dc2cdff9ae0dd630cb3b6431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab173f0c441972404f76b0b43d77da401" id="r_ab173f0c441972404f76b0b43d77da401"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab173f0c441972404f76b0b43d77da401">box_key_def_extract_key</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, int multikey_idx, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:ab173f0c441972404f76b0b43d77da401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract key from tuple by given key definition and return buffer allocated on the box region with this key.  <br /></td></tr>
<tr class="separator:ab173f0c441972404f76b0b43d77da401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32868fa25087aa7d7249fd2692a0ac52" id="r_a32868fa25087aa7d7249fd2692a0ac52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a32868fa25087aa7d7249fd2692a0ac52">box_key_def_validate_key</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, const char *key, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:a32868fa25087aa7d7249fd2692a0ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a key against given key definition.  <br /></td></tr>
<tr class="separator:a32868fa25087aa7d7249fd2692a0ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237492509ee5f9e478b72077c4c65833" id="r_a237492509ee5f9e478b72077c4c65833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a237492509ee5f9e478b72077c4c65833">box_key_def_validate_full_key</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, const char *key, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:a237492509ee5f9e478b72077c4c65833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a full key against given key definition.  <br /></td></tr>
<tr class="separator:a237492509ee5f9e478b72077c4c65833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20436be4bf694001c205489cca0d9d45" id="r_a20436be4bf694001c205489cca0d9d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a20436be4bf694001c205489cca0d9d45">box_tuple_format_new</a> (struct key_def **keys, uint16_t key_count)</td></tr>
<tr class="memdesc:a20436be4bf694001c205489cca0d9d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a20436be4bf694001c205489cca0d9d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc998b676589a854eaf71e2e1fd4debc" id="r_acc998b676589a854eaf71e2e1fd4debc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acc998b676589a854eaf71e2e1fd4debc">box_tuple_format_ref</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:acc998b676589a854eaf71e2e1fd4debc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment tuple format ref count.  <br /></td></tr>
<tr class="separator:acc998b676589a854eaf71e2e1fd4debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134eab27cb960c030d553d3881d8d074" id="r_a134eab27cb960c030d553d3881d8d074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a134eab27cb960c030d553d3881d8d074">box_tuple_format_unref</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a134eab27cb960c030d553d3881d8d074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement tuple format ref count.  <br /></td></tr>
<tr class="separator:a134eab27cb960c030d553d3881d8d074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1e8f1e92bb906daefd5666e0ff2f4d" id="r_a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8b1e8f1e92bb906daefd5666e0ff2f4d">box_schema_version</a> (void)</td></tr>
<tr class="memdesc:a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62bc1dd0c418fe0031c32f44e048ce4" id="r_aa62bc1dd0c418fe0031c32f44e048ce4"><td class="memItemLeft" align="right" valign="top"><a id="aa62bc1dd0c418fe0031c32f44e048ce4" name="aa62bc1dd0c418fe0031c32f44e048ce4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>box_is_ro</b> (void)</td></tr>
<tr class="memdesc:aa62bc1dd0c418fe0031c32f44e048ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:aa62bc1dd0c418fe0031c32f44e048ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6a73f9ce8d72029ea976cf2999ba30" id="r_adf6a73f9ce8d72029ea976cf2999ba30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adf6a73f9ce8d72029ea976cf2999ba30">box_wait_ro</a> (bool ro, double timeout)</td></tr>
<tr class="memdesc:adf6a73f9ce8d72029ea976cf2999ba30"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:adf6a73f9ce8d72029ea976cf2999ba30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d96086f343e0739efabf43174a3fa35" id="r_a1d96086f343e0739efabf43174a3fa35"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1d96086f343e0739efabf43174a3fa35">box_ro_reason</a> (void)</td></tr>
<tr class="memdesc:a1d96086f343e0739efabf43174a3fa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a1d96086f343e0739efabf43174a3fa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52506f29df1be0ad66721617c7452f" id="r_aea52506f29df1be0ad66721617c7452f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aea52506f29df1be0ad66721617c7452f">box_status</a> (void)</td></tr>
<tr class="memdesc:aea52506f29df1be0ad66721617c7452f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:aea52506f29df1be0ad66721617c7452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb00cd4eac4d388d58e9e5ef1ea1b3f" id="r_a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7fb00cd4eac4d388d58e9e5ef1ea1b3f">box_return_tuple</a> (<a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *ctx, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tuple from stored C procedure.  <br /></td></tr>
<tr class="separator:a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf7ae13f994a18d2f9dcf7816578ca" id="r_a96bf7ae13f994a18d2f9dcf7816578ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a96bf7ae13f994a18d2f9dcf7816578ca">box_return_mp</a> (<a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *ctx, const char *mp, const char *mp_end)</td></tr>
<tr class="memdesc:a96bf7ae13f994a18d2f9dcf7816578ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return MessagePack from a stored C procedure.  <br /></td></tr>
<tr class="separator:a96bf7ae13f994a18d2f9dcf7816578ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a816d0fc386d810b874b50db1f50293" id="r_a4a816d0fc386d810b874b50db1f50293"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4a816d0fc386d810b874b50db1f50293">box_space_id_by_name</a> (const char *name, uint32_t len)</td></tr>
<tr class="memdesc:a4a816d0fc386d810b874b50db1f50293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find space id by name.  <br /></td></tr>
<tr class="separator:a4a816d0fc386d810b874b50db1f50293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abb8381625fb1364af63d58a0235b3a" id="r_a4abb8381625fb1364af63d58a0235b3a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4abb8381625fb1364af63d58a0235b3a">box_index_id_by_name</a> (uint32_t space_id, const char *name, uint32_t len)</td></tr>
<tr class="memdesc:a4abb8381625fb1364af63d58a0235b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index id by name.  <br /></td></tr>
<tr class="separator:a4abb8381625fb1364af63d58a0235b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08571f03c05abf96fd6e98a590d78822" id="r_a08571f03c05abf96fd6e98a590d78822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08571f03c05abf96fd6e98a590d78822">box_insert</a> (uint32_t space_id, const char *tuple, const char *tuple_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a08571f03c05abf96fd6e98a590d78822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an INSERT request.  <br /></td></tr>
<tr class="separator:a08571f03c05abf96fd6e98a590d78822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b6e9cbf9d4fc05e3964b0949b5bd0" id="r_a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a933b6e9cbf9d4fc05e3964b0949b5bd0">box_replace</a> (uint32_t space_id, const char *tuple, const char *tuple_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an REPLACE request.  <br /></td></tr>
<tr class="separator:a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740bf8f0f5f912dfa78221c9fe5f21bb" id="r_a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a740bf8f0f5f912dfa78221c9fe5f21bb">box_delete</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an DELETE request.  <br /></td></tr>
<tr class="separator:a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9badf4d5cc54e424a157439fcb58b96a" id="r_a9badf4d5cc54e424a157439fcb58b96a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a">box_update</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, const char *ops, const char *ops_end, int index_base, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a9badf4d5cc54e424a157439fcb58b96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an UPDATE request.  <br /></td></tr>
<tr class="separator:a9badf4d5cc54e424a157439fcb58b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268a03389cd856206f0ddfc90f3cbf84" id="r_a268a03389cd856206f0ddfc90f3cbf84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84">box_upsert</a> (uint32_t space_id, uint32_t index_id, const char *tuple, const char *tuple_end, const char *ops, const char *ops_end, int index_base, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a268a03389cd856206f0ddfc90f3cbf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an UPSERT request.  <br /></td></tr>
<tr class="separator:a268a03389cd856206f0ddfc90f3cbf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554b65cb9819d6e231deaaf1e7874d5" id="r_ab554b65cb9819d6e231deaaf1e7874d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab554b65cb9819d6e231deaaf1e7874d5">box_insert_arrow</a> (uint32_t space_id, struct ArrowArray *array, struct ArrowSchema *schema)</td></tr>
<tr class="memdesc:ab554b65cb9819d6e231deaaf1e7874d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a batch insert request.  <br /></td></tr>
<tr class="separator:ab554b65cb9819d6e231deaaf1e7874d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20de21b171ded688588f1063ac04a9d3" id="r_a20de21b171ded688588f1063ac04a9d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a20de21b171ded688588f1063ac04a9d3">box_truncate</a> (uint32_t space_id)</td></tr>
<tr class="memdesc:a20de21b171ded688588f1063ac04a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate space.  <br /></td></tr>
<tr class="separator:a20de21b171ded688588f1063ac04a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5fd9116818749f73bf868d4e780256" id="r_a3e5fd9116818749f73bf868d4e780256"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3e5fd9116818749f73bf868d4e780256">box_sequence_next</a> (uint32_t seq_id, int64_t *result)</td></tr>
<tr class="memdesc:a3e5fd9116818749f73bf868d4e780256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance a sequence.  <br /></td></tr>
<tr class="separator:a3e5fd9116818749f73bf868d4e780256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac5f1357a07acaae764e5d2e2e55fa" id="r_a66ac5f1357a07acaae764e5d2e2e55fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a66ac5f1357a07acaae764e5d2e2e55fa">box_sequence_current</a> (uint32_t seq_id, int64_t *result)</td></tr>
<tr class="memdesc:a66ac5f1357a07acaae764e5d2e2e55fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last value returned by a sequence.  <br /></td></tr>
<tr class="separator:a66ac5f1357a07acaae764e5d2e2e55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2243f60e2773d3522a540103f645110" id="r_ac2243f60e2773d3522a540103f645110"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac2243f60e2773d3522a540103f645110">box_sequence_set</a> (uint32_t seq_id, int64_t value)</td></tr>
<tr class="memdesc:ac2243f60e2773d3522a540103f645110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a sequence value.  <br /></td></tr>
<tr class="separator:ac2243f60e2773d3522a540103f645110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c3210df64b1f6fd89eb2c5e088e94" id="r_a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8f9c3210df64b1f6fd89eb2c5e088e94">box_sequence_reset</a> (uint32_t seq_id)</td></tr>
<tr class="memdesc:a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a sequence.  <br /></td></tr>
<tr class="separator:a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9c91d463ce4aca081e5bd376aac1d9" id="r_a0e9c91d463ce4aca081e5bd376aac1d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0e9c91d463ce4aca081e5bd376aac1d9">box_session_push</a> (const char *data, const char *data_end)</td></tr>
<tr class="memdesc:a0e9c91d463ce4aca081e5bd376aac1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push MessagePack data into a session data channel - socket, console or whatever is behind the session.  <br /></td></tr>
<tr class="separator:a0e9c91d463ce4aca081e5bd376aac1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a6ea7f0c101d1986f27de9f8ec25c8" id="r_a14a6ea7f0c101d1986f27de9f8ec25c8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a14a6ea7f0c101d1986f27de9f8ec25c8">box_session_id</a> (void)</td></tr>
<tr class="separator:a14a6ea7f0c101d1986f27de9f8ec25c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcef363e704e69cb0cc4efb80c6a648e" id="r_abcef363e704e69cb0cc4efb80c6a648e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abcef363e704e69cb0cc4efb80c6a648e">box_iproto_send</a> (uint64_t sid, const char *header, const char *header_end, const char *body, const char *body_end)</td></tr>
<tr class="memdesc:abcef363e704e69cb0cc4efb80c6a648e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet with the given header and body over the IPROTO session's socket.  <br /></td></tr>
<tr class="separator:abcef363e704e69cb0cc4efb80c6a648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6d1752bccac95ed2d154a98c3fe9c7" id="r_a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7">box_iproto_override</a> (uint32_t req_type, <a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a> handler, <a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a> destroy, void *ctx)</td></tr>
<tr class="memdesc:a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an IPROTO request handler with the provided context for the given request type.  <br /></td></tr>
<tr class="separator:a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672bcf1df35af10f617ccdcc71f760bd" id="r_a672bcf1df35af10f617ccdcc71f760bd"><td class="memItemLeft" align="right" valign="top"><a id="a672bcf1df35af10f617ccdcc71f760bd" name="a672bcf1df35af10f617ccdcc71f760bd"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>box_info_lsn</b> (void)</td></tr>
<tr class="memdesc:a672bcf1df35af10f617ccdcc71f760bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get self LSN component of box vclock, -1 if no one or bootstrap haven't succeeded. <br /></td></tr>
<tr class="separator:a672bcf1df35af10f617ccdcc71f760bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c3dfb46ae57e3f253db3be6b066636" id="r_a38c3dfb46ae57e3f253db3be6b066636"><td class="memItemLeft" align="right" valign="top"><a id="a38c3dfb46ae57e3f253db3be6b066636" name="a38c3dfb46ae57e3f253db3be6b066636"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>box_slab_info</b> (enum <a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96f">box_slab_info_type</a> type)</td></tr>
<tr class="memdesc:a38c3dfb46ae57e3f253db3be6b066636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memtx status information for box.slab.info. <br /></td></tr>
<tr class="separator:a38c3dfb46ae57e3f253db3be6b066636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af339d131bfa577606d631f5e4bd82752" id="r_af339d131bfa577606d631f5e4bd82752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af339d131bfa577606d631f5e4bd82752">box_index_iterator</a> (uint32_t space_id, uint32_t index_id, int type, const char *key, const char *key_end)</td></tr>
<tr class="memdesc:af339d131bfa577606d631f5e4bd82752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize iterator for space_id, index_id.  <br /></td></tr>
<tr class="separator:af339d131bfa577606d631f5e4bd82752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4361728e6abe6243e7f02b098e7b347" id="r_ae4361728e6abe6243e7f02b098e7b347"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347">box_iterator_next</a> (<a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *iterator, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:ae4361728e6abe6243e7f02b098e7b347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next item from the <em>iterator</em>.  <br /></td></tr>
<tr class="separator:ae4361728e6abe6243e7f02b098e7b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7fe762b15009de313fdf915378429c" id="r_a6f7fe762b15009de313fdf915378429c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a> (<a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *iterator)</td></tr>
<tr class="memdesc:a6f7fe762b15009de313fdf915378429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and deallocate iterator.  <br /></td></tr>
<tr class="separator:a6f7fe762b15009de313fdf915378429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698d8991fa015a4b490f078b29e8d929" id="r_a698d8991fa015a4b490f078b29e8d929"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a698d8991fa015a4b490f078b29e8d929">box_index_len</a> (uint32_t space_id, uint32_t index_id)</td></tr>
<tr class="memdesc:a698d8991fa015a4b490f078b29e8d929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of element in the index.  <br /></td></tr>
<tr class="separator:a698d8991fa015a4b490f078b29e8d929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeda3d99d32c382bc5ac2bc8f0a09f48" id="r_aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaeda3d99d32c382bc5ac2bc8f0a09f48">box_index_bsize</a> (uint32_t space_id, uint32_t index_id)</td></tr>
<tr class="memdesc:aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes used in memory by the index.  <br /></td></tr>
<tr class="separator:aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10baf3a63a95a208b5a5ee96afa66e4b" id="r_a10baf3a63a95a208b5a5ee96afa66e4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a10baf3a63a95a208b5a5ee96afa66e4b">box_index_quantile</a> (uint32_t space_id, uint32_t index_id, double level, const char *begin_key, const char *begin_key_end, const char *end_key, const char *end_key_end, const char **quantile_key, const char **quantile_key_end)</td></tr>
<tr class="memdesc:a10baf3a63a95a208b5a5ee96afa66e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quantile point in an indexed range.  <br /></td></tr>
<tr class="separator:a10baf3a63a95a208b5a5ee96afa66e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56e2bf2a5720259ea3997149ae53ca9" id="r_aa56e2bf2a5720259ea3997149ae53ca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa56e2bf2a5720259ea3997149ae53ca9">box_index_random</a> (uint32_t space_id, uint32_t index_id, uint32_t rnd, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:aa56e2bf2a5720259ea3997149ae53ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random tuple from the index (useful for statistical analysis).  <br /></td></tr>
<tr class="separator:aa56e2bf2a5720259ea3997149ae53ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9cedd4198d62ddfe6c77ef2bf89f56" id="r_a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5c9cedd4198d62ddfe6c77ef2bf89f56">box_index_get</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a tuple from index by the key.  <br /></td></tr>
<tr class="separator:a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd278987613571a9d6475de6103a4f" id="r_a4fbd278987613571a9d6475de6103a4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4fbd278987613571a9d6475de6103a4f">box_index_min</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a4fbd278987613571a9d6475de6103a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a first (minimal) tuple matched the provided key.  <br /></td></tr>
<tr class="separator:a4fbd278987613571a9d6475de6103a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e5f79addcfd9c7312fe66e7be7514" id="r_a044e5f79addcfd9c7312fe66e7be7514"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a044e5f79addcfd9c7312fe66e7be7514">box_index_max</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a044e5f79addcfd9c7312fe66e7be7514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a last (maximal) tuple matched the provided key.  <br /></td></tr>
<tr class="separator:a044e5f79addcfd9c7312fe66e7be7514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f06a7df9e461267455477bd84ce02ed" id="r_a3f06a7df9e461267455477bd84ce02ed"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3f06a7df9e461267455477bd84ce02ed">box_index_count</a> (uint32_t space_id, uint32_t index_id, int type, const char *key, const char *key_end)</td></tr>
<tr class="memdesc:a3f06a7df9e461267455477bd84ce02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of tuple matched the provided key.  <br /></td></tr>
<tr class="separator:a3f06a7df9e461267455477bd84ce02ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8452d35ca52bc3147b129f8d46c35ef1" id="r_a8452d35ca52bc3147b129f8d46c35ef1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8452d35ca52bc3147b129f8d46c35ef1">box_tuple_extract_key</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, uint32_t space_id, uint32_t index_id, uint32_t *key_size)</td></tr>
<tr class="memdesc:a8452d35ca52bc3147b129f8d46c35ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract key from tuple according to key definition of given index.  <br /></td></tr>
<tr class="separator:a8452d35ca52bc3147b129f8d46c35ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd4a9f506e56bab2a03475d7b95589" id="r_ab3cd4a9f506e56bab2a03475d7b95589"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab3cd4a9f506e56bab2a03475d7b95589">box_error_type</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:ab3cd4a9f506e56bab2a03475d7b95589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error type, e.g.  <br /></td></tr>
<tr class="separator:ab3cd4a9f506e56bab2a03475d7b95589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a57f7e18f0b9c3880d4e516589e73" id="r_a800a57f7e18f0b9c3880d4e516589e73"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a800a57f7e18f0b9c3880d4e516589e73">box_error_code</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:a800a57f7e18f0b9c3880d4e516589e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return IPROTO error code.  <br /></td></tr>
<tr class="separator:a800a57f7e18f0b9c3880d4e516589e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94399db28784bf3419da94fa563463" id="r_a4f94399db28784bf3419da94fa563463"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4f94399db28784bf3419da94fa563463">box_error_message</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:a4f94399db28784bf3419da94fa563463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error message.  <br /></td></tr>
<tr class="separator:a4f94399db28784bf3419da94fa563463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b4ebee3bb9402fb8621b4e96b93b5d" id="r_a29b4ebee3bb9402fb8621b4e96b93b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d">box_error_last</a> (void)</td></tr>
<tr class="memdesc:a29b4ebee3bb9402fb8621b4e96b93b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about the last API call error.  <br /></td></tr>
<tr class="separator:a29b4ebee3bb9402fb8621b4e96b93b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2143635d7ff4aeb2ced40ffa033527" id="r_a1c2143635d7ff4aeb2ced40ffa033527"><td class="memItemLeft" align="right" valign="top"><a id="a1c2143635d7ff4aeb2ced40ffa033527" name="a1c2143635d7ff4aeb2ced40ffa033527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>box_error_clear</b> (void)</td></tr>
<tr class="memdesc:a1c2143635d7ff4aeb2ced40ffa033527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the last error. <br /></td></tr>
<tr class="separator:a1c2143635d7ff4aeb2ced40ffa033527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e6803bc4309c3f59b93e2709cb418b" id="r_aa6e6803bc4309c3f59b93e2709cb418b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b">box_error_set</a> (const char *file, unsigned line, uint32_t code, const char *format,...)</td></tr>
<tr class="memdesc:aa6e6803bc4309c3f59b93e2709cb418b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the last error.  <br /></td></tr>
<tr class="separator:aa6e6803bc4309c3f59b93e2709cb418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4703451fd9a5ddf2b0a5e5c2f828aa4a" id="r_a4703451fd9a5ddf2b0a5e5c2f828aa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4703451fd9a5ddf2b0a5e5c2f828aa4a">luaT_checktuple</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a4703451fd9a5ddf2b0a5e5c2f828aa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a4703451fd9a5ddf2b0a5e5c2f828aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddb8bf7e1f41149fe67352de0f276d4" id="r_a0ddb8bf7e1f41149fe67352de0f276d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0ddb8bf7e1f41149fe67352de0f276d4">luaT_pushtuple</a> (struct lua_State *L, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a0ddb8bf7e1f41149fe67352de0f276d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a tuple onto the stack.  <br /></td></tr>
<tr class="separator:a0ddb8bf7e1f41149fe67352de0f276d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8ffde3785c473470bf52bba05787c7" id="r_a3c8ffde3785c473470bf52bba05787c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3c8ffde3785c473470bf52bba05787c7">luaT_istuple</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a3c8ffde3785c473470bf52bba05787c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether argument idx is a tuple.  <br /></td></tr>
<tr class="separator:a3c8ffde3785c473470bf52bba05787c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a399adb96af280b9faedf642f5549cf" id="r_a1a399adb96af280b9faedf642f5549cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1a399adb96af280b9faedf642f5549cf">luaT_tuple_encode</a> (struct lua_State *L, int idx, size_t *tuple_len_ptr)</td></tr>
<tr class="memdesc:a1a399adb96af280b9faedf642f5549cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a table or a tuple on the Lua stack as an MsgPack array.  <br /></td></tr>
<tr class="separator:a1a399adb96af280b9faedf642f5549cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9fba67e9a46d465bcefba3fd06f305" id="r_a8f9fba67e9a46d465bcefba3fd06f305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8f9fba67e9a46d465bcefba3fd06f305">luaT_tuple_new</a> (struct lua_State *L, int idx, <a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a8f9fba67e9a46d465bcefba3fd06f305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new tuple with specific format from a Lua table or a tuple.  <br /></td></tr>
<tr class="separator:a8f9fba67e9a46d465bcefba3fd06f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b81bda5be3fd39b8d076cd048e83b67" id="r_a6b81bda5be3fd39b8d076cd048e83b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6b81bda5be3fd39b8d076cd048e83b67">box_latch_new</a> (void)</td></tr>
<tr class="memdesc:a6b81bda5be3fd39b8d076cd048e83b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the new latch.  <br /></td></tr>
<tr class="separator:a6b81bda5be3fd39b8d076cd048e83b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a897e7386e946cd5ffd2ea1cb47a52" id="r_a83a897e7386e946cd5ffd2ea1cb47a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a83a897e7386e946cd5ffd2ea1cb47a52">box_latch_delete</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a83a897e7386e946cd5ffd2ea1cb47a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free the latch.  <br /></td></tr>
<tr class="separator:a83a897e7386e946cd5ffd2ea1cb47a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef397199dd9a19cb7b9362233a1d4a98" id="r_aef397199dd9a19cb7b9362233a1d4a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aef397199dd9a19cb7b9362233a1d4a98">box_latch_lock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:aef397199dd9a19cb7b9362233a1d4a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a latch.  <br /></td></tr>
<tr class="separator:aef397199dd9a19cb7b9362233a1d4a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294e53c819e91f172428d580a29f434f" id="r_a294e53c819e91f172428d580a29f434f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a294e53c819e91f172428d580a29f434f">box_latch_trylock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a294e53c819e91f172428d580a29f434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a latch.  <br /></td></tr>
<tr class="separator:a294e53c819e91f172428d580a29f434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dea9d7a0347d38956ed59f739c68ca" id="r_a11dea9d7a0347d38956ed59f739c68ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a11dea9d7a0347d38956ed59f739c68ca">box_latch_unlock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a11dea9d7a0347d38956ed59f739c68ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a latch.  <br /></td></tr>
<tr class="separator:a11dea9d7a0347d38956ed59f739c68ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b915cd0f2fbf8da0031594334d1161" id="r_a82b915cd0f2fbf8da0031594334d1161"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a82b915cd0f2fbf8da0031594334d1161">clock_realtime</a> (void)</td></tr>
<tr class="memdesc:a82b915cd0f2fbf8da0031594334d1161"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a82b915cd0f2fbf8da0031594334d1161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35900530fb24b7e882c37016b01603aa" id="r_a35900530fb24b7e882c37016b01603aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a35900530fb24b7e882c37016b01603aa">clock_monotonic</a> (void)</td></tr>
<tr class="memdesc:a35900530fb24b7e882c37016b01603aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonsettable system-wide clock that represents monotonic time.  <br /></td></tr>
<tr class="separator:a35900530fb24b7e882c37016b01603aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf77597c056216e310c34951bf21b9" id="r_a7ecf77597c056216e310c34951bf21b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7ecf77597c056216e310c34951bf21b9">clock_process</a> (void)</td></tr>
<tr class="memdesc:a7ecf77597c056216e310c34951bf21b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock that measures CPU time consumed by this process (by all threads in the process).  <br /></td></tr>
<tr class="separator:a7ecf77597c056216e310c34951bf21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c5ad4ed25168dd171bd2f9d112d0d" id="r_aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aac6c5ad4ed25168dd171bd2f9d112d0d">clock_thread</a> (void)</td></tr>
<tr class="memdesc:aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock that measures CPU time consumed by this thread.  <br /></td></tr>
<tr class="separator:aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbe6ebb913f8356f36c68e724473b45" id="r_a3bbe6ebb913f8356f36c68e724473b45"><td class="memItemLeft" align="right" valign="top"><a id="a3bbe6ebb913f8356f36c68e724473b45" name="a3bbe6ebb913f8356f36c68e724473b45"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>clock_realtime64</b> (void)</td></tr>
<tr class="memdesc:a3bbe6ebb913f8356f36c68e724473b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a82b915cd0f2fbf8da0031594334d1161" title="public">clock_realtime()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a3bbe6ebb913f8356f36c68e724473b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29caad1a3f9995d2a2844a1d4672e3cd" id="r_a29caad1a3f9995d2a2844a1d4672e3cd"><td class="memItemLeft" align="right" valign="top"><a id="a29caad1a3f9995d2a2844a1d4672e3cd" name="a29caad1a3f9995d2a2844a1d4672e3cd"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>clock_monotonic64</b> (void)</td></tr>
<tr class="memdesc:a29caad1a3f9995d2a2844a1d4672e3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a35900530fb24b7e882c37016b01603aa" title="A nonsettable system-wide clock that represents monotonic time.">clock_monotonic()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a29caad1a3f9995d2a2844a1d4672e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162cf2a3d31840c4a904d5c543980104" id="r_a162cf2a3d31840c4a904d5c543980104"><td class="memItemLeft" align="right" valign="top"><a id="a162cf2a3d31840c4a904d5c543980104" name="a162cf2a3d31840c4a904d5c543980104"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>clock_process64</b> (void)</td></tr>
<tr class="memdesc:a162cf2a3d31840c4a904d5c543980104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a7ecf77597c056216e310c34951bf21b9" title="A clock that measures CPU time consumed by this process (by all threads in the process).">clock_process()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a162cf2a3d31840c4a904d5c543980104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4e0ab14aaaf4b7d101e28c55c18cf" id="r_afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="memItemLeft" align="right" valign="top"><a id="afac4e0ab14aaaf4b7d101e28c55c18cf" name="afac4e0ab14aaaf4b7d101e28c55c18cf"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>clock_thread64</b> (void)</td></tr>
<tr class="memdesc:afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#aac6c5ad4ed25168dd171bd2f9d112d0d" title="A clock that measures CPU time consumed by this thread.">clock_thread()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1815f3add53077a6f1383db1d9347c99" id="r_a1815f3add53077a6f1383db1d9347c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1815f3add53077a6f1383db1d9347c99">box_decimal_precision</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a1815f3add53077a6f1383db1d9347c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimal precision.  <br /></td></tr>
<tr class="separator:a1815f3add53077a6f1383db1d9347c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499bd306b660788339570ea8b9f4733" id="r_a3499bd306b660788339570ea8b9f4733"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3499bd306b660788339570ea8b9f4733">box_decimal_scale</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a3499bd306b660788339570ea8b9f4733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimal scale.  <br /></td></tr>
<tr class="separator:a3499bd306b660788339570ea8b9f4733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adad9501fc38ba6e6a54f58d6152840" id="r_a1adad9501fc38ba6e6a54f58d6152840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1adad9501fc38ba6e6a54f58d6152840">box_decimal_is_int</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a1adad9501fc38ba6e6a54f58d6152840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the fractional part of a decimal number is 0.  <br /></td></tr>
<tr class="separator:a1adad9501fc38ba6e6a54f58d6152840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74749ee03d5f2860c5813b0bf36cabe4" id="r_a74749ee03d5f2860c5813b0bf36cabe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a74749ee03d5f2860c5813b0bf36cabe4">box_decimal_is_neg</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a74749ee03d5f2860c5813b0bf36cabe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a decimal number is negative.  <br /></td></tr>
<tr class="separator:a74749ee03d5f2860c5813b0bf36cabe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11dd28c7727e83e8c3729a7f46c97d2" id="r_ac11dd28c7727e83e8c3729a7f46c97d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac11dd28c7727e83e8c3729a7f46c97d2">box_decimal_zero</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:ac11dd28c7727e83e8c3729a7f46c97d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a zero decimal number.  <br /></td></tr>
<tr class="separator:ac11dd28c7727e83e8c3729a7f46c97d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb48bbc701ce3221e4c5c4fd8c1055b" id="r_a3eb48bbc701ce3221e4c5c4fd8c1055b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3eb48bbc701ce3221e4c5c4fd8c1055b">box_decimal_from_string</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char *str)</td></tr>
<tr class="memdesc:a3eb48bbc701ce3221e4c5c4fd8c1055b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a value from a string.  <br /></td></tr>
<tr class="separator:a3eb48bbc701ce3221e4c5c4fd8c1055b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac068234331e788d607868fd95cefa88f" id="r_ac068234331e788d607868fd95cefa88f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac068234331e788d607868fd95cefa88f">box_decimal_from_double</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, double d)</td></tr>
<tr class="memdesc:ac068234331e788d607868fd95cefa88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from double.  <br /></td></tr>
<tr class="separator:ac068234331e788d607868fd95cefa88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d0e0cb965eeeb0a00f867b4ee3431f" id="r_ab1d0e0cb965eeeb0a00f867b4ee3431f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab1d0e0cb965eeeb0a00f867b4ee3431f">box_decimal_from_int64</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int64_t num)</td></tr>
<tr class="memdesc:ab1d0e0cb965eeeb0a00f867b4ee3431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a signed integer value.  <br /></td></tr>
<tr class="separator:ab1d0e0cb965eeeb0a00f867b4ee3431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5a5a5609e5ee0cdaf33cef61a90077" id="r_a7e5a5a5609e5ee0cdaf33cef61a90077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7e5a5a5609e5ee0cdaf33cef61a90077">box_decimal_from_uint64</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, uint64_t num)</td></tr>
<tr class="memdesc:a7e5a5a5609e5ee0cdaf33cef61a90077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a unsigned integer value.  <br /></td></tr>
<tr class="separator:a7e5a5a5609e5ee0cdaf33cef61a90077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f32322d571c6f6381bc72a88bf678" id="r_a227f32322d571c6f6381bc72a88bf678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a227f32322d571c6f6381bc72a88bf678">box_decimal_scale_from_int32</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int32_t value, int scale)</td></tr>
<tr class="memdesc:a227f32322d571c6f6381bc72a88bf678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from given integer value and scale.  <br /></td></tr>
<tr class="separator:a227f32322d571c6f6381bc72a88bf678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb0a5484cbe49e65c61a4cdba51a03d" id="r_a4eb0a5484cbe49e65c61a4cdba51a03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4eb0a5484cbe49e65c61a4cdba51a03d">box_decimal_scale_from_int64</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int64_t value, int scale)</td></tr>
<tr class="memdesc:a4eb0a5484cbe49e65c61a4cdba51a03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from given integer value and scale.  <br /></td></tr>
<tr class="separator:a4eb0a5484cbe49e65c61a4cdba51a03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c90a1dbf9e913e8ebf9f95330e570e8" id="r_a6c90a1dbf9e913e8ebf9f95330e570e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6c90a1dbf9e913e8ebf9f95330e570e8">box_decimal_scale_from_int128</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const uint64_t *value, int scale)</td></tr>
<tr class="memdesc:a6c90a1dbf9e913e8ebf9f95330e570e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from given integer value and scale.  <br /></td></tr>
<tr class="separator:a6c90a1dbf9e913e8ebf9f95330e570e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1d16f165c38b5d72fb9ef18ab5ac3e" id="r_a8c1d16f165c38b5d72fb9ef18ab5ac3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8c1d16f165c38b5d72fb9ef18ab5ac3e">box_decimal_scale_from_int256</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const uint64_t *value, int scale)</td></tr>
<tr class="memdesc:a8c1d16f165c38b5d72fb9ef18ab5ac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from given integer value and scale.  <br /></td></tr>
<tr class="separator:a8c1d16f165c38b5d72fb9ef18ab5ac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308e450dedd64c9ed97a0fa841de8bc" id="r_ac308e450dedd64c9ed97a0fa841de8bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac308e450dedd64c9ed97a0fa841de8bc">box_decimal_copy</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dest, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *src)</td></tr>
<tr class="memdesc:ac308e450dedd64c9ed97a0fa841de8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy decimal value from one storage to another.  <br /></td></tr>
<tr class="separator:ac308e450dedd64c9ed97a0fa841de8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a20acf8704e0a8de6b2c6e70cabda94" id="r_a7a20acf8704e0a8de6b2c6e70cabda94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7a20acf8704e0a8de6b2c6e70cabda94">box_decimal_to_string</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, char *buf)</td></tr>
<tr class="memdesc:a7a20acf8704e0a8de6b2c6e70cabda94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the decimal as a string into the passed buffer.  <br /></td></tr>
<tr class="separator:a7a20acf8704e0a8de6b2c6e70cabda94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef891f48c3de2b70a23565833977e51b" id="r_aef891f48c3de2b70a23565833977e51b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aef891f48c3de2b70a23565833977e51b">box_decimal_to_int64</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int64_t *num)</td></tr>
<tr class="memdesc:aef891f48c3de2b70a23565833977e51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given decimal to int64_t.  <br /></td></tr>
<tr class="separator:aef891f48c3de2b70a23565833977e51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7984e1af9644427d4431d483313cda1" id="r_aa7984e1af9644427d4431d483313cda1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa7984e1af9644427d4431d483313cda1">box_decimal_to_uint64</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, uint64_t *num)</td></tr>
<tr class="memdesc:aa7984e1af9644427d4431d483313cda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given decimal to uint64_t.  <br /></td></tr>
<tr class="separator:aa7984e1af9644427d4431d483313cda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed176d1daf608d41d24239bc9d73fdab" id="r_aed176d1daf608d41d24239bc9d73fdab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aed176d1daf608d41d24239bc9d73fdab">box_decimal_scale_to_int32</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale, int32_t *value)</td></tr>
<tr class="memdesc:aed176d1daf608d41d24239bc9d73fdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert decimal to integer given scale is <em>scale</em>.  <br /></td></tr>
<tr class="separator:aed176d1daf608d41d24239bc9d73fdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b07d7e0fc3db346f1414384e6cc93e" id="r_ad7b07d7e0fc3db346f1414384e6cc93e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad7b07d7e0fc3db346f1414384e6cc93e">box_decimal_scale_to_int64</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale, int64_t *value)</td></tr>
<tr class="memdesc:ad7b07d7e0fc3db346f1414384e6cc93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert decimal to integer given scale is <em>scale</em>.  <br /></td></tr>
<tr class="separator:ad7b07d7e0fc3db346f1414384e6cc93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043c0cbd03ee3567a306458cfb66b440" id="r_a043c0cbd03ee3567a306458cfb66b440"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a043c0cbd03ee3567a306458cfb66b440">box_decimal_scale_to_int128</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale, uint64_t *value)</td></tr>
<tr class="memdesc:a043c0cbd03ee3567a306458cfb66b440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert decimal to integer given scale is <em>scale</em>.  <br /></td></tr>
<tr class="separator:a043c0cbd03ee3567a306458cfb66b440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d85d17e483ac8d9bc8be0c304e1bb24" id="r_a1d85d17e483ac8d9bc8be0c304e1bb24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1d85d17e483ac8d9bc8be0c304e1bb24">box_decimal_scale_to_int256</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale, uint64_t *value)</td></tr>
<tr class="memdesc:a1d85d17e483ac8d9bc8be0c304e1bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert decimal to integer given scale is <em>scale</em>.  <br /></td></tr>
<tr class="separator:a1d85d17e483ac8d9bc8be0c304e1bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84169b77917c2d12a4ef8027e4beacef" id="r_a84169b77917c2d12a4ef8027e4beacef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a84169b77917c2d12a4ef8027e4beacef">box_decimal_round</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:a84169b77917c2d12a4ef8027e4beacef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest decimal at given <em>scale</em>, half goes away from zero.  <br /></td></tr>
<tr class="separator:a84169b77917c2d12a4ef8027e4beacef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37aced6f227b3dbd48169ce4ba092504" id="r_a37aced6f227b3dbd48169ce4ba092504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a37aced6f227b3dbd48169ce4ba092504">box_decimal_floor</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:a37aced6f227b3dbd48169ce4ba092504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a floor function to a decimal, i.e.  <br /></td></tr>
<tr class="separator:a37aced6f227b3dbd48169ce4ba092504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe405bddd53bc745cd54851b071e49c5" id="r_abe405bddd53bc745cd54851b071e49c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abe405bddd53bc745cd54851b071e49c5">box_decimal_trim</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:abe405bddd53bc745cd54851b071e49c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing zeros from the fractional part of a number.  <br /></td></tr>
<tr class="separator:abe405bddd53bc745cd54851b071e49c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ea8ad6f58a43e9dca729a410b5e286" id="r_a96ea8ad6f58a43e9dca729a410b5e286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a96ea8ad6f58a43e9dca729a410b5e286">box_decimal_rescale</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:a96ea8ad6f58a43e9dca729a410b5e286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scale of <em>dec</em> to <em>scale</em>.  <br /></td></tr>
<tr class="separator:a96ea8ad6f58a43e9dca729a410b5e286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0376671f42b04fdafb2706527762b4" id="r_aaf0376671f42b04fdafb2706527762b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaf0376671f42b04fdafb2706527762b4">box_decimal_compare</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aaf0376671f42b04fdafb2706527762b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two decimal values.  <br /></td></tr>
<tr class="separator:aaf0376671f42b04fdafb2706527762b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff11b49687b7a3ad15a6246368a74f9" id="r_a9ff11b49687b7a3ad15a6246368a74f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9ff11b49687b7a3ad15a6246368a74f9">box_decimal_abs</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a9ff11b49687b7a3ad15a6246368a74f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute value of a decimal.  <br /></td></tr>
<tr class="separator:a9ff11b49687b7a3ad15a6246368a74f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc8a9f6fbed4a19d9b7a74ebd80107" id="r_acefc8a9f6fbed4a19d9b7a74ebd80107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acefc8a9f6fbed4a19d9b7a74ebd80107">box_decimal_minus</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:acefc8a9f6fbed4a19d9b7a74ebd80107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform unary minus operation.  <br /></td></tr>
<tr class="separator:acefc8a9f6fbed4a19d9b7a74ebd80107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68205951a728801a27c7a1e059cb33b" id="r_ac68205951a728801a27c7a1e059cb33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac68205951a728801a27c7a1e059cb33b">box_decimal_add</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:ac68205951a728801a27c7a1e059cb33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a sum of two decimal numbers.  <br /></td></tr>
<tr class="separator:ac68205951a728801a27c7a1e059cb33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4473537df85f1f2168b9cc749f86b0" id="r_aaa4473537df85f1f2168b9cc749f86b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaa4473537df85f1f2168b9cc749f86b0">box_decimal_sub</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aaa4473537df85f1f2168b9cc749f86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one decimal number from another.  <br /></td></tr>
<tr class="separator:aaa4473537df85f1f2168b9cc749f86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3673e0c446bbd7917a06c842b4bcd99" id="r_aa3673e0c446bbd7917a06c842b4bcd99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa3673e0c446bbd7917a06c842b4bcd99">box_decimal_mul</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aa3673e0c446bbd7917a06c842b4bcd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two decimal numbers.  <br /></td></tr>
<tr class="separator:aa3673e0c446bbd7917a06c842b4bcd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38241d721907b901ff2f15875ad8ebe" id="r_ac38241d721907b901ff2f15875ad8ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac38241d721907b901ff2f15875ad8ebe">box_decimal_div</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:ac38241d721907b901ff2f15875ad8ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide one decimal number on another.  <br /></td></tr>
<tr class="separator:ac38241d721907b901ff2f15875ad8ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701a02f61292b3da8a4d10b68c85d7ff" id="r_a701a02f61292b3da8a4d10b68c85d7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a701a02f61292b3da8a4d10b68c85d7ff">box_decimal_remainder</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:a701a02f61292b3da8a4d10b68c85d7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remainder of diviging two decimals.  <br /></td></tr>
<tr class="separator:a701a02f61292b3da8a4d10b68c85d7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da42507f4c84c89b0b1784f6ebb14bd" id="r_a5da42507f4c84c89b0b1784f6ebb14bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5da42507f4c84c89b0b1784f6ebb14bd">box_decimal_log10</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a5da42507f4c84c89b0b1784f6ebb14bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a common logarithm (base 10).  <br /></td></tr>
<tr class="separator:a5da42507f4c84c89b0b1784f6ebb14bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ce757059e40b95dfca8e29077e638b" id="r_a47ce757059e40b95dfca8e29077e638b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a47ce757059e40b95dfca8e29077e638b">box_decimal_ln</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a47ce757059e40b95dfca8e29077e638b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a natural logarithm (base e).  <br /></td></tr>
<tr class="separator:a47ce757059e40b95dfca8e29077e638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d986753e1e1eb2d0a0e94f76044b5" id="r_aac5d986753e1e1eb2d0a0e94f76044b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aac5d986753e1e1eb2d0a0e94f76044b5">box_decimal_pow</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aac5d986753e1e1eb2d0a0e94f76044b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <em>lhs</em> raised to the power of <em>rhs</em>.  <br /></td></tr>
<tr class="separator:aac5d986753e1e1eb2d0a0e94f76044b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179a62fcfca4882a5612d0c9847d68d" id="r_a7179a62fcfca4882a5612d0c9847d68d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7179a62fcfca4882a5612d0c9847d68d">box_decimal_exp</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a7179a62fcfca4882a5612d0c9847d68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate exp(<em>dec</em>), i.e.  <br /></td></tr>
<tr class="separator:a7179a62fcfca4882a5612d0c9847d68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85c95c41f61184a803dd714de874e5" id="r_a2a85c95c41f61184a803dd714de874e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2a85c95c41f61184a803dd714de874e5">box_decimal_sqrt</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a2a85c95c41f61184a803dd714de874e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a square root.  <br /></td></tr>
<tr class="separator:a2a85c95c41f61184a803dd714de874e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847059b54874f3e4bde5550ec228fd3" id="r_ad847059b54874f3e4bde5550ec228fd3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad847059b54874f3e4bde5550ec228fd3">box_decimal_mp_sizeof</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:ad847059b54874f3e4bde5550ec228fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate exact buffer size needed to store msgpack representation of a decimal.  <br /></td></tr>
<tr class="separator:ad847059b54874f3e4bde5550ec228fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf8eda7fa944c6fc8949e19af5dceb" id="r_afdaf8eda7fa944c6fc8949e19af5dceb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afdaf8eda7fa944c6fc8949e19af5dceb">box_decimal_mp_encode</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, char *data)</td></tr>
<tr class="memdesc:afdaf8eda7fa944c6fc8949e19af5dceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a decimal as msgpack.  <br /></td></tr>
<tr class="separator:afdaf8eda7fa944c6fc8949e19af5dceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de043345d920023948829285063ce98" id="r_a7de043345d920023948829285063ce98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7de043345d920023948829285063ce98">box_decimal_mp_decode</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char **data)</td></tr>
<tr class="memdesc:a7de043345d920023948829285063ce98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a decimal from msgpack <em>data</em>.  <br /></td></tr>
<tr class="separator:a7de043345d920023948829285063ce98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c08c83a937326e63be00ef63c77c12f" id="r_a0c08c83a937326e63be00ef63c77c12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0c08c83a937326e63be00ef63c77c12f">box_decimal_mp_decode_data</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char **data, uint32_t size)</td></tr>
<tr class="memdesc:a0c08c83a937326e63be00ef63c77c12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a decimal from msgpack <em>data</em> without the msgpack extension header.  <br /></td></tr>
<tr class="separator:a0c08c83a937326e63be00ef63c77c12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ce5d3090eafea3a46709aaa68c7a5b" id="r_a99ce5d3090eafea3a46709aaa68c7a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a99ce5d3090eafea3a46709aaa68c7a5b">luaT_newdecimal</a> (struct lua_State *L)</td></tr>
<tr class="memdesc:a99ce5d3090eafea3a46709aaa68c7a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <br /></td></tr>
<tr class="separator:a99ce5d3090eafea3a46709aaa68c7a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954243c7f6641e47706cae54fc995d5" id="r_a5954243c7f6641e47706cae54fc995d5"><td class="memItemLeft" align="right" valign="top"><a id="a5954243c7f6641e47706cae54fc995d5" name="a5954243c7f6641e47706cae54fc995d5"></a>
<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>luaT_pushdecimal</b> (struct lua_State *L, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a5954243c7f6641e47706cae54fc995d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new decimal on the Lua stack with copy of given decimal and return a pointer to it. <br /></td></tr>
<tr class="separator:a5954243c7f6641e47706cae54fc995d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b19d5a4c0f109f4a8db17bb886d863" id="r_a15b19d5a4c0f109f4a8db17bb886d863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a15b19d5a4c0f109f4a8db17bb886d863">luaT_isdecimal</a> (struct lua_State *L, int index)</td></tr>
<tr class="memdesc:a15b19d5a4c0f109f4a8db17bb886d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a value on the Lua stack is a decimal.  <br /></td></tr>
<tr class="separator:a15b19d5a4c0f109f4a8db17bb886d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab5a71c2541c377b3d5b34fdb35964c2e" id="r_ab5a71c2541c377b3d5b34fdb35964c2e"><td class="memItemLeft" align="right" valign="top"><a id="ab5a71c2541c377b3d5b34fdb35964c2e" name="ab5a71c2541c377b3d5b34fdb35964c2e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>log_level</b></td></tr>
<tr class="memdesc:ab5a71c2541c377b3d5b34fdb35964c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging level. <br /></td></tr>
<tr class="separator:ab5a71c2541c377b3d5b34fdb35964c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe1e6dda2fc92e77e64561cd3d4380f" id="r_abfe1e6dda2fc92e77e64561cd3d4380f"><td class="memItemLeft" align="right" valign="top"><a id="abfe1e6dda2fc92e77e64561cd3d4380f" name="abfe1e6dda2fc92e77e64561cd3d4380f"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>log_write_flightrec</b> )(int level, const char *filename, int line, const char *error, const char *format, va_list ap)</td></tr>
<tr class="memdesc:abfe1e6dda2fc92e77e64561cd3d4380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called for every log which log level is not less than log_level_flightrec. <br /></td></tr>
<tr class="separator:abfe1e6dda2fc92e77e64561cd3d4380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af989845e24678c452b9222afdac95e7f" name="af989845e24678c452b9222afdac95e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af989845e24678c452b9222afdac95e7f">&#9670;&#160;</a></span>__has_feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __has_feature</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Feature test macros for -std=c11 / -std=c++11</p>
<p>Sic: clang aims to be gcc-compatible and thus defines <b>GNUC</b> </p>

</div>
</div>
<a id="a131f3cf1114cea323f428ee90a531c62" name="a131f3cf1114cea323f428ee90a531c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131f3cf1114cea323f428ee90a531c62">&#9670;&#160;</a></span>alignas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alignas</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11/C++11 keyword. </p>
<p>Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared.</p>
<p>Sic: <a class="el" href="module_8h.html#a131f3cf1114cea323f428ee90a531c62" title="C11/C++11 keyword.">alignas()</a> doesn't work on anonymous structs on gcc &lt; 4.9</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>obuf { <span class="keywordtype">int</span> a; <span class="keywordtype">int</span> b; <span class="keyword">alignas</span>(16) <span class="keywordtype">int</span> c; };</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ed9482331696beaadb8ab2e6b4dfead" name="a3ed9482331696beaadb8ab2e6b4dfead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed9482331696beaadb8ab2e6b4dfead">&#9670;&#160;</a></span>alignof</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alignof</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_T</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(struct { char c; _T member; }, member)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11/C++11 operator. </p>
<p>Returns the alignment, in bytes, required for any instance of the type indicated by type-id, which is either complete type, an array type, or a reference type. </p>

</div>
</div>
<a id="aa1dec568e79152c892dcf63f445cbd7a" name="aa1dec568e79152c892dcf63f445cbd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dec568e79152c892dcf63f445cbd7a">&#9670;&#160;</a></span>ALWAYS_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALWAYS_INLINE&#160;&#160;&#160;inline</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the 'always_inline' attribute to the function if it's supported. </p>
<p>This attribute forces the function to be inlined if it's possible. If it's not, this results in a diagnostic.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <span class="keywordtype">int</span> function() { <span class="keywordflow">return</span> 0; }</div>
<div class="ttc" id="amodule_8h_html_aa1dec568e79152c892dcf63f445cbd7a"><div class="ttname"><a href="module_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a></div><div class="ttdeci">#define ALWAYS_INLINE</div><div class="ttdoc">Adds the 'always_inline' attribute to the function if it's supported.</div><div class="ttdef"><b>Definition</b> module.h:363</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac8c9f90a1d4b7435c509fd2020e4aa88" name="ac8c9f90a1d4b7435c509fd2020e4aa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9f90a1d4b7435c509fd2020e4aa88">&#9670;&#160;</a></span>BUILD_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUILD_INFO&#160;&#160;&#160;&quot;Linux-x86_64-Debug&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CMake build type signature, e.g. </p>
<p>Linux-x86_64-Debug </p>

</div>
</div>
<a id="a040141d0f88e012c0b915e3531fef5cc" name="a040141d0f88e012c0b915e3531fef5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040141d0f88e012c0b915e3531fef5cc">&#9670;&#160;</a></span>BUILD_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUILD_TYPE&#160;&#160;&#160;&quot;Debug&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build type, e.g. </p>
<p>Debug or Release </p>

</div>
</div>
<a id="a75df7795fe4158ac681564ae0520d975" name="a75df7795fe4158ac681564ae0520d975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75df7795fe4158ac681564ae0520d975">&#9670;&#160;</a></span>CFORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFORMAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">archetype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stringindex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">firsttocheck&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CFORMAT attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments that should be type-checked against a format string. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html</a> </dd></dl>

</div>
</div>
<a id="af8c317a42292b61c93aae91e59118a46" name="af8c317a42292b61c93aae91e59118a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c317a42292b61c93aae91e59118a46">&#9670;&#160;</a></span>container_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define container_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        <span class="keyword">const</span> typeof( ((type *)0)-&gt;member  ) *__mptr = (ptr); \</div>
<div class="line">        (type *)( (<span class="keywordtype">char</span> *)__mptr - <a class="code hl_define" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(type,member)  );})</div>
<div class="ttc" id="amodule_8h_html_afd049f7ad59dbe455f460807475c2841"><div class="ttname"><a href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a></div><div class="ttdeci">#define offsetof(type, member)</div><div class="ttdoc">The macro offsetof expands to an integral constant expression of type size_t, the value of which is t...</div><div class="ttdef"><b>Definition</b> module.h:220</div></div>
</div><!-- fragment -->
<p>This macro is used to retrieve an enclosing structure from a pointer to a nested element. </p>

</div>
</div>
<a id="a033c6face33bc7db165c0ba591696fcc" name="a033c6face33bc7db165c0ba591696fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033c6face33bc7db165c0ba591696fcc">&#9670;&#160;</a></span>DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEPRECATED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_msg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The DEPRECATED attribute can be applied to a function, a variable, or a type. </p>
<p>This is useful when identifying functions, variables, or types that are expected to be removed in a future version of a program. </p>

</div>
</div>
<a id="a0cf2d82c57a09723ab59e6f4dcc45b84" name="a0cf2d82c57a09723ab59e6f4dcc45b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf2d82c57a09723ab59e6f4dcc45b84">&#9670;&#160;</a></span>FALLTHROUGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALLTHROUGH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Attributes }}}. </p>
<p>{{{ Statement Attributes The fallthrough attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the -Wimplicit-fallthrough warning must not trigger. The fallthrough attribute may appear at most once in each attribute list, and may not be mixed with other attributes. It can only be used in a switch statement (the compiler will issue an error otherwise), after a preceding statement and before a logically succeeding case label, or user-defined label. </p>

</div>
</div>
<a id="a643b6b7ac15874197420e2adbea8b6bb" name="a643b6b7ac15874197420e2adbea8b6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643b6b7ac15874197420e2adbea8b6bb">&#9670;&#160;</a></span>INSTALL_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTALL_PREFIX&#160;&#160;&#160;&quot;/usr/local&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install prefix (e.g. </p>
<p>/usr) </p>

</div>
</div>
<a id="a217a0bd562b98ae8c2ffce44935351e1" name="a217a0bd562b98ae8c2ffce44935351e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217a0bd562b98ae8c2ffce44935351e1">&#9670;&#160;</a></span>likely</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define likely</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiler-independent built-ins. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a></dd></dl>
<p>{{{ Built-ins You may use <a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1" title="Compiler-independent built-ins.">likely()</a>/unlikely() to provide the compiler with branch prediction information. </p>

</div>
</div>
<a id="a07d932791f722cd5b75c111e51ef2023" name="a07d932791f722cd5b75c111e51ef2023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d932791f722cd5b75c111e51ef2023">&#9670;&#160;</a></span>MAYBE_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAYBE_UNUSED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Built-ins }}}. </p>
<p>Compiler-independent function attributes.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html</a> </dd>
<dd>
<a href="http://clang.llvm.org/docs/AttributeReference.html#function-attributes">http://clang.llvm.org/docs/AttributeReference.html#function-attributes</a> </dd>
<dd>
<a href="http://en.cppreference.com/w/cpp/language/attributes">http://en.cppreference.com/w/cpp/language/attributes</a></dd></dl>
<p>{{{ Function Attributes The MAYBE_UNUSED function attribute can be used to silence -Wunused diagnostics when the entity cannot be removed. For instance, a local variable may exist solely for use in an assert() statement, which makes the local variable unused when NDEBUG is defined.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> fun(<a class="code hl_define" href="module_8h.html#a07d932791f722cd5b75c111e51ef2023">MAYBE_UNUSED</a> <span class="keywordtype">int</span> unused_arg);</div>
<div class="ttc" id="amodule_8h_html_a07d932791f722cd5b75c111e51ef2023"><div class="ttname"><a href="module_8h.html#a07d932791f722cd5b75c111e51ef2023">MAYBE_UNUSED</a></div><div class="ttdeci">#define MAYBE_UNUSED</div><div class="ttdoc">Built-ins }}}.</div><div class="ttdef"><b>Definition</b> module.h:311</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a69b1282ba1eedeb002fd3bb325d3570b" name="a69b1282ba1eedeb002fd3bb325d3570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b1282ba1eedeb002fd3bb325d3570b">&#9670;&#160;</a></span>NO_SANITIZE_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NO_SANITIZE_ADDRESS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NO_SANITIZE_ADDRESS attribute disables AddressSanitizer for a given function. </p>
<p>The attribute may not be supported by old compilers, but they do not support ASAN as well, so it's safe to define the attribute only if ASAN is enabled. </p>

</div>
</div>
<a id="abf13e44576a768044e199191d4f26f7e" name="abf13e44576a768044e199191d4f26f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf13e44576a768044e199191d4f26f7e">&#9670;&#160;</a></span>NODISCARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NODISCARD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A diagnostic is generated when a function is marked with NODISCARD and the function call appears as a potentially-evaluated discarded-value expression that is not explicitly cast to void. </p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#abf13e44576a768044e199191d4f26f7e">NODISCARD</a> <span class="keywordtype">int</span> function() { <span class="keywordflow">return</span> -1 };</div>
<div class="ttc" id="amodule_8h_html_abf13e44576a768044e199191d4f26f7e"><div class="ttname"><a href="module_8h.html#abf13e44576a768044e199191d4f26f7e">NODISCARD</a></div><div class="ttdeci">#define NODISCARD</div><div class="ttdoc">A diagnostic is generated when a function is marked with NODISCARD and the function call appears as a...</div><div class="ttdef"><b>Definition</b> module.h:330</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1b173d22e57d9395897acbd8de62d505" name="a1b173d22e57d9395897acbd8de62d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b173d22e57d9395897acbd8de62d505">&#9670;&#160;</a></span>NOINLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOINLINE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attribute prevents a function from being considered for inlining. </p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#a1b173d22e57d9395897acbd8de62d505">NOINLINE</a> <span class="keywordtype">int</span> function() { <span class="keywordflow">return</span> 0; };</div>
<div class="ttc" id="amodule_8h_html_a1b173d22e57d9395897acbd8de62d505"><div class="ttname"><a href="module_8h.html#a1b173d22e57d9395897acbd8de62d505">NOINLINE</a></div><div class="ttdeci">#define NOINLINE</div><div class="ttdoc">This function attribute prevents a function from being considered for inlining.</div><div class="ttdef"><b>Definition</b> module.h:346</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa1728270d73c5d1598de1fd691762eb1" name="aa1728270d73c5d1598de1fd691762eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1728270d73c5d1598de1fd691762eb1">&#9670;&#160;</a></span>NORETURN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NORETURN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function declared as NORETURN shall not return to its caller. </p>
<p>The compiler will generate a diagnostic for a function declared as NORETURN that appears to be capable of returning to its caller.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#aa1728270d73c5d1598de1fd691762eb1">NORETURN</a> <span class="keywordtype">void</span> abort();</div>
<div class="ttc" id="amodule_8h_html_aa1728270d73c5d1598de1fd691762eb1"><div class="ttname"><a href="module_8h.html#aa1728270d73c5d1598de1fd691762eb1">NORETURN</a></div><div class="ttdeci">#define NORETURN</div><div class="ttdoc">A function declared as NORETURN shall not return to its caller.</div><div class="ttdef"><b>Definition</b> module.h:382</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa326a05d5e30f9e9a4bb0b4469d5d0c0" name="aa326a05d5e30f9e9a4bb0b4469d5d0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa326a05d5e30f9e9a4bb0b4469d5d0c0">&#9670;&#160;</a></span>PACKAGE_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PACKAGE_VERSION&#160;&#160;&#160;&quot;3.5.0-entrypoint-101-g0ba7505b96&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string with major-minor-patch-commit-id identifier of the release, e.g. </p>
<p>1.6.6-113-g8399d0e. </p>

</div>
</div>
<a id="a36d525cf4d116b2fe4ecc00222b256f1" name="a36d525cf4d116b2fe4ecc00222b256f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d525cf4d116b2fe4ecc00222b256f1">&#9670;&#160;</a></span>PACKED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="unionPACKED.html">PACKED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="unionPACKED.html" title="Public representation of a key part definition.">PACKED</a> qualifier is useful to map a structure to an external data structure, or for accessing unaligned data, but it is generally not useful to save data size because of the relatively high cost of unaligned access on some architectures. </p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_union" href="unionPACKED.html">PACKED</a> name { <span class="keywordtype">char</span> a; <span class="keywordtype">int</span> b; };</div>
<div class="ttc" id="aunionPACKED_html"><div class="ttname"><a href="unionPACKED.html">PACKED</a></div><div class="ttdoc">Public representation of a key part definition.</div><div class="ttdef"><b>Definition</b> module.h:1974</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="add6458adcc00e90c64bc87db324d1602" name="add6458adcc00e90c64bc87db324d1602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6458adcc00e90c64bc87db324d1602">&#9670;&#160;</a></span>prefetch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define prefetch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((void) addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed. </p>
<p>You can insert calls to <a class="el" href="module_8h.html#add6458adcc00e90c64bc87db324d1602" title="This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed.">prefetch()</a> into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions will be generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</p>
<p>The value of addr is the address of the memory to prefetch. There are two optional arguments, rw and locality. The value of rw is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value locality must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three. </p>

</div>
</div>
<a id="a5b2bb360001f6dfb4f946335950cabbf" name="a5b2bb360001f6dfb4f946335950cabbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2bb360001f6dfb4f946335950cabbf">&#9670;&#160;</a></span>say</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">error, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        say_file_line(level, __FILE__, __LINE__, error, format, ##__VA_ARGS__); })</div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>(int) - log level (see enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a>) </td></tr>
    <tr><td class="paramname">error</td><td>(const char * ) - error description, may be NULL </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> </dd></dl>

</div>
</div>
<a id="a7971b0f41c615be5a0b7100b5e42dcb3" name="a7971b0f41c615be5a0b7100b5e42dcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7971b0f41c615be5a0b7100b5e42dcb3">&#9670;&#160;</a></span>say_crit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_crit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_CRIT, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
<div class="ttc" id="amodule_8h_html_ae02d530f5d4ff18fd7786c3648dac2cf"><div class="ttname"><a href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a></div><div class="ttdeci">#define say_info(format,...)</div><div class="ttdoc">Format and print a message to Tarantool log file.</div><div class="ttdef"><b>Definition</b> module.h:612</div></div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="ab318c2435df2b04c7180df57a3c217ae" name="ab318c2435df2b04c7180df57a3c217ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab318c2435df2b04c7180df57a3c217ae">&#9670;&#160;</a></span>say_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_debug</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_DEBUG, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="a0a7d66a81cb7c12fdb2bf2c16b9c563e" name="a0a7d66a81cb7c12fdb2bf2c16b9c563e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7d66a81cb7c12fdb2bf2c16b9c563e">&#9670;&#160;</a></span>say_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_ERROR, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aed82e9747a226e287b0355deecfee5d1" name="aed82e9747a226e287b0355deecfee5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82e9747a226e287b0355deecfee5d1">&#9670;&#160;</a></span>say_file_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_file_line</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">file, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">line, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">error, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        if (<a class="code hl_function" href="module_8h.html#a11d9d5dc245f23922392835e55fccba9">say_log_level_is_enabled</a>(level)) \</div>
<div class="line">                _say(level, file, line, error, format, ##__VA_ARGS__); })</div>
<div class="ttc" id="amodule_8h_html_a11d9d5dc245f23922392835e55fccba9"><div class="ttname"><a href="module_8h.html#a11d9d5dc245f23922392835e55fccba9">say_log_level_is_enabled</a></div><div class="ttdeci">static bool say_log_level_is_enabled(int level)</div><div class="ttdoc">Function checks whether passed log level is enabled.</div><div class="ttdef"><b>Definition</b> module.h:545</div></div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>(int) - log level (see enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a>) </td></tr>
    <tr><td class="paramname">file</td><td>(const char * ) - file name to print </td></tr>
    <tr><td class="paramname">line</td><td>(int) - line number to print </td></tr>
    <tr><td class="paramname">error</td><td>(const char * ) - error description, may be NULL </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> </dd></dl>

</div>
</div>
<a id="ae02d530f5d4ff18fd7786c3648dac2cf" name="ae02d530f5d4ff18fd7786c3648dac2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02d530f5d4ff18fd7786c3648dac2cf">&#9670;&#160;</a></span>say_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_info</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_INFO, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="a39929109aefade22a76048b9ac73bd8d" name="a39929109aefade22a76048b9ac73bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39929109aefade22a76048b9ac73bd8d">&#9670;&#160;</a></span>say_syserror</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_syserror</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                      <a class="code hl_define" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_SYSERROR, <a class="code hl_function" href="module_8h.html#acfccf290219d520605e8eaac46b16694">_say_strerror</a>(errno), \</div>
<div class="line">                                      format, ##__VA_ARGS__)</div>
<div class="ttc" id="amodule_8h_html_a5b2bb360001f6dfb4f946335950cabbf"><div class="ttname"><a href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a></div><div class="ttdeci">#define say(level, error, format,...)</div><div class="ttdoc">Format and print a message to Tarantool log file.</div><div class="ttdef"><b>Definition</b> module.h:591</div></div>
<div class="ttc" id="amodule_8h_html_acfccf290219d520605e8eaac46b16694"><div class="ttname"><a href="module_8h.html#acfccf290219d520605e8eaac46b16694">_say_strerror</a></div><div class="ttdeci">const char * _say_strerror(int errnum)</div><div class="ttdoc">Internal function that implements MT-Safe strerror().</div></div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="a01a0037b2d3389e850c9bd7d66996b42" name="a01a0037b2d3389e850c9bd7d66996b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a0037b2d3389e850c9bd7d66996b42">&#9670;&#160;</a></span>say_verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_verbose</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_VERBOSE, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="ac1ea95f80b8aa81fe56ca4291814b8a3" name="ac1ea95f80b8aa81fe56ca4291814b8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ea95f80b8aa81fe56ca4291814b8a3">&#9670;&#160;</a></span>say_warn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_warn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_WARN, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code hl_define" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment -->   </dd></dl>

</div>
</div>
<a id="adb6d1259777e8f56c6260be6faed183e" name="adb6d1259777e8f56c6260be6faed183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6d1259777e8f56c6260be6faed183e">&#9670;&#160;</a></span>SYSCONF_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCONF_DIR&#160;&#160;&#160;&quot;etc&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>System configuration dir (e.g /etc) </p>

</div>
</div>
<a id="aa4ca483733f06b223d2619bdd00d88eb" name="aa4ca483733f06b223d2619bdd00d88eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ca483733f06b223d2619bdd00d88eb">&#9670;&#160;</a></span>SYSTEM_SPACES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSTEM_SPACES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>List of system space definitions in the following format: (name, identifier, is_sync), where is_sync determines whether synchronous replication is enabled for this system space when the synchronous queue is claimed. If is_sync is false, a reason must be supplied after the space definition comment. </p>

</div>
</div>
<a id="ad63a17703ee9303be2682b7bb08e7a9f" name="ad63a17703ee9303be2682b7bb08e7a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63a17703ee9303be2682b7bb08e7a9f">&#9670;&#160;</a></span>TZDATA_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TZDATA_VERSION&#160;&#160;&#160;&quot;2022a&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string with tag identifier of the tzdata release, e.g. </p>
<p>2024a. </p>

</div>
</div>
<a id="ac6c45889010c1bd68631771b64f18101" name="ac6c45889010c1bd68631771b64f18101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c45889010c1bd68631771b64f18101">&#9670;&#160;</a></span>unlikely</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define unlikely</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may use <a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1" title="Compiler-independent built-ins.">likely()</a>/unlikely() to provide the compiler with branch prediction information. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/attributes/likely">https://en.cppreference.com/w/cpp/language/attributes/likely</a> </dd></dl>

</div>
</div>
<a id="a86d08c1b23d67eca942da0ac012d89f3" name="a86d08c1b23d67eca942da0ac012d89f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d08c1b23d67eca942da0ac012d89f3">&#9670;&#160;</a></span>unreachable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define unreachable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(assert(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If control flow reaches the point of the <a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3" title="If control flow reaches the point of the unreachable(), the program is undefined.">unreachable()</a>, the program is undefined. </p>
<p>It is useful in situations where the compiler cannot deduce the unreachability of the code. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a90d26cf0c54dfa5e878e95ca0f73202a" name="a90d26cf0c54dfa5e878e95ca0f73202a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d26cf0c54dfa5e878e95ca0f73202a">&#9670;&#160;</a></span>box_decimal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structbox__decimal.html">box_decimal</a> <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage for a decimal number. </p>
<p>This type is large enough to hold a decimal value. The primary usage is to allocate a decimal on the stack and pass it to a box_decimal_*() function.</p>
<p>Take it as opacue structure with ability to allocate a value on the stack.</p>
<p>Use <a class="el" href="module_8h.html#ac308e450dedd64c9ed97a0fa841de8bc" title="Copy decimal value from one storage to another.">box_decimal_copy()</a> to copy the value, don't use memcpy(). The real data can be smaller than this type. Moreover, tarantool may allocate less bytes for <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> value, so direct read/write of the structure may lead to access to an unallocated memory.</p>
<p>The alignment of the structure is not less than alignment of decimal values allocated by tarantool. It can be larger and it is another reason to don't access the structure content directly.</p>
<p>Last, but not least: the data format is unspecified and can be changed. Modules and applications that aims to be compatible with future tarantool versions must not lean on particular data representation within the structure. </p>

</div>
</div>
<a id="a302d3f85cf14f03ace911e9541c95c4d" name="a302d3f85cf14f03ace911e9541c95c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302d3f85cf14f03ace911e9541c95c4d">&#9670;&#160;</a></span>box_key_part_def_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionPACKED.html">PACKED</a> <a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public representation of a key part definition. </p>
<p>Usage: Allocate an array of such key parts, initialize each key part (call <a class="el" href="module_8h.html#a52f751905f893144ead356172137e796" title="Initialize a key part with default values.">box_key_part_def_create()</a> and set necessary fields), pass the array into <a class="el" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718" title="Create a key_def from given key parts.">box_key_def_new_v2()</a> function.</p>
<p>Important: A module should call <a class="el" href="module_8h.html#a52f751905f893144ead356172137e796" title="Initialize a key part with default values.">box_key_part_def_create()</a> to initialize the structure with default values. There is no guarantee that all future default values for fields and flags will be remain the same.</p>
<p>The idea of separation from internal "struct key_part_def" is to provide stable API and ABI for modules.</p>
<p>New fields may be added into the end of the structure in later tarantool versions. Also new flags may be introduced within <em>flags</em> field. <em>collation</em> cannot be changed to a union (to reuse for some other value), because it is verified even for a non-string key part by <a class="el" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718" title="Create a key_def from given key parts.">box_key_def_new_v2()</a>.</p>
<p>Fields that are unknown at given tarantool version are ignored in general, but filled with zeros when initialized. </p>

</div>
</div>
<a id="a923d13f137e4bdb8c852ea04637da58d" name="a923d13f137e4bdb8c852ea04637da58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d13f137e4bdb8c852ea04637da58d">&#9670;&#160;</a></span>box_latch_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct box_latch <a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>A lock for cooperative multitasking environment </p>

</div>
</div>
<a id="aa9eb59c79a9b32bb8a23204e89bced9d" name="aa9eb59c79a9b32bb8a23204e89bced9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb59c79a9b32bb8a23204e89bced9d">&#9670;&#160;</a></span>iproto_handler_destroy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* iproto_handler_destroy_t) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPROTO request handler destructor called when the corresponding handler is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19dc8ff47cfc25ee92d0f74cdf459070" name="a19dc8ff47cfc25ee92d0f74cdf459070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dc8ff47cfc25ee92d0f74cdf459070">&#9670;&#160;</a></span>iproto_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a>(* iproto_handler_t) (const char *header, const char *header_end, const char *body, const char *body_end, void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPROTO request handler signature: receives MsgPack encoded header and body, a context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a>, and must return one of the status codes from iproto_handler_status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Msgpack encoded header </td></tr>
    <tr><td class="paramname">header_end</td><td>end of Msgpack encoded header </td></tr>
    <tr><td class="paramname">body</td><td>Msgpack encoded body </td></tr>
    <tr><td class="paramname">body_end</td><td>end of Msgpack encoded body </td></tr>
    <tr><td class="paramname">ctx</td><td>context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a status code </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a06fc87d81c62e9abb8790b6e5713c55b" name="a06fc87d81c62e9abb8790b6e5713c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fc87d81c62e9abb8790b6e5713c55b">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06fc87d81c62e9abb8790b6e5713c55ba4e556d3f75a54e162feaa8e9451cfce7" name="a06fc87d81c62e9abb8790b6e5713c55ba4e556d3f75a54e162feaa8e9451cfce7"></a>COIO_READ&#160;</td><td class="fielddoc"><p>READ event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06fc87d81c62e9abb8790b6e5713c55ba9ccd504861956d107f717efa66b3f1b7" name="a06fc87d81c62e9abb8790b6e5713c55ba9ccd504861956d107f717efa66b3f1b7"></a>COIO_WRITE&#160;</td><td class="fielddoc"><p>WRITE event. </p>
</td></tr>
</table>

</div>
</div>
<a id="a99fb83031ce9923c84392b4e92f956b5" name="a99fb83031ce9923c84392b4e92f956b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb83031ce9923c84392b4e92f956b5">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is recommended to verify size of box_key_part_def_t against this constant on the module side at build time. </p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if !defined(__cplusplus) &amp;&amp; !defined(static_assert)</span></div>
<div class="line"><span class="preprocessor">#define static_assert _Static_assert</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">(slash)*</div>
<div class="line"> * Verify that <a class="code hl_union" href="unionPACKED.html">box_key_part_def_t</a> has the same size when</div>
<div class="line"> * compiled within tarantool and within the module.</div>
<div class="line"> *</div>
<div class="line"> * It is important, because the module allocates an array of key</div>
<div class="line"> * parts and passes it to <a class="code hl_function" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718">box_key_def_new_v2</a>() tarantool</div>
<div class="line"> * function.</div>
<div class="line"> *(slash)</div>
<div class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<a class="code hl_union" href="unionPACKED.html">box_key_part_def_t</a>) == <a class="code hl_enumvalue" href="module_8h.html#a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433">BOX_KEY_PART_DEF_T_SIZE</a>,</div>
<div class="line">              <span class="stringliteral">&quot;sizeof(box_key_part_def_t)&quot;</span>);</div>
<div class="ttc" id="amodule_8h_html_a0ee0eb2d3a12d2588226a2a232f7b718"><div class="ttname"><a href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718">box_key_def_new_v2</a></div><div class="ttdeci">box_key_def_t * box_key_def_new_v2(box_key_part_def_t *parts, uint32_t part_count)</div><div class="ttdoc">Create a key_def from given key parts.</div></div>
<div class="ttc" id="amodule_8h_html_a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433"><div class="ttname"><a href="module_8h.html#a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433">BOX_KEY_PART_DEF_T_SIZE</a></div><div class="ttdeci">@ BOX_KEY_PART_DEF_T_SIZE</div><div class="ttdoc">The constant.</div><div class="ttdef"><b>Definition</b> module.h:1947</div></div>
</div><!-- fragment --><p>This snippet is not part of <a class="el" href="module_8h.html">module.h</a>, because portability of static_assert() / _Static_assert() is dubious. It should be decision of a module author how portable its code should be. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433" name="a99fb83031ce9923c84392b4e92f956b5a372d10ebd12378fbc28f503f5c14a433"></a>BOX_KEY_PART_DEF_T_SIZE&#160;</td><td class="fielddoc"><p>The constant. </p>
</td></tr>
</table>

</div>
</div>
<a id="abc6126af1d45847bc59afa0aa3216b04" name="abc6126af1d45847bc59afa0aa3216b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6126af1d45847bc59afa0aa3216b04">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a05cae1bfc9671a38779ffd9dde4d7f58" name="abc6126af1d45847bc59afa0aa3216b04a05cae1bfc9671a38779ffd9dde4d7f58"></a>BOX_SYSTEM_ID_MIN&#160;</td><td class="fielddoc"><p>Start of the reserved range of system spaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04abb87df1b61192ee3aea178534071b9cd" name="abc6126af1d45847bc59afa0aa3216b04abb87df1b61192ee3aea178534071b9cd"></a>BOX_SYSTEM_ID_MAX&#160;</td><td class="fielddoc"><p>End of the reserved range of system spaces. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad95be11a839742b838f48a05e15dc96f" name="ad95be11a839742b838f48a05e15dc96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95be11a839742b838f48a05e15dc96f">&#9670;&#160;</a></span>box_slab_info_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#ad95be11a839742b838f48a05e15dc96f">box_slab_info_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Codes for request memtx status information for box.slab.info. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96fa5035a467639de7b7878658bb6d5d6759" name="ad95be11a839742b838f48a05e15dc96fa5035a467639de7b7878658bb6d5d6759"></a>BOX_SLAB_INFO_ITEMS_SIZE&#160;</td><td class="fielddoc"><p>Allocated only for tuples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96fac05e5e1257324755fbb5b69a42a3162f" name="ad95be11a839742b838f48a05e15dc96fac05e5e1257324755fbb5b69a42a3162f"></a>BOX_SLAB_INFO_ITEMS_USED&#160;</td><td class="fielddoc"><p>Used only for tuples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96fa011955c844200186269b1728c60072a9" name="ad95be11a839742b838f48a05e15dc96fa011955c844200186269b1728c60072a9"></a>BOX_SLAB_INFO_ARENA_SIZE&#160;</td><td class="fielddoc"><p>Allocated for tuples and indexes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96faaf908670201e994b6fbb7a39bd0af778" name="ad95be11a839742b838f48a05e15dc96faaf908670201e994b6fbb7a39bd0af778"></a>BOX_SLAB_INFO_ARENA_USED&#160;</td><td class="fielddoc"><p>Used for both tuples and indexes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96fa1d115d2d78ba3a718b37952afc930716" name="ad95be11a839742b838f48a05e15dc96fa1d115d2d78ba3a718b37952afc930716"></a>BOX_SLAB_INFO_QUOTA_SIZE&#160;</td><td class="fielddoc"><p>Memory limit for slab allocator. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95be11a839742b838f48a05e15dc96fa9727bdf5f628906b49ab0c65682d6a70" name="ad95be11a839742b838f48a05e15dc96fa9727bdf5f628906b49ab0c65682d6a70"></a>BOX_SLAB_INFO_QUOTA_USED&#160;</td><td class="fielddoc"><p>Used by slab allocator. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4dab01cb6470a8177e9618558523ff7b" name="a4dab01cb6470a8177e9618558523ff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dab01cb6470a8177e9618558523ff7b">&#9670;&#160;</a></span>iproto_handler_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return codes for IPROTO request handlers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7ba964fc0581c3169c5047abaebcbc6a190" name="a4dab01cb6470a8177e9618558523ff7ba964fc0581c3169c5047abaebcbc6a190"></a>IPROTO_HANDLER_OK&#160;</td><td class="fielddoc"><p>Success, no further actions needed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7ba3838e3dc0206744064024e6948f5f214" name="a4dab01cb6470a8177e9618558523ff7ba3838e3dc0206744064024e6948f5f214"></a>IPROTO_HANDLER_ERROR&#160;</td><td class="fielddoc"><p>Error, diagnostic must be set by handler via <a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b" title="Set the last error.">box_error_set()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7badb3e2b86bb68c8ef55af839fc59a63a5" name="a4dab01cb6470a8177e9618558523ff7badb3e2b86bb68c8ef55af839fc59a63a5"></a>IPROTO_HANDLER_FALLBACK&#160;</td><td class="fielddoc"><p>Fallback to system handler. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2693ce4bd8fa71e8ac1e5272fc64d17e" name="a2693ce4bd8fa71e8ac1e5272fc64d17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2693ce4bd8fa71e8ac1e5272fc64d17e">&#9670;&#160;</a></span>iterator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Controls how to iterate over tuples in an index. Different index types support different iterator types. For example, one can start iteration from a particular value (request key) and then retrieve all tuples where keys are greater or equal (= GE) to this key.</p>
<p>If iterator type is not supported by the selected index type, iterator constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, an index must support at least ITER_EQ and ITER_GE types.</p>
<p>NULL value of request key corresponds to the first or last key in the index, depending on iteration direction. (first key for GE and GT types, and last key for LE and LT). Therefore, to iterate over all tuples in an index, one can use ITER_GE or ITER_LE iteration types with start key equal to NULL. For ITER_EQ, the key must not be NULL. </p>

</div>
</div>
<a id="af667a90dfe6a8cc25b510af73d98bb82" name="af667a90dfe6a8cc25b510af73d98bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af667a90dfe6a8cc25b510af73d98bb82">&#9670;&#160;</a></span>say_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Log levels </p>

</div>
</div>
<a id="af2d527c62a52f85cb173c79c31d20ce1" name="af2d527c62a52f85cb173c79c31d20ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d527c62a52f85cb173c79c31d20ce1">&#9670;&#160;</a></span>txn_isolation_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">txn_isolation_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>When a transaction calls <code>commit</code>, this action can last for some time until redo data is written to WAL. While such a <code>commit</code> call is in progress we call changes of such a transaction as 'committed', and when the process is finished - we call the changes as 'confirmed'. One of the main options of a transaction is to see or not to see 'committed' changes. Note that now there are different terminologies in different places. This enum uses new 'committed' and 'confirmed' states of transactions. Meanwhile in engined the first state is usually called as 'prepared', and the second as 'committed' or 'completed'. Warning: this enum is exposed in lua via ffi, and thus any change in items must be correspondingly modified on ffi.cdef(), see schema.lua. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a4f9fb36818af61558b13124ca0e02363" name="af2d527c62a52f85cb173c79c31d20ce1a4f9fb36818af61558b13124ca0e02363"></a>TXN_ISOLATION_DEFAULT&#160;</td><td class="fielddoc"><p>Take isolation level from global default_isolation_level. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a351aceaaa55693a90f5e33103d051947" name="af2d527c62a52f85cb173c79c31d20ce1a351aceaaa55693a90f5e33103d051947"></a>TXN_ISOLATION_READ_COMMITTED&#160;</td><td class="fielddoc"><p>Allow to read committed, but not confirmed changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1ab2411f8d6a9d68367da464d9fcff932f" name="af2d527c62a52f85cb173c79c31d20ce1ab2411f8d6a9d68367da464d9fcff932f"></a>TXN_ISOLATION_READ_CONFIRMED&#160;</td><td class="fielddoc"><p>Allow to read only confirmed changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1afa0bc338b3e678625a61d16254991c7b" name="af2d527c62a52f85cb173c79c31d20ce1afa0bc338b3e678625a61d16254991c7b"></a>TXN_ISOLATION_BEST_EFFORT&#160;</td><td class="fielddoc"><p>Determine isolation level automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a6236950c80e86644457d27e158639b60" name="af2d527c62a52f85cb173c79c31d20ce1a6236950c80e86644457d27e158639b60"></a>TXN_ISOLATION_LINEARIZABLE&#160;</td><td class="fielddoc"><p>Allow to read only the changes confirmed on any cluster node. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a8e225c05de0c630a787eb113f64e3af4" name="af2d527c62a52f85cb173c79c31d20ce1a8e225c05de0c630a787eb113f64e3af4"></a>txn_isolation_level_MAX&#160;</td><td class="fielddoc"><p>Upper bound of valid values. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acfccf290219d520605e8eaac46b16694" name="acfccf290219d520605e8eaac46b16694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfccf290219d520605e8eaac46b16694">&#9670;&#160;</a></span>_say_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * _say_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that implements MT-Safe strerror(). </p>
<p>It is used by <a class="el" href="module_8h.html#a39929109aefade22a76048b9ac73bd8d" title="Format and print a message to Tarantool log file.">say_syserror()</a> macro. </p>

</div>
</div>
<a id="a9ff11b49687b7a3ad15a6246368a74f9" name="a9ff11b49687b7a3ad15a6246368a74f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff11b49687b7a3ad15a6246368a74f9">&#9670;&#160;</a></span>box_decimal_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute value of a decimal. </p>
<p><em>res</em> is set to the absolute value of <em>dec</em>.</p>
<p>box_decimal_abs(&amp;a, &amp;a) is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to store the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>res</em> </dd></dl>

</div>
</div>
<a id="ac68205951a728801a27c7a1e059cb33b" name="ac68205951a728801a27c7a1e059cb33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68205951a728801a27c7a1e059cb33b">&#9670;&#160;</a></span>box_decimal_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a sum of two decimal numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="aaf0376671f42b04fdafb2706527762b4" name="aaf0376671f42b04fdafb2706527762b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0376671f42b04fdafb2706527762b4">&#9670;&#160;</a></span>box_decimal_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two decimal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if lhs &lt; rhs </dd>
<dd>
0 if lhs = rhs </dd>
<dd>
1 if lhs &gt; rhs </dd></dl>

</div>
</div>
<a id="ac308e450dedd64c9ed97a0fa841de8bc" name="ac308e450dedd64c9ed97a0fa841de8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308e450dedd64c9ed97a0fa841de8bc">&#9670;&#160;</a></span>box_decimal_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy decimal value from one storage to another. </p>
<p>Use this function where you would use memcpy() if the precise data size would be known.</p>
<p>The memory areas must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>where to store the copy </td></tr>
    <tr><td class="paramname">src</td><td>from where to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy (<em>dest</em>) </dd></dl>

</div>
</div>
<a id="ac38241d721907b901ff2f15875ad8ebe" name="ac38241d721907b901ff2f15875ad8ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38241d721907b901ff2f15875ad8ebe">&#9670;&#160;</a></span>box_decimal_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide one decimal number on another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="a7179a62fcfca4882a5612d0c9847d68d" name="a7179a62fcfca4882a5612d0c9847d68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7179a62fcfca4882a5612d0c9847d68d">&#9670;&#160;</a></span>box_decimal_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate exp(<em>dec</em>), i.e. </p>
<p>pow(e, <em>dec</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="a37aced6f227b3dbd48169ce4ba092504" name="a37aced6f227b3dbd48169ce4ba092504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37aced6f227b3dbd48169ce4ba092504">&#9670;&#160;</a></span>box_decimal_floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a floor function to a decimal, i.e. </p>
<p>round it towards zero to a decimal with given <em>scale</em>.</p>
<p>floor(-0.66, 1) -&gt; -0.6 floor(-0.65, 1) -&gt; -0.6 floor(-0.64, 1) -&gt; -0.6</p>
<p>floor(0.64, 1) -&gt; 0.6 floor(0.65, 1) -&gt; 0.6 floor(0.66, 1) -&gt; 0.6</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a84169b77917c2d12a4ef8027e4beacef" title="Round to nearest decimal at given scale, half goes away from zero.">box_decimal_round</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
    <tr><td class="paramname">scale</td><td>target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <em>scale</em> is out of supported range </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="ac068234331e788d607868fd95cefa88f" name="ac068234331e788d607868fd95cefa88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac068234331e788d607868fd95cefa88f">&#9670;&#160;</a></span>box_decimal_from_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_from_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">d</td><td>source double value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the double is NaN, Infinity or greater than a maximum precision for decimal values </dd>
<dd>
decimal result </dd></dl>

</div>
</div>
<a id="ab1d0e0cb965eeeb0a00f867b4ee3431f" name="ab1d0e0cb965eeeb0a00f867b4ee3431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d0e0cb965eeeb0a00f867b4ee3431f">&#9670;&#160;</a></span>box_decimal_from_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_from_int64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a signed integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">num</td><td>source integer value (signed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal result </dd></dl>

</div>
</div>
<a id="a3eb48bbc701ce3221e4c5c4fd8c1055b" name="a3eb48bbc701ce3221e4c5c4fd8c1055b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb48bbc701ce3221e4c5c4fd8c1055b">&#9670;&#160;</a></span>box_decimal_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a value from a string. </p>
<p>The fractional part may be rounded if a maximum precision is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">str</td><td>source string value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the string is invalid or the number is too big </dd>
<dd>
decimal result </dd></dl>

</div>
</div>
<a id="a7e5a5a5609e5ee0cdaf33cef61a90077" name="a7e5a5a5609e5ee0cdaf33cef61a90077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5a5a5609e5ee0cdaf33cef61a90077">&#9670;&#160;</a></span>box_decimal_from_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_from_uint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a unsigned integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">num</td><td>source integer value (unsigned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal result </dd></dl>

</div>
</div>
<a id="a1adad9501fc38ba6e6a54f58d6152840" name="a1adad9501fc38ba6e6a54f58d6152840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adad9501fc38ba6e6a54f58d6152840">&#9670;&#160;</a></span>box_decimal_is_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool box_decimal_is_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the fractional part of a decimal number is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fractional part is zero </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a74749ee03d5f2860c5813b0bf36cabe4" name="a74749ee03d5f2860c5813b0bf36cabe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74749ee03d5f2860c5813b0bf36cabe4">&#9670;&#160;</a></span>box_decimal_is_neg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool box_decimal_is_neg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a decimal number is negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the decimal is less than zero </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a47ce757059e40b95dfca8e29077e638b" name="a47ce757059e40b95dfca8e29077e638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ce757059e40b95dfca8e29077e638b">&#9670;&#160;</a></span>box_decimal_ln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a natural logarithm (base e). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="a5da42507f4c84c89b0b1784f6ebb14bd" name="a5da42507f4c84c89b0b1784f6ebb14bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da42507f4c84c89b0b1784f6ebb14bd">&#9670;&#160;</a></span>box_decimal_log10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a common logarithm (base 10). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="acefc8a9f6fbed4a19d9b7a74ebd80107" name="acefc8a9f6fbed4a19d9b7a74ebd80107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefc8a9f6fbed4a19d9b7a74ebd80107">&#9670;&#160;</a></span>box_decimal_minus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_minus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform unary minus operation. </p>
<p><em>res</em> is set to -dec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to store the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>res</em> </dd></dl>

</div>
</div>
<a id="a7de043345d920023948829285063ce98" name="a7de043345d920023948829285063ce98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de043345d920023948829285063ce98">&#9670;&#160;</a></span>box_decimal_mp_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_mp_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a decimal from msgpack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decoded decimal </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer with the msgpack data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the msgpack data does not represent a valid decimal value </dd>
<dd>
the decoded decimal </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + box_decimal_mp_sizeof(retval) </dd></dl>

</div>
</div>
<a id="a0c08c83a937326e63be00ef63c77c12f" name="a0c08c83a937326e63be00ef63c77c12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c08c83a937326e63be00ef63c77c12f">&#9670;&#160;</a></span>box_decimal_mp_decode_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_mp_decode_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a decimal from msgpack <em>data</em> without the msgpack extension header. </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="module_8h.html#a0c08c83a937326e63be00ef63c77c12f">box_decimal_mp_decode_data</a>() must be called for this position</div>
<div class="line">                                       |</div>
<div class="line">                                       v</div>
<div class="line">&lt;msgpack type&gt; &lt;size&gt; &lt;extension type&gt; &lt;data&gt;</div>
<div class="line">^</div>
<div class="line">|</div>
<div class="line"><a class="code hl_function" href="module_8h.html#a7de043345d920023948829285063ce98">box_decimal_mp_decode</a>() must be called for this position</div>
<div class="ttc" id="amodule_8h_html_a0c08c83a937326e63be00ef63c77c12f"><div class="ttname"><a href="module_8h.html#a0c08c83a937326e63be00ef63c77c12f">box_decimal_mp_decode_data</a></div><div class="ttdeci">box_decimal_t * box_decimal_mp_decode_data(box_decimal_t *dec, const char **data, uint32_t size)</div><div class="ttdoc">Decode a decimal from msgpack data without the msgpack extension header.</div></div>
<div class="ttc" id="amodule_8h_html_a7de043345d920023948829285063ce98"><div class="ttname"><a href="module_8h.html#a7de043345d920023948829285063ce98">box_decimal_mp_decode</a></div><div class="ttdeci">box_decimal_t * box_decimal_mp_decode(box_decimal_t *dec, const char **data)</div><div class="ttdoc">Decode a decimal from msgpack data.</div></div>
</div><!-- fragment --><p>This function is suitable to finish decoding after calling mp_decode_extl() (from the msgpuck library).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decoded decimal </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer with the msgpack data </td></tr>
    <tr><td class="paramname">size</td><td>size of the decimal data in the buffer; this value is returned by mp_decode_extl() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the msgpack data does not represent a valid decimal value </dd>
<dd>
the decoded decimal </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + <em>size</em> </dd></dl>

</div>
</div>
<a id="afdaf8eda7fa944c6fc8949e19af5dceb" name="afdaf8eda7fa944c6fc8949e19af5dceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaf8eda7fa944c6fc8949e19af5dceb">&#9670;&#160;</a></span>box_decimal_mp_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * box_decimal_mp_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a decimal as msgpack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number to encode </td></tr>
    <tr><td class="paramname">data</td><td>buffer to write the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + box_decimal_mp_sizeof(<em>dec</em>) </dd></dl>

</div>
</div>
<a id="ad847059b54874f3e4bde5550ec228fd3" name="ad847059b54874f3e4bde5550ec228fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad847059b54874f3e4bde5550ec228fd3">&#9670;&#160;</a></span>box_decimal_mp_sizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_decimal_mp_sizeof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate exact buffer size needed to store msgpack representation of a decimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer size </dd></dl>

</div>
</div>
<a id="aa3673e0c446bbd7917a06c842b4bcd99" name="aa3673e0c446bbd7917a06c842b4bcd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3673e0c446bbd7917a06c842b4bcd99">&#9670;&#160;</a></span>box_decimal_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two decimal numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="aac5d986753e1e1eb2d0a0e94f76044b5" name="aac5d986753e1e1eb2d0a0e94f76044b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d986753e1e1eb2d0a0e94f76044b5">&#9670;&#160;</a></span>box_decimal_pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <em>lhs</em> raised to the power of <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand, base </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand, power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="a1815f3add53077a6f1383db1d9347c99" name="a1815f3add53077a6f1383db1d9347c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1815f3add53077a6f1383db1d9347c99">&#9670;&#160;</a></span>box_decimal_precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_precision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decimal precision. </p>
<p>It is equivalent to amount of decimal digits in the string representation (not counting minus, decimal separator and the leading zero in 0.ddd...ddd number, but counting trailing zeros if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>precision </dd></dl>

</div>
</div>
<a id="a701a02f61292b3da8a4d10b68c85d7ff" name="a701a02f61292b3da8a4d10b68c85d7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701a02f61292b3da8a4d10b68c85d7ff">&#9670;&#160;</a></span>box_decimal_remainder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the remainder of diviging two decimals. </p>
<p><em>res</em> is set to the remainder of dividing <em>lhs</em> by <em>rhs</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="a96ea8ad6f58a43e9dca729a410b5e286" name="a96ea8ad6f58a43e9dca729a410b5e286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ea8ad6f58a43e9dca729a410b5e286">&#9670;&#160;</a></span>box_decimal_rescale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_rescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scale of <em>dec</em> to <em>scale</em>. </p>
<p>If <em>scale</em> is less than scale(<em>dec</em>), round the decimal. Otherwise append a sufficient amount of trailing fractional zeros.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a84169b77917c2d12a4ef8027e4beacef" title="Round to nearest decimal at given scale, half goes away from zero.">box_decimal_round</a> </dd>
<dd>
<a class="el" href="module_8h.html#abe405bddd53bc745cd54851b071e49c5" title="Remove trailing zeros from the fractional part of a number.">box_decimal_trim</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
    <tr><td class="paramname">scale</td><td>target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if scale is out of supported range (less than zero or too big) </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="a84169b77917c2d12a4ef8027e4beacef" name="a84169b77917c2d12a4ef8027e4beacef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84169b77917c2d12a4ef8027e4beacef">&#9670;&#160;</a></span>box_decimal_round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round to nearest decimal at given <em>scale</em>, half goes away from zero. </p>
<p>round(-0.66, 1) -&gt; -0.7 round(-0.65, 1) -&gt; -0.7 round(-0.64, 1) -&gt; -0.6</p>
<p>round(0.64, 1) -&gt; 0.6 round(0.65, 1) -&gt; 0.7 round(0.66, 1) -&gt; 0.7</p>
<p>Resulting decimal number has not more than <em>scale</em> digits after the decimal point.</p>
<p>If <em>scale</em> if greater than current <em>dec</em> scale, do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
    <tr><td class="paramname">scale</td><td>target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <em>scale</em> is out of supported range </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="a3499bd306b660788339570ea8b9f4733" name="a3499bd306b660788339570ea8b9f4733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499bd306b660788339570ea8b9f4733">&#9670;&#160;</a></span>box_decimal_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decimal scale. </p>
<p>It is equivalent to amount of digits after the decimal separator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scale </dd></dl>

</div>
</div>
<a id="a6c90a1dbf9e913e8ebf9f95330e570e8" name="a6c90a1dbf9e913e8ebf9f95330e570e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c90a1dbf9e913e8ebf9f95330e570e8">&#9670;&#160;</a></span>box_decimal_scale_from_int128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_from_int128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from given integer value and scale. </p>
<p>Scale is a negated exponent.</p>
<p>128 bit value is given as array with native endianness.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a8c1d16f165c38b5d72fb9ef18ab5ac3e" name="a8c1d16f165c38b5d72fb9ef18ab5ac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1d16f165c38b5d72fb9ef18ab5ac3e">&#9670;&#160;</a></span>box_decimal_scale_from_int256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_from_int256 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from given integer value and scale. </p>
<p>Scale is a negated exponent.</p>
<p>256 bit value is given as array with native endianness.</p>
<p>Note that not all 256 bit values are representable as box_decimal_t. If value is not representable then it is error.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a227f32322d571c6f6381bc72a88bf678" name="a227f32322d571c6f6381bc72a88bf678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f32322d571c6f6381bc72a88bf678">&#9670;&#160;</a></span>box_decimal_scale_from_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_from_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from given integer value and scale. </p>
<p>Scale is a negated exponent.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a4eb0a5484cbe49e65c61a4cdba51a03d" name="a4eb0a5484cbe49e65c61a4cdba51a03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb0a5484cbe49e65c61a4cdba51a03d">&#9670;&#160;</a></span>box_decimal_scale_from_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_from_int64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from given integer value and scale. </p>
<p>Scale is a negated exponent.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a043c0cbd03ee3567a306458cfb66b440" name="a043c0cbd03ee3567a306458cfb66b440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043c0cbd03ee3567a306458cfb66b440">&#9670;&#160;</a></span>box_decimal_scale_to_int128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_to_int128 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert decimal to integer given scale is <em>scale</em>. </p>
<p>Scale is a negated exponent. For example 1.23 will be converted to 123 if scale is 2 and to 1230 if scale is 3.</p>
<p>If decimal cannot be presented exactly with given scale then it is rounded. If result cannot fit in 128 bits then it is error.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a1d85d17e483ac8d9bc8be0c304e1bb24" name="a1d85d17e483ac8d9bc8be0c304e1bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d85d17e483ac8d9bc8be0c304e1bb24">&#9670;&#160;</a></span>box_decimal_scale_to_int256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_to_int256 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert decimal to integer given scale is <em>scale</em>. </p>
<p>Scale is a negated exponent. For example 1.23 will be converted to 123 if scale is 2 and to 1230 if scale is 3.</p>
<p>If decimal cannot be presented exactly with given scale then it is rounded. If result cannot fit in 128 bits then it is error.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="aed176d1daf608d41d24239bc9d73fdab" name="aed176d1daf608d41d24239bc9d73fdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed176d1daf608d41d24239bc9d73fdab">&#9670;&#160;</a></span>box_decimal_scale_to_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_to_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert decimal to integer given scale is <em>scale</em>. </p>
<p>Scale is a negated exponent. For example 1.23 will be converted to 123 if scale is 2 and to 1230 if scale is 3.</p>
<p>If decimal cannot be presented exactly with given scale then it is rounded. If result cannot fit in 32 bits then it is error.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="ad7b07d7e0fc3db346f1414384e6cc93e" name="ad7b07d7e0fc3db346f1414384e6cc93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b07d7e0fc3db346f1414384e6cc93e">&#9670;&#160;</a></span>box_decimal_scale_to_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_scale_to_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert decimal to integer given scale is <em>scale</em>. </p>
<p>Scale is a negated exponent. For example 1.23 will be converted to 123 if scale is 2 and to 1230 if scale is 3.</p>
<p>If decimal cannot be presented exactly with given scale then it is rounded. If result cannot fit in 64 bits then it is error.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL on error and <em>dec</em> on success. </dd></dl>

</div>
</div>
<a id="a2a85c95c41f61184a803dd714de874e5" name="a2a85c95c41f61184a803dd714de874e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85c95c41f61184a803dd714de874e5">&#9670;&#160;</a></span>box_decimal_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="aaa4473537df85f1f2168b9cc749f86b0" name="aaa4473537df85f1f2168b9cc749f86b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4473537df85f1f2168b9cc749f86b0">&#9670;&#160;</a></span>box_decimal_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract one decimal number from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (<em>res</em>) </dd></dl>

</div>
</div>
<a id="aef891f48c3de2b70a23565833977e51b" name="aef891f48c3de2b70a23565833977e51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef891f48c3de2b70a23565833977e51b">&#9670;&#160;</a></span>box_decimal_to_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_to_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given decimal to int64_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">num</td><td>where to store <em>dec</em> integer representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the value does not fit into int64_t </dd>
<dd>
<em>dec</em> </dd></dl>

</div>
</div>
<a id="a7a20acf8704e0a8de6b2c6e70cabda94" name="a7a20acf8704e0a8de6b2c6e70cabda94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a20acf8704e0a8de6b2c6e70cabda94">&#9670;&#160;</a></span>box_decimal_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_decimal_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the decimal as a string into the passed buffer. </p>
<p>The buffer must have at least <a class="el" href="module_8h.html#afd0415940d06f795e1f4dcfd40dd6c5b">BOX_DECIMAL_STRING_BUFFER_SIZE</a> bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">buf</td><td>where to write <em>dec</em> string representation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7984e1af9644427d4431d483313cda1" name="aa7984e1af9644427d4431d483313cda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7984e1af9644427d4431d483313cda1">&#9670;&#160;</a></span>box_decimal_to_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_to_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given decimal to uint64_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">num</td><td>where to store <em>dec</em> integer representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the value does not fit into uint64_t </dd>
<dd>
<em>dec</em> </dd></dl>

</div>
</div>
<a id="abe405bddd53bc745cd54851b071e49c5" name="abe405bddd53bc745cd54851b071e49c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe405bddd53bc745cd54851b071e49c5">&#9670;&#160;</a></span>box_decimal_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing zeros from the fractional part of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="ac11dd28c7727e83e8c3729a7f46c97d2" name="ac11dd28c7727e83e8c3729a7f46c97d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11dd28c7727e83e8c3729a7f46c97d2">&#9670;&#160;</a></span>box_decimal_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * box_decimal_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a zero decimal number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal result </dd></dl>

</div>
</div>
<a id="a740bf8f0f5f912dfa78221c9fe5f21bb" name="a740bf8f0f5f912dfa78221c9fe5f21bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740bf8f0f5f912dfa78221c9fe5f21bb">&#9670;&#160;</a></span>box_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_delete </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an DELETE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>an old tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:<span class="keyword">delete</span>(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a800a57f7e18f0b9c3880d4e516589e73" name="a800a57f7e18f0b9c3880d4e516589e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a57f7e18f0b9c3880d4e516589e73">&#9670;&#160;</a></span>box_error_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce">box_error_code</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return IPROTO error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum box_error_code </dd></dl>

</div>
</div>
<a id="a29b4ebee3bb9402fb8621b4e96b93b5d" name="a29b4ebee3bb9402fb8621b4e96b93b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b4ebee3bb9402fb8621b4e96b93b5d">&#9670;&#160;</a></span>box_error_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> * box_error_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about the last API call error. </p>
<p>The Tarantool error handling works most like libc's errno. All API calls return -1 or NULL in the event of error. An internal pointer to box_error_t type is set by API functions to indicate what went wrong. This value is only significant if API call failed (returned -1 or NULL).</p>
<p>Successful function can also touch the last error in some cases. You don't have to clear the last error before calling API functions. The returned object is valid only until next call to <b>any</b> API function.</p>
<p>You must set the last error using <a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b" title="Set the last error.">box_error_set()</a> in your stored C procedures if you want to return a custom error message. You can re-throw the last API error to IPROTO client by keeping the current value and returning -1 to Tarantool from your stored procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>last error. </dd></dl>

</div>
</div>
<a id="a4f94399db28784bf3419da94fa563463" name="a4f94399db28784bf3419da94fa563463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94399db28784bf3419da94fa563463">&#9670;&#160;</a></span>box_error_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_error_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>not-null string </dd></dl>

</div>
</div>
<a id="aa6e6803bc4309c3f59b93e2709cb418b" name="aa6e6803bc4309c3f59b93e2709cb418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e6803bc4309c3f59b93e2709cb418b">&#9670;&#160;</a></span>box_error_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_error_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the last error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>file name, usually <b>FILE</b> macro </td></tr>
    <tr><td class="paramname">line</td><td>line number in the file, usually <b>LINE</b> macro </td></tr>
    <tr><td class="paramname">code</td><td>IPROTO error code (enum <a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce">box_error_code</a>) </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for convention use</dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce" title="public">box_error_code</a> </dd></dl>

</div>
</div>
<a id="ab3cd4a9f506e56bab2a03475d7b95589" name="ab3cd4a9f506e56bab2a03475d7b95589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cd4a9f506e56bab2a03475d7b95589">&#9670;&#160;</a></span>box_error_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_error_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error type, e.g. </p>
<p>"ClientError", "SocketError", etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>not-null string </dd></dl>

</div>
</div>
<a id="a1fb9d369f674c637b476fd92b00d3da5" name="a1fb9d369f674c637b476fd92b00d3da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb9d369f674c637b476fd92b00d3da5">&#9670;&#160;</a></span>box_ibuf_read_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_ibuf_read_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>rpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>wpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointers to read range pointers used [rpos..wpos) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>ibuf structure </td></tr>
    <tr><td class="paramname">rpos</td><td>where to place ibuf.rpos address </td></tr>
    <tr><td class="paramname">wpos</td><td>where to place ibuf.wpos address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a407327a4c9860b0f088aa677c1a0e7" name="a4a407327a4c9860b0f088aa677c1a0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a407327a4c9860b0f088aa677c1a0e7">&#9670;&#160;</a></span>box_ibuf_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * box_ibuf_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve requested amount of bytes in ibuf buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>buffer used for allocation </td></tr>
    <tr><td class="paramname">size</td><td>allocated bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error, check diag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74b2d0e25c3a295f9ae0200a787c432" name="ac74b2d0e25c3a295f9ae0200a787c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b2d0e25c3a295f9ae0200a787c432">&#9670;&#160;</a></span>box_ibuf_write_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_ibuf_write_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>wpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointers to write range pointers used [wpos..end) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>ibuf structure </td></tr>
    <tr><td class="paramname">wpos</td><td>where to place ibuf.rpos address </td></tr>
    <tr><td class="paramname">end</td><td>where to place ibuf.wpos address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeda3d99d32c382bc5ac2bc8f0a09f48" name="aaeda3d99d32c382bc5ac2bc8f0a09f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda3d99d32c382bc5ac2bc8f0a09f48">&#9670;&#160;</a></span>box_index_bsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_bsize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes used in memory by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=</td><td>0 otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f06a7df9e461267455477bd84ce02ed" name="a3f06a7df9e461267455477bd84ce02ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f06a7df9e461267455477bd84ce02ed">&#9670;&#160;</a></span>box_index_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_count </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramname">type</td><td>iterator type - enum <a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a> </td></tr>
    <tr><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:count(key,</div>
<div class="line">   { iterator = type }) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5c9cedd4198d62ddfe6c77ef2bf89f56" name="a5c9cedd4198d62ddfe6c77ef2bf89f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9cedd4198d62ddfe6c77ef2bf89f56">&#9670;&#160;</a></span>box_index_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a tuple from index by the key. </p>
<p>Please note that this function works much more faster than box_select() or <a class="el" href="module_8h.html#af339d131bfa577606d631f5e4bd82752" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a> + <a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347" title="Retrieve the next item from the iterator.">box_iterator_next()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>key != NULL </dd></dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:get(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4abb8381625fb1364af63d58a0235b3a" name="a4abb8381625fb1364af63d58a0235b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abb8381625fb1364af63d58a0235b3a">&#9670;&#160;</a></span>box_index_id_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_index_id_by_name </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index id by name. </p>
<p>This function performs SELECT request to _vindex system space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">name</td><td>index name </td></tr>
    <tr><td class="paramname">len</td><td>length of <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BOX_ID_NIL</td><td>on error or if not found (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">index_id</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a4a816d0fc386d810b874b50db1f50293" title="Find space id by name.">box_space_id_by_name</a> </dd></dl>

</div>
</div>
<a id="af339d131bfa577606d631f5e4bd82752" name="af339d131bfa577606d631f5e4bd82752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af339d131bfa577606d631f5e4bd82752">&#9670;&#160;</a></span>box_index_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> * box_index_iterator </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize iterator for space_id, index_id. </p>
<p>A returned iterator must be destroyed by <a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c" title="Destroy and deallocate iterator.">box_iterator_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier. </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier. </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator type </a> </td></tr>
    <tr><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramname">key_end</td><td>the end of encoded <em>key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">iterator</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347" title="Retrieve the next item from the iterator.">box_iterator_next()</a> </dd>
<dd>
<a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c" title="Destroy and deallocate iterator.">box_iterator_free()</a> </dd></dl>

</div>
</div>
<a id="a698d8991fa015a4b490f078b29e8d929" name="a698d8991fa015a4b490f078b29e8d929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698d8991fa015a4b490f078b29e8d929">&#9670;&#160;</a></span>box_index_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of element in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=</td><td>0 otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044e5f79addcfd9c7312fe66e7be7514" name="a044e5f79addcfd9c7312fe66e7be7514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e5f79addcfd9c7312fe66e7be7514">&#9670;&#160;</a></span>box_index_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_max </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a last (maximal) tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:max(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4fbd278987613571a9d6475de6103a4f" name="a4fbd278987613571a9d6475de6103a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbd278987613571a9d6475de6103a4f">&#9670;&#160;</a></span>box_index_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_min </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a first (minimal) tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:min(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a10baf3a63a95a208b5a5ee96afa66e4b" name="a10baf3a63a95a208b5a5ee96afa66e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10baf3a63a95a208b5a5ee96afa66e4b">&#9670;&#160;</a></span>box_index_quantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_quantile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin_key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end_key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>quantile_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>quantile_key_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a quantile point in an indexed range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">level</td><td>quantile level </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">begin_key</td><td>beginning key of the target range </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">begin_key_end</td><td>end of <em>begin_key</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end_key</td><td>end key of the target range </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end_key_end</td><td>end of <em>end_key</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quantile_key</td><td>quantile point or NULL if the range is too small </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quantile_key_end</td><td>end of <em>quantile_key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success</td></tr>
  </table>
  </dd>
</dl>
<p>The quantile point is such a key that the ratio of tuples less than the key in the target range approximately equals the given level.</p>
<p><em>begin_key</em> and <em>end_key</em> must be encoded in the MsgPack Array format. The target range is defined as the intersection of GE <em>begin_key</em> and LT <em>end_key</em> read queries.</p>
<p>The quantile point is returned in the MsgPack Array format. It is allocated on the box region so the caller should use <a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4" title="Truncate the box region to the given size.">box_region_truncate()</a> to clean up the region after calling this function. </p>

</div>
</div>
<a id="aa56e2bf2a5720259ea3997149ae53ca9" name="aa56e2bf2a5720259ea3997149ae53ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56e2bf2a5720259ea3997149ae53ca9">&#9670;&#160;</a></span>box_index_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_random </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random tuple from the index (useful for statistical analysis). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rnd</td><td>random seed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:random(rnd) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a08571f03c05abf96fd6e98a590d78822" name="a08571f03c05abf96fd6e98a590d78822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08571f03c05abf96fd6e98a590d78822">&#9670;&#160;</a></span>box_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an INSERT request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id]:insert(tuple) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab554b65cb9819d6e231deaaf1e7874d5" name="ab554b65cb9819d6e231deaaf1e7874d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab554b65cb9819d6e231deaaf1e7874d5">&#9670;&#160;</a></span>box_insert_arrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_insert_arrow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a batch insert request. </p>
<p>A record batch from the Arrow <code>array</code> is inserted into the space columns, whose names are provided by the Arrow <code>schema</code>. Column types in the schema must match the types of the corresponding fields in the space format.</p>
<p>If a column is nullable in space format, it can be omitted. All non-nullable columns (including primary key parts) must be present in the batch.</p>
<p>Both <code>array</code> and <code>schema</code> are moved or released, even on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">array</td><td>input data in ArrowArray format </td></tr>
    <tr><td class="paramname">schema</td><td>definition of the input data in ArrowSchema format </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f6d1752bccac95ed2d154a98c3fe9c7" name="a6f6d1752bccac95ed2d154a98c3fe9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6d1752bccac95ed2d154a98c3fe9c7">&#9670;&#160;</a></span>box_iproto_override()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iproto_override </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>req_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a>&#160;</td>
          <td class="paramname"><em>destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an IPROTO request handler with the provided context for the given request type. </p>
<p>NB: yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_type</td><td>request type code from iproto_type enumeration (src/box/iproto_constants.h); use IPROTO_UNKNOWN for overriding the handler of unknown request types; </td></tr>
    <tr><td class="paramname">handler</td><td>IPROTO request handler; passing NULL resets the corresponding handler </td></tr>
    <tr><td class="paramname">destroy</td><td>IPROTO request handler destructor </td></tr>
    <tr><td class="paramname">ctx</td><td>context passed to handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcef363e704e69cb0cc4efb80c6a648e" name="abcef363e704e69cb0cc4efb80c6a648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcef363e704e69cb0cc4efb80c6a648e">&#9670;&#160;</a></span>box_iproto_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iproto_send </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>body_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a packet with the given header and body over the IPROTO session's socket. </p>
<p>NB: yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>IPROTO session identifier </td></tr>
    <tr><td class="paramname">header</td><td>MsgPack encoded header </td></tr>
    <tr><td class="paramname">header_end</td><td>MsgPack encoded header end </td></tr>
    <tr><td class="paramname">body</td><td>MsgPack encoded body </td></tr>
    <tr><td class="paramname">body_end</td><td>MsgPack encoded body end </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f7fe762b15009de313fdf915378429c" name="a6f7fe762b15009de313fdf915378429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7fe762b15009de313fdf915378429c">&#9670;&#160;</a></span>box_iterator_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_iterator_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and deallocate iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>an iterator returned by <a class="el" href="module_8h.html#af339d131bfa577606d631f5e4bd82752" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4361728e6abe6243e7f02b098e7b347" name="ae4361728e6abe6243e7f02b098e7b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4361728e6abe6243e7f02b098e7b347">&#9670;&#160;</a></span>box_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next item from the <em>iterator</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iterator</td><td>an iterator returned by <a class="el" href="module_8h.html#af339d131bfa577606d631f5e4bd82752" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if there is no more data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> for details) </td></tr>
    <tr><td class="paramname">0</td><td>on success. The end of data is not an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82fdf05e0d276baa072123358c29e046" name="a82fdf05e0d276baa072123358c29e046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fdf05e0d276baa072123358c29e046">&#9670;&#160;</a></span>box_key_def_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_key_def_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>key definition to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b6445ef676ed2dee9b3aa23efebccd8" name="a4b6445ef676ed2dee9b3aa23efebccd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6445ef676ed2dee9b3aa23efebccd8">&#9670;&#160;</a></span>box_key_def_dump_parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> * box_key_def_dump_parts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>part_count_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump key part definitions of given key_def. </p>
<p>The function allocates key parts and storage for pointer fields (e.g. collation names) on the box region. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4" title="Truncate the box region to the given size.">box_region_truncate()</a></dd></dl>
<p>box_key_part_def_t fields that are unknown at given tarantool version are set to zero. The same for unknown <em>flags</em> bits.</p>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="ad06d39b3f4fb10333b555b77d07949d0" name="ad06d39b3f4fb10333b555b77d07949d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06d39b3f4fb10333b555b77d07949d0">&#9670;&#160;</a></span>box_key_def_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> * box_key_def_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate key_def. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Original key_def.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Duplicate of src. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab173f0c441972404f76b0b43d77da401" name="ab173f0c441972404f76b0b43d77da401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173f0c441972404f76b0b43d77da401">&#9670;&#160;</a></span>box_key_def_extract_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * box_key_def_extract_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multikey_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract key from tuple by given key definition and return buffer allocated on the box region with this key. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4" title="Truncate the box region to the given size.">box_region_truncate()</a></dd></dl>
<p>This function has O(n) complexity, where n is the number of key parts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Definition of key that need to extract. </td></tr>
    <tr><td class="paramname">tuple</td><td>Tuple from which need to extract key. </td></tr>
    <tr><td class="paramname">multikey_idx</td><td>Multikey index hint or -1. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of extracted key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Success. </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="ada9eb3e3dc2cdff9ae0dd630cb3b6431" name="ada9eb3e3dc2cdff9ae0dd630cb3b6431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9eb3e3dc2cdff9ae0dd630cb3b6431">&#9670;&#160;</a></span>box_key_def_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> * box_key_def_merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new key_def with a set union of key parts from first and second key defs. </p>
<p>Parts of the new key_def consist of the first key_def's parts and those parts of the second key_def that were not among the first parts.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Ok. </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory error.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a7993cc0cf6aab8047c50911d1e3d91ee" name="a7993cc0cf6aab8047c50911d1e3d91ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7993cc0cf6aab8047c50911d1e3d91ee">&#9670;&#160;</a></span>box_key_def_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> * box_key_def_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>part_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create key definition with given field numbers and field types. </p>
<p>May be used for tuple format creation and/or tuple comparison.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718" title="Create a key_def from given key parts.">box_key_def_new_v2()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>array with key field identifiers </td></tr>
    <tr><td class="paramname">types</td><td>array with key field types (see enum field_type) </td></tr>
    <tr><td class="paramname">part_count</td><td>the number of key fields </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new key definition object </dd></dl>

</div>
</div>
<a id="a0ee0eb2d3a12d2588226a2a232f7b718" name="a0ee0eb2d3a12d2588226a2a232f7b718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee0eb2d3a12d2588226a2a232f7b718">&#9670;&#160;</a></span>box_key_def_new_v2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> * box_key_def_new_v2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td>
          <td class="paramname"><em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>part_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a key_def from given key parts. </p>
<p>Unlike <a class="el" href="module_8h.html#a7993cc0cf6aab8047c50911d1e3d91ee" title="Create key definition with given field numbers and field types.">box_key_def_new()</a> this function allows to define nullability, collation and other options for each key part.</p>
<p>box_key_part_def_t fields that are unknown at given tarantool version are ignored. The same for unknown <em>flags</em> bits.</p>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a237492509ee5f9e478b72077c4c65833" name="a237492509ee5f9e478b72077c4c65833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237492509ee5f9e478b72077c4c65833">&#9670;&#160;</a></span>box_key_def_validate_full_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_full_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a full key against given key definition. </p>
<p>Verifies key parts against given key_def's field types with respect to nullability.</p>
<p>Imposes the same parts count in <em>key</em> as in <em>key_def</em>. Absence of trailing key parts fails the check.</p>
<p>Note: nil is accepted for nullable fields, but only for them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">key</td><td>MessagePack'ed data for matching. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of the validated key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The key is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The key is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid key set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a32868fa25087aa7d7249fd2692a0ac52" name="a32868fa25087aa7d7249fd2692a0ac52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32868fa25087aa7d7249fd2692a0ac52">&#9670;&#160;</a></span>box_key_def_validate_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a key against given key definition. </p>
<p>Verifies key parts against given key_def's field types with respect to nullability.</p>
<p>A partial key (with less part than defined in <em>key_def</em>) is verified by given key parts, the omitted tail is not verified anyhow.</p>
<p>Note: nil is accepted for nullable fields, but only for them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">key</td><td>MessagePack'ed data for matching. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of the validated key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The key is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The key is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid key set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a3c01aea33b0593fd1b84243be7033469" name="a3c01aea33b0593fd1b84243be7033469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c01aea33b0593fd1b84243be7033469">&#9670;&#160;</a></span>box_key_def_validate_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that tuple fields match with given key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">tuple</td><td>Tuple to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The tuple is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The tuple is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid tuple set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a52f751905f893144ead356172137e796" name="a52f751905f893144ead356172137e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f751905f893144ead356172137e796">&#9670;&#160;</a></span>box_key_part_def_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_key_part_def_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a key part with default values. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Details    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fieldno   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">flags   </td><td class="markdownTableBodyNone"><em>default</em> flags   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">field_type   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone">[^1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">collation   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Default flag values are the following:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BOX_KEY_PART_DEF_IS_NULLABLE   </td><td class="markdownTableBodyNone">0 (unset)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BOX_KEY_PART_DEF_EXCLUDE_NULL   </td><td class="markdownTableBodyNone">0 (unset)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BOX_KEY_PART_DEF_SORT_ORDER_DESC   </td><td class="markdownTableBodyNone">0 (unset)   </td></tr>
</table>
<p>Default values of fields and flags are permitted to be changed in future tarantool versions. However we should be VERY conservative here and consider any meaningful usage scenarios, when doing so. At least new defaults should be consistent with how tarantool itself doing key_def related operations: validation, key extraction, comparisons and so on.</p>
<p>All trailing padding bytes are set to zero. The same for unknown <em>flags</em> bits.</p>
<p>[^1]: <a class="el" href="module_8h.html#a0ee0eb2d3a12d2588226a2a232f7b718" title="Create a key_def from given key parts.">box_key_def_new_v2()</a> does not accept NULL as a <em>field_type</em>, so it should be filled explicitly. </p>

</div>
</div>
<a id="a83a897e7386e946cd5ffd2ea1cb47a52" name="a83a897e7386e946cd5ffd2ea1cb47a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a897e7386e946cd5ffd2ea1cb47a52">&#9670;&#160;</a></span>box_latch_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and free the latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef397199dd9a19cb7b9362233a1d4a98" name="aef397199dd9a19cb7b9362233a1d4a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef397199dd9a19cb7b9362233a1d4a98">&#9670;&#160;</a></span>box_latch_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a latch. </p>
<p>Waits indefinitely until the current fiber can gain access to the latch. Locks are acquired in the strict order as they were requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b81bda5be3fd39b8d076cd048e83b67" name="a6b81bda5be3fd39b8d076cd048e83b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b81bda5be3fd39b8d076cd048e83b67">&#9670;&#160;</a></span>box_latch_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> * box_latch_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the new latch. </p>
<dl class="section return"><dt>Returns</dt><dd>latch </dd></dl>

</div>
</div>
<a id="a294e53c819e91f172428d580a29f434f" name="a294e53c819e91f172428d580a29f434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294e53c819e91f172428d580a29f434f">&#9670;&#160;</a></span>box_latch_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_latch_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a latch. </p>
<p>Return immediately if the latch is locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">1</td><td>- the latch is locked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11dea9d7a0347d38956ed59f739c68ca" name="a11dea9d7a0347d38956ed59f739c68ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dea9d7a0347d38956ed59f739c68ca">&#9670;&#160;</a></span>box_latch_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a latch. </p>
<p>The fiber calling this function must own the latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a35d7a7fe53c673112e06ab78794216" name="a4a35d7a7fe53c673112e06ab78794216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a35d7a7fe53c673112e06ab78794216">&#9670;&#160;</a></span>box_on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_on_shutdown </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>new_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>old_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statement Attributes }}}. </p>
<p>public Function, which registers or deletes on_shutdown handler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>on_shutdown function's argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_handler</td><td>New on_shutdown handler, in case this argument is NULL, function finds and destroys old on_shutdown handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_handler</td><td>Old on_shutdown handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">return</td><td>0 if success otherwise return -1 and sets errno. There are three cases when function fails:<ul>
<li>both old_handler and new_handler are equal to zero (sets errno to EINVAL).</li>
<li>old_handler != NULL, but there is no trigger with such function (sets errno to EINVAL).</li>
<li>malloc for some internal struct memory allocation return NULL (errno sets by malloc to ENOMEM). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a751fd698cbeca02ecca506f2fcdb1c60" name="a751fd698cbeca02ecca506f2fcdb1c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751fd698cbeca02ecca506f2fcdb1c60">&#9670;&#160;</a></span>box_region_aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * box_region_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate size bytes from the box region with given alignment. </p>
<p>Alignment must be a power of 2.</p>
<p>In case of a memory error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>. </dd></dl>

</div>
</div>
<a id="a1e232fab2a9b3f2362bde6f03b83f67b" name="a1e232fab2a9b3f2362bde6f03b83f67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e232fab2a9b3f2362bde6f03b83f67b">&#9670;&#160;</a></span>box_region_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * box_region_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate size bytes from the box region. </p>
<p>Don't use this function to allocate a memory block for a value or array of values of a type with alignment requirements. A violation of alignment requirements leads to undefined behaviour.</p>
<p>In case of a memory error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>. </dd></dl>

</div>
</div>
<a id="a113af82955ade6d52b5a03fc327b266f" name="a113af82955ade6d52b5a03fc327b266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113af82955ade6d52b5a03fc327b266f">&#9670;&#160;</a></span>box_region_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t box_region_used </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>box region allocator </p>
<p>It is the region allocator from the small library. It is useful for allocating tons of small objects and free them at once.</p>
<p>Typical usage is illustrated in the sketch below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> region_svp = <a class="code hl_function" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">box_region_used</a>();</div>
<div class="line"><span class="keywordflow">while</span> (&lt;...&gt;) {</div>
<div class="line">    <span class="keywordtype">char</span> *buf = <a class="code hl_function" href="module_8h.html#a1e232fab2a9b3f2362bde6f03b83f67b">box_region_alloc</a>(&lt;...&gt;);</div>
<div class="line">    &lt;...&gt;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4">box_region_truncate</a>(region_svp);</div>
<div class="ttc" id="amodule_8h_html_a113af82955ade6d52b5a03fc327b266f"><div class="ttname"><a href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">box_region_used</a></div><div class="ttdeci">size_t box_region_used(void)</div><div class="ttdoc">box region allocator</div></div>
<div class="ttc" id="amodule_8h_html_a1e232fab2a9b3f2362bde6f03b83f67b"><div class="ttname"><a href="module_8h.html#a1e232fab2a9b3f2362bde6f03b83f67b">box_region_alloc</a></div><div class="ttdeci">void * box_region_alloc(size_t size)</div><div class="ttdoc">Allocate size bytes from the box region.</div></div>
<div class="ttc" id="amodule_8h_html_a6575301cf1bd4df1bfad9a319b80a0b4"><div class="ttname"><a href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4">box_region_truncate</a></div><div class="ttdeci">void box_region_truncate(size_t size)</div><div class="ttdoc">Truncate the box region to the given size.</div></div>
</div><!-- fragment --><p>There are module API functions that return a result on this region. In this case a caller is responsible to free the result:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> region_svp = <a class="code hl_function" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">box_region_used</a>();</div>
<div class="line"><span class="keywordtype">char</span> *buf = box_&lt;...&gt;(&lt;...&gt;);</div>
<div class="line">&lt;...&gt;</div>
<div class="line"><a class="code hl_function" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4">box_region_truncate</a>(region_svp);</div>
</div><!-- fragment --><p>This API provides better compatibility guarantees over using the small library directly in a module. A binary layout of internal structures may be changed in a future, but &lt;box_region_*&gt;() functions will remain API and ABI compatible.</p>
<p>Each fiber has its own box region. It means that a call of, say, <a class="el" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f" title="box region allocator">box_region_used()</a> will give its own value in different fibers. It also means that a yield does not invalidate data in the box region.</p>
<p>Prior to version 2.11, the box region was implicitly cleaned up on transaction commit (see <a class="el" href="module_8h.html#a541c69864552de6ae21c4edce2bbf949" title="Commit the current transaction.">box_txn_commit()</a>) so that <a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4" title="Truncate the box region to the given size.">box_region_truncate()</a> wasn't strictly necessary. Starting from version 2.11, it isn't true anymore, and the client code must free all its allocations explicitly. How much memory is used by the box region. </p>

</div>
</div>
<a id="a933b6e9cbf9d4fc05e3964b0949b5bd0" name="a933b6e9cbf9d4fc05e3964b0949b5bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933b6e9cbf9d4fc05e3964b0949b5bd0">&#9670;&#160;</a></span>box_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_replace </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an REPLACE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id]:replace(tuple) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a96bf7ae13f994a18d2f9dcf7816578ca" name="a96bf7ae13f994a18d2f9dcf7816578ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf7ae13f994a18d2f9dcf7816578ca">&#9670;&#160;</a></span>box_return_mp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_return_mp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mp_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return MessagePack from a stored C procedure. </p>
<p>The MessagePack is copied, so it is safe to free/reuse the passed arguments after the call. MessagePack is not validated, for the sake of speed. It is expected to be a single encoded object. An attempt to encode and return multiple objects without wrapping them into an MP_ARRAY or MP_MAP is undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An opaque structure passed to the stored C procedure by Tarantool. </td></tr>
    <tr><td class="paramname">mp</td><td>Begin of MessagePack. </td></tr>
    <tr><td class="paramname">mp_end</td><td>End of MessagePack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>Error. </td></tr>
    <tr><td class="paramname">0</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb00cd4eac4d388d58e9e5ef1ea1b3f" name="a7fb00cd4eac4d388d58e9e5ef1ea1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb00cd4eac4d388d58e9e5ef1ea1b3f">&#9670;&#160;</a></span>box_return_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_return_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tuple from stored C procedure. </p>
<p>Returned tuple is automatically reference counted by Tarantool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>an opaque structure passed to the stored C procedure by Tarantool </td></tr>
    <tr><td class="paramname">tuple</td><td>a tuple to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (perhaps, out of memory; check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d96086f343e0739efabf43174a3fa35" name="a1d96086f343e0739efabf43174a3fa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d96086f343e0739efabf43174a3fa35">&#9670;&#160;</a></span>box_ro_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_ro_reason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Get the reason why the instance is read only if it is. Can't be called on a writable instance. </p>

</div>
</div>
<a id="a8b1e8f1e92bb906daefd5666e0ff2f4d" name="a8b1e8f1e92bb906daefd5666e0ff2f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1e8f1e92bb906daefd5666e0ff2f4d">&#9670;&#160;</a></span>box_schema_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t box_schema_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Returns the current version of the database schema, an unsigned number that goes up when there is a major change in the schema, i.e., on DDL operations. </p><dl class="section see"><dt>See also</dt><dd>IPROTO_SCHEMA_VERSION </dd></dl>

</div>
</div>
<a id="a66ac5f1357a07acaae764e5d2e2e55fa" name="a66ac5f1357a07acaae764e5d2e2e55fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ac5f1357a07acaae764e5d2e2e55fa">&#9670;&#160;</a></span>box_sequence_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_current </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last value returned by a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to a variable where the current sequence value will be stored on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e5fd9116818749f73bf868d4e780256" name="a3e5fd9116818749f73bf868d4e780256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5fd9116818749f73bf868d4e780256">&#9670;&#160;</a></span>box_sequence_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_next </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to a variable where the next sequence value will be stored on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9c3210df64b1f6fd89eb2c5e088e94" name="a8f9c3210df64b1f6fd89eb2c5e088e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c3210df64b1f6fd89eb2c5e088e94">&#9670;&#160;</a></span>box_sequence_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_reset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2243f60e2773d3522a540103f645110" name="ac2243f60e2773d3522a540103f645110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2243f60e2773d3522a540103f645110">&#9670;&#160;</a></span>box_sequence_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a sequence value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramname">value</td><td>new sequence value; on success the next call to <a class="el" href="module_8h.html#a3e5fd9116818749f73bf868d4e780256" title="Advance a sequence.">box_sequence_next()</a> will return the value following <em>value</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a6ea7f0c101d1986f27de9f8ec25c8" name="a14a6ea7f0c101d1986f27de9f8ec25c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a6ea7f0c101d1986f27de9f8ec25c8">&#9670;&#160;</a></span>box_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t box_session_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current session's unique monotonic identifier </dd></dl>
<dl class="section see"><dt>See also</dt><dd>box.session.id </dd></dl>

</div>
</div>
<a id="a0e9c91d463ce4aca081e5bd376aac1d9" name="a0e9c91d463ce4aca081e5bd376aac1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9c91d463ce4aca081e5bd376aac1d9">&#9670;&#160;</a></span>box_session_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_session_push </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push MessagePack data into a session data channel - socket, console or whatever is behind the session. </p>
<p>Note, that successful push does not guarantee delivery in case it was sent into the network. Just like with write()/send() system calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>begin of MessagePack to push </td></tr>
    <tr><td class="paramname">data_end</td><td>end of MessagePack to push </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a816d0fc386d810b874b50db1f50293" name="a4a816d0fc386d810b874b50db1f50293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a816d0fc386d810b874b50db1f50293">&#9670;&#160;</a></span>box_space_id_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_space_id_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find space id by name. </p>
<p>This function performs SELECT request to _vspace system space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>space name </td></tr>
    <tr><td class="paramname">len</td><td>length of <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BOX_ID_NIL</td><td>on error or if not found (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">space_id</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a4abb8381625fb1364af63d58a0235b3a" title="Find index id by name.">box_index_id_by_name</a> </dd></dl>

</div>
</div>
<a id="aea52506f29df1be0ad66721617c7452f" name="aea52506f29df1be0ad66721617c7452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea52506f29df1be0ad66721617c7452f">&#9670;&#160;</a></span>box_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>The current status of the instance. It is either "running", "loading", "orphan" or "hot_standby". See box.info.status Lua API for the reference. </p>

</div>
</div>
<a id="a20de21b171ded688588f1063ac04a9d3" name="a20de21b171ded688588f1063ac04a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20de21b171ded688588f1063ac04a9d3">&#9670;&#160;</a></span>box_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_truncate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6812d20a87dc1f55648679680d0d2272" name="a6812d20a87dc1f55648679680d0d2272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6812d20a87dc1f55648679680d0d2272">&#9670;&#160;</a></span>box_tuple_bsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t box_tuple_bsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes used to store internal tuple data (MsgPack Array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b978e168708341cb358a15c5e42430" name="a88b978e168708341cb358a15c5e42430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b978e168708341cb358a15c5e42430">&#9670;&#160;</a></span>box_tuple_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare tuples using the key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_a</td><td>first tuple </td></tr>
    <tr><td class="paramname">tuple_b</td><td>second tuple </td></tr>
    <tr><td class="paramname">key_def</td><td>key definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if key_fields(tuple_a) == key_fields(tuple_b) </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if key_fields(tuple_a) &lt; key_fields(tuple_b) </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if key_fields(tuple_a) &gt; key_fields(tuple_b) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8fec3862fabe2eb885bb71517b99a5f" name="ae8fec3862fabe2eb885bb71517b99a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fec3862fabe2eb885bb71517b99a5f">&#9670;&#160;</a></span>box_tuple_compare_with_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_compare_with_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare tuple with key using the key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_a</td><td>tuple </td></tr>
    <tr><td class="paramname">key_b</td><td>key with MessagePack array header </td></tr>
    <tr><td class="paramname">key_def</td><td>key definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if key_fields(tuple) == parts(key) </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if key_fields(tuple) &lt; parts(key) </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if key_fields(tuple) &gt; parts(key) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bf51406abdaed2efa950aa428ca3ad1" name="a0bf51406abdaed2efa950aa428ca3ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf51406abdaed2efa950aa428ca3ad1">&#9670;&#160;</a></span>box_tuple_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_tuple_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the pointer to the raw tuple MsgPack Array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple. </td></tr>
    <tr><td class="paramname">bsize</td><td>will be set to the number of bytes of raw MsgPack data if not NULL provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8452d35ca52bc3147b129f8d46c35ef1" name="a8452d35ca52bc3147b129f8d46c35ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8452d35ca52bc3147b129f8d46c35ef1">&#9670;&#160;</a></span>box_tuple_extract_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * box_tuple_extract_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract key from tuple according to key definition of given index. </p>
<p>Returned buffer is allocated on <a class="el" href="module_8h.html#a6d157a0b9ff004736c655db785486447" title="Allocate memory on txn memory pool.">box_txn_alloc()</a> with this key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>Tuple from which need to extract key. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>Space identifier. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>Index identifier. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key_size</td><td>where to store the size of the extracted key; pass NULL here if it is not needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Success </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory Allocation error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae249982b4154dfbc763fa6b4c9dc5aa6" name="ae249982b4154dfbc763fa6b4c9dc5aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae249982b4154dfbc763fa6b4c9dc5aa6">&#9670;&#160;</a></span>box_tuple_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_tuple_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fieldno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the raw tuple field in MsgPack format. </p>
<p>The buffer is valid until next call to box_tuple_* functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
    <tr><td class="paramname">fieldno</td><td>zero-based index in MsgPack array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if i &gt;= box_tuple_field_count(tuple) </td></tr>
    <tr><td class="paramname">msgpack</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a935e8bc08352e18e941326d6118b4dbd" name="a935e8bc08352e18e941326d6118b4dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935e8bc08352e18e941326d6118b4dbd">&#9670;&#160;</a></span>box_tuple_field_by_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_tuple_field_by_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a raw tuple field in the MsgPack format pointed by a JSON path. </p>
<p>The JSON path includes the outmost field. For example, "c" in ["a", ["b", "c"], "d"] can be accessed using "[2][2]" path (if index_base is 1, as in Lua). If index_base is set to 0, the same field will be pointed by the "[1][1]" path.</p>
<p>The first JSON path token may be a field name if the tuple has associated format with named fields. A field of a nested map can be accessed in the same way: "foo.bar" or ".foo.bar".</p>
<p>The return value is valid until the tuple is destroyed, see <a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a>.</p>
<p>Return NULL if the field does not exist or if the JSON path is malformed or invalid. Multikey JSON path token [*] is treated as invalid in this context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
    <tr><td class="paramname">path</td><td>a JSON path </td></tr>
    <tr><td class="paramname">path_len</td><td>a length of <em>path</em> </td></tr>
    <tr><td class="paramname">index_base</td><td>0 if array element indexes in <em>path</em> are zero-based (like in C) or 1 if they're one-based (like in Lua) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>pointer to a field data if the field exists or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a800d61b749ed483d35b65025eaa3039e" name="a800d61b749ed483d35b65025eaa3039e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800d61b749ed483d35b65025eaa3039e">&#9670;&#160;</a></span>box_tuple_field_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_tuple_field_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of fields in tuple (the size of MsgPack Array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb5de2d649fd56eacbe7d734643620ea" name="afb5de2d649fd56eacbe7d734643620ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5de2d649fd56eacbe7d734643620ea">&#9670;&#160;</a></span>box_tuple_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> * box_tuple_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the associated format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple_format </dd></dl>

</div>
</div>
<a id="ad42ff178dd0ab620350f84d8cde8a341" name="ad42ff178dd0ab620350f84d8cde8a341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42ff178dd0ab620350f84d8cde8a341">&#9670;&#160;</a></span>box_tuple_format_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> * box_tuple_format_default </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tuple Format. </p>
<p>Each Tuple has associated format (class). Default format is used to create tuples which are not attach to any particular space. </p>

</div>
</div>
<a id="a20436be4bf694001c205489cca0d9d45" name="a20436be4bf694001c205489cca0d9d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20436be4bf694001c205489cca0d9d45">&#9670;&#160;</a></span>box_tuple_format_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> * box_tuple_format_new </td>
          <td>(</td>
          <td class="paramtype">struct key_def **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Return new in-memory tuple format based on passed key definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>array of keys defined for the format </td></tr>
    <tr><td class="paramname">key_count</td><td>count of keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">new</td><td>tuple format if success </td></tr>
    <tr><td class="paramname">NULL</td><td>for error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc998b676589a854eaf71e2e1fd4debc" name="acc998b676589a854eaf71e2e1fd4debc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc998b676589a854eaf71e2e1fd4debc">&#9670;&#160;</a></span>box_tuple_format_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_format_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment tuple format ref count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the tuple format to ref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134eab27cb960c030d553d3881d8d074" name="a134eab27cb960c030d553d3881d8d074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134eab27cb960c030d553d3881d8d074">&#9670;&#160;</a></span>box_tuple_format_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_format_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement tuple format ref count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the tuple format to unref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5812aa63732b19983fe43c7b436afc2" name="af5812aa63732b19983fe43c7b436afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5812aa63732b19983fe43c7b436afc2">&#9670;&#160;</a></span>box_tuple_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> * box_tuple_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new tuple iterator. </p>
<p>The tuple iterator allow to iterate over fields at root level of MsgPack array.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="module_8h.html#af5812aa63732b19983fe43c7b436afc2">box_tuple_iterator</a> *it = <a class="code hl_function" href="module_8h.html#af5812aa63732b19983fe43c7b436afc2">box_tuple_iterator</a>(tuple);</div>
<div class="line"><span class="keywordflow">if</span> (it == NULL) {</div>
<div class="line">     <span class="comment">// error handling using box_error_last()</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *field;</div>
<div class="line"><span class="keywordflow">while</span> (field = <a class="code hl_function" href="module_8h.html#ac80dc63e3007553d4952681f97966146">box_tuple_next</a>(it)) {</div>
<div class="line">     <span class="comment">// process raw MsgPack data</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rewind iterator to first position</span></div>
<div class="line"><a class="code hl_function" href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a>(it);</div>
<div class="line">assert(<a class="code hl_function" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a>(it) == 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rewind iterator to first position</span></div>
<div class="line">field = <a class="code hl_function" href="module_8h.html#ad7ab5877a484f94d7454b25737bd11df">box_tuple_seek</a>(it, 3);</div>
<div class="line">assert(<a class="code hl_function" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a>(it) == 4);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a>(it);</div>
<div class="ttc" id="amodule_8h_html_a6f7fe762b15009de313fdf915378429c"><div class="ttname"><a href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a></div><div class="ttdeci">void box_iterator_free(box_iterator_t *iterator)</div><div class="ttdoc">Destroy and deallocate iterator.</div></div>
<div class="ttc" id="amodule_8h_html_aaa998b89aa550c51d8576d3b766d1a67"><div class="ttname"><a href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a></div><div class="ttdeci">void box_tuple_rewind(box_tuple_iterator_t *it)</div><div class="ttdoc">Rewind iterator to the initial position.</div></div>
<div class="ttc" id="amodule_8h_html_ac24865c6c4138cd6a252f32c55c812c6"><div class="ttname"><a href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a></div><div class="ttdeci">uint32_t box_tuple_position(box_tuple_iterator_t *it)</div><div class="ttdoc">Return zero-based next position in iterator.</div></div>
<div class="ttc" id="amodule_8h_html_ac80dc63e3007553d4952681f97966146"><div class="ttname"><a href="module_8h.html#ac80dc63e3007553d4952681f97966146">box_tuple_next</a></div><div class="ttdeci">const char * box_tuple_next(box_tuple_iterator_t *it)</div><div class="ttdoc">Return the next tuple field from tuple iterator.</div></div>
<div class="ttc" id="amodule_8h_html_ad7ab5877a484f94d7454b25737bd11df"><div class="ttname"><a href="module_8h.html#ad7ab5877a484f94d7454b25737bd11df">box_tuple_seek</a></div><div class="ttdeci">const char * box_tuple_seek(box_tuple_iterator_t *it, uint32_t fieldno)</div><div class="ttdoc">Seek the tuple iterator.</div></div>
<div class="ttc" id="amodule_8h_html_af5812aa63732b19983fe43c7b436afc2"><div class="ttname"><a href="module_8h.html#af5812aa63732b19983fe43c7b436afc2">box_tuple_iterator</a></div><div class="ttdeci">box_tuple_iterator_t * box_tuple_iterator(box_tuple_t *tuple)</div><div class="ttdoc">Allocate and initialize a new tuple iterator.</div></div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == 0 </dd></dl>

</div>
</div>
<a id="a283636709357b346d38a44345a0a7297" name="a283636709357b346d38a44345a0a7297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283636709357b346d38a44345a0a7297">&#9670;&#160;</a></span>box_tuple_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * box_tuple_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new tuple from a raw MsgPack Array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>tuple format. Use <a class="el" href="module_8h.html#ad42ff178dd0ab620350f84d8cde8a341" title="Tuple Format.">box_tuple_format_default()</a> to create space-independent tuple. </td></tr>
    <tr><td class="paramname">data</td><td>tuple data in MsgPack Array format ([field1, field2, ...]). </td></tr>
    <tr><td class="paramname">end</td><td>the end of <em>data</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tuple</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>data, end is valid MsgPack Array </dd></dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.tuple.new(data) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac80dc63e3007553d4952681f97966146" name="ac80dc63e3007553d4952681f97966146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80dc63e3007553d4952681f97966146">&#9670;&#160;</a></span>box_tuple_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_tuple_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next tuple field from tuple iterator. </p>
<p>The returned buffer is valid until next call to box_tuple_* API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if there are no more fields. </td></tr>
    <tr><td class="paramname">MsgPack</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>box_tuple_position(it) is zero-based id of returned field </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == box_tuple_field_count(tuple) if returned value is NULL. </dd></dl>

</div>
</div>
<a id="ac24865c6c4138cd6a252f32c55c812c6" name="ac24865c6c4138cd6a252f32c55c812c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24865c6c4138cd6a252f32c55c812c6">&#9670;&#160;</a></span>box_tuple_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_tuple_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return zero-based next position in iterator. </p>
<p>That is, this function return the field id of field that will be returned by the next call to <a class="el" href="module_8h.html#ac80dc63e3007553d4952681f97966146" title="Return the next tuple field from tuple iterator.">box_tuple_next()</a>. Returned value is zero after initialization or rewind and <a class="el" href="module_8h.html#a800d61b749ed483d35b65025eaa3039e" title="Return the number of fields in tuple (the size of MsgPack Array).">box_tuple_field_count()</a> after the end of iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position. </dd></dl>

</div>
</div>
<a id="a2211f2682d19f564c55f2888e35d6430" name="a2211f2682d19f564c55f2888e35d6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2211f2682d19f564c55f2888e35d6430">&#9670;&#160;</a></span>box_tuple_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the reference counter of tuple. </p>
<p>Tuples are reference counted. All functions that return tuples guarantee that the last returned tuple is refcounted internally until the next call to API function that yields or returns another tuple.</p>
<p>You should increase the reference counter before taking tuples for long processing in your code. Such tuples will not be garbage collected even if another fiber remove they from space. After processing please decrement the reference counter using <a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc" title="Decrease the reference counter of tuple.">box_tuple_unref()</a>, otherwise the tuple will leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>always </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc" title="Decrease the reference counter of tuple.">box_tuple_unref()</a> </dd></dl>

</div>
</div>
<a id="aaa998b89aa550c51d8576d3b766d1a67" name="aaa998b89aa550c51d8576d3b766d1a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa998b89aa550c51d8576d3b766d1a67">&#9670;&#160;</a></span>box_tuple_rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind iterator to the initial position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == 0 </dd></dl>

</div>
</div>
<a id="ad7ab5877a484f94d7454b25737bd11df" name="ad7ab5877a484f94d7454b25737bd11df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ab5877a484f94d7454b25737bd11df">&#9670;&#160;</a></span>box_tuple_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * box_tuple_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fieldno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek the tuple iterator. </p>
<p>The returned buffer is valid until next call to box_tuple_* API. Requested fieldno returned by next call to <a class="el" href="module_8h.html#ac80dc63e3007553d4952681f97966146" title="Return the next tuple field from tuple iterator.">box_tuple_next()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
    <tr><td class="paramname">fieldno</td><td>- zero-based position in MsgPack array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == fieldno if returned value is not NULL </dd>
<dd>
box_tuple_position(it) == box_tuple_field_count(tuple) if returned value is NULL. </dd></dl>

</div>
</div>
<a id="af520a6742b61a5bcb879b75d09d72f4e" name="af520a6742b61a5bcb879b75d09d72f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af520a6742b61a5bcb879b75d09d72f4e">&#9670;&#160;</a></span>box_tuple_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_tuple_to_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump raw MsgPack data to the memory buffer <em>buf</em> of size <em>size</em>. </p>
<p>Store tuple fields in the memory buffer. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error. </td></tr>
    <tr><td class="paramname">number</td><td>of bytes written on success. Upon successful return, the function returns the number of bytes written. If buffer size is not enough then the return value is the number of bytes which would have been written if enough space had been available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d7b12b1afbff0c3cc20726c10cc6cc" name="a22d7b12b1afbff0c3cc20726c10cc6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d7b12b1afbff0c3cc20726c10cc6cc">&#9670;&#160;</a></span>box_tuple_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the reference counter of tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a> </dd></dl>

</div>
</div>
<a id="a7828361e1999ca87deec4dba0edf0a96" name="a7828361e1999ca87deec4dba0edf0a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7828361e1999ca87deec4dba0edf0a96">&#9670;&#160;</a></span>box_tuple_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * box_tuple_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a tuple. </p>
<p>Function returns a copy of tuple with updated fields. Pay attention that original tuple is left without changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple to update. </td></tr>
    <tr><td class="paramname">expr</td><td>MessagePack array of operations. </td></tr>
    <tr><td class="paramname">expr_end</td><td>End of the <em>expr</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The tuple was not updated. </td></tr>
    <tr><td class="paramname">box_tuple_t</td><td>A copy of original tuple with updated fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a" title="Execute an UPDATE request.">box_update()</a> </dd></dl>

</div>
</div>
<a id="adc32bd58e9b190a5857d022e568743c1" name="adc32bd58e9b190a5857d022e568743c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc32bd58e9b190a5857d022e568743c1">&#9670;&#160;</a></span>box_tuple_upsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * box_tuple_upsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a tuple. </p>
<p>The same as <a class="el" href="module_8h.html#a7828361e1999ca87deec4dba0edf0a96" title="Update a tuple.">box_tuple_update()</a>, but ignores errors. In case of an error the tuple is left intact, but an error message is printed. Only client errors are ignored, such as a bad field type, or wrong field index/name. System errors, such as OOM, are not ignored and raised just like with a normal <a class="el" href="module_8h.html#a7828361e1999ca87deec4dba0edf0a96" title="Update a tuple.">box_tuple_update()</a>. Note that only bad operations are ignored. All correct operations are applied.</p>
<p>Despite the function name (upsert, update and insert), the function does not insert any tuple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple to update. </td></tr>
    <tr><td class="paramname">expr</td><td>MessagePack array of operations. </td></tr>
    <tr><td class="paramname">expr_end</td><td>End of the <em>expr</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The tuple was not updated. </td></tr>
    <tr><td class="paramname">box_tuple_t</td><td>A copy of original tuple with updated fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84" title="Execute an UPSERT request.">box_upsert()</a> </dd></dl>

</div>
</div>
<a id="a8f05611324090cd538b14e0728cf185a" name="a8f05611324090cd538b14e0728cf185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05611324090cd538b14e0728cf185a">&#9670;&#160;</a></span>box_tuple_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check tuple data correspondence to the space format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple to validate. </td></tr>
    <tr><td class="paramname">format</td><td>Format to which the tuple must match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The tuple is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The tuple is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d157a0b9ff004736c655db785486447" name="a6d157a0b9ff004736c655db785486447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d157a0b9ff004736c655db785486447">&#9670;&#160;</a></span>box_txn_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * box_txn_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory on txn memory pool. </p>
<p>The memory is automatically deallocated when the transaction is committed or rolled back.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88346fff21ac55ecf5e8e7e8750093ce" name="a88346fff21ac55ecf5e8e7e8750093ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88346fff21ac55ecf5e8e7e8750093ce">&#9670;&#160;</a></span>box_txn_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin a transaction in the current fiber. </p>
<p>A transaction is attached to caller fiber, therefore one fiber can have only one active transaction.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">-1</td><td>- failed, perhaps a transaction has already been started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a541c69864552de6ae21c4edce2bbf949" name="a541c69864552de6ae21c4edce2bbf949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541c69864552de6ae21c4edce2bbf949">&#9670;&#160;</a></span>box_txn_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_commit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the current transaction. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">-1</td><td>- failed, perhaps a disk write failure. started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94bf484fef1147b9e53323cd5082b505" name="a94bf484fef1147b9e53323cd5082b505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bf484fef1147b9e53323cd5082b505">&#9670;&#160;</a></span>box_txn_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t box_txn_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Transaction id - a non-persistent unique identifier of the current transaction. -1 if there is no current transaction. </p>

</div>
</div>
<a id="ab434c9ba079ac5578be4699220b1860f" name="ab434c9ba079ac5578be4699220b1860f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab434c9ba079ac5578be4699220b1860f">&#9670;&#160;</a></span>box_txn_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_isolation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get isolation level of current transaction, one of enum txn_isolation_level values (but cannot be TXN_ISOLATION_DEFAULT (which is zero) by design). </p>
<p>-1 if there is no current transaction. </p>

</div>
</div>
<a id="a59188d28eb2a8cd892d48f74041fec45" name="a59188d28eb2a8cd892d48f74041fec45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59188d28eb2a8cd892d48f74041fec45">&#9670;&#160;</a></span>box_txn_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_rollback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rollback the current transaction. </p>
<p>May fail if called from a nested statement. </p>

</div>
</div>
<a id="a8a24686e9b0f80d53ded039aa69dfd33" name="a8a24686e9b0f80d53ded039aa69dfd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24686e9b0f80d53ded039aa69dfd33">&#9670;&#160;</a></span>box_txn_set_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_set_isolation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an isolation <em>level</em> for a transaction. </p>
<p>Must be called before the first DML. The level must be of enun txn_isolation_level values. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if success </td></tr>
    <tr><td class="paramname">-1</td><td>if failed, diag is set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e930976f6e8e73e213f701c3761fce4" name="a3e930976f6e8e73e213f701c3761fce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e930976f6e8e73e213f701c3761fce4">&#9670;&#160;</a></span>box_txn_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_set_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>timeout</em> for transaction, when it expires, transaction will be rolled back. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if success </td></tr>
    <tr><td class="paramname">-1</td><td>if timeout is less than or equal to 0, there is no current transaction or rollback timer for current transaction is already started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9badf4d5cc54e424a157439fcb58b96a" name="a9badf4d5cc54e424a157439fcb58b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9badf4d5cc54e424a157439fcb58b96a">&#9670;&#160;</a></span>box_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_update </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an UPDATE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops</td><td>encoded operations in MsgPack Array format, e.g. [ [ '=', fieldno, value ], ['!', 2, 'xxx'] ] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops_end</td><td>the end of encoded <em>ops</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_base</td><td>0 if fieldnos in update operations are zero-based indexed (like C) or 1 if for one-based indexed field ids (like Lua). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:update(key, ops) </div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84" title="Execute an UPSERT request.">box_upsert()</a> </dd></dl>

</div>
</div>
<a id="a268a03389cd856206f0ddfc90f3cbf84" name="a268a03389cd856206f0ddfc90f3cbf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268a03389cd856206f0ddfc90f3cbf84">&#9670;&#160;</a></span>box_upsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_upsert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an UPSERT request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops</td><td>encoded operations in MsgPack Array format, e.g. [ [ '=', fieldno, value ], ['!', 2, 'xxx'] ] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops_end</td><td>the end of encoded <em>ops</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_base</td><td>0 if fieldnos in update operations are zero-based indexed (like C) or 1 if for one-based indexed field ids (like Lua). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:update(key, ops) </div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a" title="Execute an UPDATE request.">box_update()</a> </dd></dl>

</div>
</div>
<a id="adf6a73f9ce8d72029ea976cf2999ba30" name="adf6a73f9ce8d72029ea976cf2999ba30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6a73f9ce8d72029ea976cf2999ba30">&#9670;&#160;</a></span>box_wait_ro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_wait_ro </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Wait until the instance switches to a desired mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ro</td><td>wait read-only if set or read-write if unset </td></tr>
    <tr><td class="paramname">timeout</td><td>max time to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>timeout or fiber is cancelled </td></tr>
    <tr><td class="paramname">0</td><td>success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35900530fb24b7e882c37016b01603aa" name="a35900530fb24b7e882c37016b01603aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35900530fb24b7e882c37016b01603aa">&#9670;&#160;</a></span>clock_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_monotonic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A nonsettable system-wide clock that represents monotonic time. </p>
<dl class="section see"><dt>See also</dt><dd>clock_gettime(2), CLOCK_MONOTONIC. </dd></dl>

</div>
</div>
<a id="a7ecf77597c056216e310c34951bf21b9" name="a7ecf77597c056216e310c34951bf21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecf77597c056216e310c34951bf21b9">&#9670;&#160;</a></span>clock_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A clock that measures CPU time consumed by this process (by all threads in the process). </p>
<dl class="section see"><dt>See also</dt><dd>clock_gettime(2), CLOCK_PROCESS_CPUTIME_ID. </dd></dl>

</div>
</div>
<a id="a82b915cd0f2fbf8da0031594334d1161" name="a82b915cd0f2fbf8da0031594334d1161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b915cd0f2fbf8da0031594334d1161">&#9670;&#160;</a></span>clock_realtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_realtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>A settable system-wide clock that measures real (i.e., wall-clock) time.</p>
<dl class="section see"><dt>See also</dt><dd>clock_gettime(2), CLOCK_REALTIME. </dd></dl>

</div>
</div>
<a id="aac6c5ad4ed25168dd171bd2f9d112d0d" name="aac6c5ad4ed25168dd171bd2f9d112d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6c5ad4ed25168dd171bd2f9d112d0d">&#9670;&#160;</a></span>clock_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A clock that measures CPU time consumed by this thread. </p>
<dl class="section see"><dt>See also</dt><dd>clock_gettime(2), CLOCK_THREAD_CPUTIME_ID. </dd></dl>

</div>
</div>
<a id="af9433c7d42d7747f1f69b79a0d98df13" name="af9433c7d42d7747f1f69b79a0d98df13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9433c7d42d7747f1f69b79a0d98df13">&#9670;&#160;</a></span>coio_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t coio_call </td>
          <td>(</td>
          <td class="paramtype">ssize_t(*)(va_list)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Create new eio task with specified function and arguments. Yield and wait until the task is complete.</p>
<p>This function doesn't throw exceptions to avoid double error checking: in most cases it's also necessary to check the return value of the called function and perform necessary actions. If func sets errno, the errno is preserved across the call.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>and errno = ENOMEM if failed to create a task </td></tr>
    <tr><td class="paramname">the</td><td>function return (errno is preserved).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> ssize_t openfile_cb(va_list ap)</div>
<div class="line">{</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">char</span> *filename = va_arg(ap);</div>
<div class="line">         <span class="keywordtype">int</span> flags = va_arg(ap);</div>
<div class="line">         <span class="keywordflow">return</span> open(filename, flags);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a>(openfile_cb, <span class="stringliteral">&quot;/tmp/file&quot;</span>, 0) == -1)</div>
<div class="line">   <span class="comment">// handle errors.</span></div>
<div class="line">...</div>
<div class="ttc" id="amodule_8h_html_af9433c7d42d7747f1f69b79a0d98df13"><div class="ttname"><a href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a></div><div class="ttdeci">ssize_t coio_call(ssize_t(*func)(va_list),...)</div><div class="ttdoc">public</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a832b67e03175570d9f6fa17ffd77bf83" name="a832b67e03175570d9f6fa17ffd77bf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832b67e03175570d9f6fa17ffd77bf83">&#9670;&#160;</a></span>coio_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coio_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber-friendly version of getaddrinfo(3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">host</td><td>host name, i.e. "tarantool.org" </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port</td><td>service name, i.e. "80" or "http" </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hints</td><td>hints, see getaddrinfo(3) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>result, see getaddrinfo(3) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, please free <em>res</em> using freeaddrinfo(3). </td></tr>
    <tr><td class="paramname">-1</td><td>on error, check diag. Please note that the return value is not compatible with getaddrinfo(3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getaddrinfo() </dd></dl>

</div>
</div>
<a id="ab9c521a569fd78b25f355f3b7525ba9a" name="ab9c521a569fd78b25f355f3b7525ba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c521a569fd78b25f355f3b7525ba9a">&#9670;&#160;</a></span>coio_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coio_wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until READ or WRITE event on socket (<em>fd</em>). </p>
<p>Yields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>non-blocking socket file description </td></tr>
    <tr><td class="paramname">event</td><td>requested events to wait. Combination of TNT_IO_READ | TNT_IO_WRITE bit flags. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>timeout </td></tr>
    <tr><td class="paramname">&gt;0</td><td>returned events. Combination of TNT_IO_READ | TNT_IO_WRITE bit flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4003e7d28985f1573cf3faf8b4d38ee" name="ac4003e7d28985f1573cf3faf8b4d38ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4003e7d28985f1573cf3faf8b4d38ee">&#9670;&#160;</a></span>fiber_attr_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_attr_delete </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the fiber_attr and free all allocated resources. </p>
<p>This is safe when fibers created with this attribute still exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attr</td><td>fiber attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad628f573827cf2393f0849c194719a94" name="ad628f573827cf2393f0849c194719a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad628f573827cf2393f0849c194719a94">&#9670;&#160;</a></span>fiber_attr_getstacksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fiber_attr_getstacksize </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stack size from the fiber attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attr</td><td>fiber attribute container or NULL for default </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">stack</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5d5d65285c98e77cf483a0d2a092f9" name="a0c5d5d65285c98e77cf483a0d2a092f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5d5d65285c98e77cf483a0d2a092f9">&#9670;&#160;</a></span>fiber_attr_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber_attr * fiber_attr_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber attribute container and initialize it with default parameters. </p>
<p>Can be used for many fibers creation, corresponding fibers will not take ownership. </p>

</div>
</div>
<a id="a4f42c1a444922edf2163806c5433ae1a" name="a4f42c1a444922edf2163806c5433ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f42c1a444922edf2163806c5433ae1a">&#9670;&#160;</a></span>fiber_attr_setstacksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_attr_setstacksize </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stack size for the fiber attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attr</td><td>fiber attribute container </td></tr>
    <tr><td class="paramname">stack_size</td><td>stack size for new fibers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a5b700b2122f08e6bc1298ac7eb0435" name="a9a5b700b2122f08e6bc1298ac7eb0435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5b700b2122f08e6bc1298ac7eb0435">&#9670;&#160;</a></span>fiber_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cancel </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the subject fiber. </p>
<p>Cancellation is asynchronous. Use <a class="el" href="module_8h.html#a58ac22e89f3fdab0556cc5f6922f0f59" title="Wait until the fiber is dead and then move its execution status to the caller.">fiber_join()</a> to wait for the cancellation to complete.</p>
<p>After <a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435" title="Cancel the subject fiber.">fiber_cancel()</a> is called, the fiber may or may not check whether it was cancelled. If the fiber does not check it, it cannot ever be cancelled. However, as long as most of the cooperative code calls fiber_testcancel(), most of the fibers are cancellable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be cancelled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1c835fac5180f57e01c388a95440d5" name="a0e1c835fac5180f57e01c388a95440d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c835fac5180f57e01c388a95440d5">&#9670;&#160;</a></span>fiber_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fiber_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as double (cheap). </p>
<p>Uses monotonic clock. </p>

</div>
</div>
<a id="a8ed4eb4281eaa96a74c6e052995af645" name="a8ed4eb4281eaa96a74c6e052995af645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed4eb4281eaa96a74c6e052995af645">&#9670;&#160;</a></span>fiber_clock64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fiber_clock64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as 64-bit int. </p>
<p>Uses monotonic clock. </p>

</div>
</div>
<a id="abbca6fff4cd2ccf2b65528ea5e1e1e39" name="abbca6fff4cd2ccf2b65528ea5e1e1e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbca6fff4cd2ccf2b65528ea5e1e1e39">&#9670;&#160;</a></span>fiber_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake up all fibers waiting for the cond. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64787aacecdc620e9b7e402babf9ae1e" name="a64787aacecdc620e9b7e402babf9ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64787aacecdc620e9b7e402babf9ae1e">&#9670;&#160;</a></span>fiber_cond_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_delete </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the fiber cond object. </p>
<p>Behaviour is undefined if there are fiber waiting for the cond. </p>

</div>
</div>
<a id="aed23f85d72dff57249cc6633ef945340" name="aed23f85d72dff57249cc6633ef945340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed23f85d72dff57249cc6633ef945340">&#9670;&#160;</a></span>fiber_cond_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber_cond * fiber_cond_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Instantiate a new fiber cond object. </p>

</div>
</div>
<a id="a3f13caca027d090cc02574e333c78f3c" name="a3f13caca027d090cc02574e333c78f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f13caca027d090cc02574e333c78f3c">&#9670;&#160;</a></span>fiber_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_signal </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake one fiber waiting for the cond. </p>
<p>Does nothing if no one is waiting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd72e262e9e59a14c1337bc0fa2447c" name="a1dd72e262e9e59a14c1337bc0fa2447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd72e262e9e59a14c1337bc0fa2447c">&#9670;&#160;</a></span>fiber_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_cond_wait </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for <a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a> </dd></dl>

</div>
</div>
<a id="a9e7882234efd30663364ded133ab3fad" name="a9e7882234efd30663364ded133ab3fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7882234efd30663364ded133ab3fad">&#9670;&#160;</a></span>fiber_cond_wait_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_cond_wait_timeout </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the execution of the current fiber (i.e. </p>
<p>yield) until <a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c" title="Wake one fiber waiting for the cond.">fiber_cond_signal()</a> is called. Like pthread_cond, fiber_cond can issue spurious wake ups caused by explicit <a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40" title="Interrupt a synchronous wait of a fiber.">fiber_wakeup()</a> or <a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435" title="Cancel the subject fiber.">fiber_cancel()</a> calls. It is highly recommended to wrap calls to this function into a loop and check an actual predicate and fiber_testcancel() on every iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on <a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c" title="Wake one fiber waiting for the cond.">fiber_cond_signal()</a> call or a spurious wake up </td></tr>
    <tr><td class="paramname">-1</td><td>on timeout or fiber cancellation, diag is set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bcecceb5c3cb756d858c4fb536efb9f" name="a9bcecceb5c3cb756d858c4fb536efb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcecceb5c3cb756d858c4fb536efb9f">&#9670;&#160;</a></span>fiber_csw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t fiber_csw </td>
          <td>(</td>
          <td class="paramtype">const struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of context switches of the given fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber</td><td>Target fiber, if it's NULL the current fiber is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd431e93666009ddd86563809962240" name="a6dd431e93666009ddd86563809962240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd431e93666009ddd86563809962240">&#9670;&#160;</a></span>fiber_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber * fiber_find </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to a live fiber in the current cord by the given fiber id, which may be used for getting other info about the fiber (name, csw, etc.). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fid</td><td>Target fiber id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fiber on success, NULL if fiber was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a4238673bb1300b2b3e5ec6af6fe8ccf6" title="Get fiber name.">fiber_name</a>, <a class="el" href="module_8h.html#a9bcecceb5c3cb756d858c4fb536efb9f" title="Get number of context switches of the given fiber.">fiber_csw</a>, <a class="el" href="module_8h.html#a90a115d72a466ab6f33daac6f7e88ff4" title="Get fiber id.">fiber_id</a> </dd></dl>

</div>
</div>
<a id="af1fc765077a289ff21c2e452c4ca85a6" name="af1fc765077a289ff21c2e452c4ca85a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fc765077a289ff21c2e452c4ca85a6">&#9670;&#160;</a></span>fiber_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fiber_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context for the fiber which was set via the fiber_set_ctx function. </p>
<p>Can be used to avoid calling fiber_start which means no yields. If <em>f</em> is NULL, the current fiber is used.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">context</td><td>for the fiber function set by fiber_set_ctx function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ac596a2d875dcfa8477bbfc1ccc7b809d" title="Set a pointer to context for the fiber.">fiber_set_ctx</a> </dd></dl>

</div>
</div>
<a id="a90a115d72a466ab6f33daac6f7e88ff4" name="a90a115d72a466ab6f33daac6f7e88ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a115d72a466ab6f33daac6f7e88ff4">&#9670;&#160;</a></span>fiber_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t fiber_id </td>
          <td>(</td>
          <td class="paramtype">const struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fiber id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber</td><td>Target fiber, if it's NULL the current fiber is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58ac22e89f3fdab0556cc5f6922f0f59" name="a58ac22e89f3fdab0556cc5f6922f0f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ac22e89f3fdab0556cc5f6922f0f59">&#9670;&#160;</a></span>fiber_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_join </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the fiber is dead and then move its execution status to the caller. </p>
<p>The fiber must not be detached (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208" title="Set fiber to be joinable (false by default).">fiber_set_joinable()</a>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FIBER_IS_JOINABLE flag is set (panic if not). </dd>
<dd>
the fiber is not joined yet (panic if not). </dd>
<dd>
the fiber is different from current (panic if not).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fiber function ret code </dd></dl>

</div>
</div>
<a id="a676e8a263a2592320b7260095f5c10f3" name="a676e8a263a2592320b7260095f5c10f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676e8a263a2592320b7260095f5c10f3">&#9670;&#160;</a></span>fiber_join_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_join_timeout </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the fiber is dead or timeout exceeded. </p>
<p>In case timeout == TIMEOUT_INFINITY, this function same as fiber_join function. Return fiber execution status to the caller or -1 if timeout exceeded and set diag. The fiber must not be detached </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208" title="Set fiber to be joinable (false by default).">fiber_set_joinable()</a></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FIBER_IS_JOINABLE flag is set. </dd>
<dd>
the fiber is not joined yet (panic if not).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
    <tr><td class="paramname">timeout</td><td>time during which we wait for the fiber completion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fiber function ret code or -1 in case if timeout exceeded </dd></dl>

</div>
</div>
<a id="a4238673bb1300b2b3e5ec6af6fe8ccf6" name="a4238673bb1300b2b3e5ec6af6fe8ccf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4238673bb1300b2b3e5ec6af6fe8ccf6">&#9670;&#160;</a></span>fiber_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * fiber_name </td>
          <td>(</td>
          <td class="paramtype">const struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get fiber name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber</td><td>Target fiber, if it's NULL the current fiber is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a nul-terminated string. </dd></dl>

</div>
</div>
<a id="a8757a0f2f38964c8f1201768043c7a3c" name="a8757a0f2f38964c8f1201768043c7a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8757a0f2f38964c8f1201768043c7a3c">&#9670;&#160;</a></span>fiber_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber * fiber_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber. </p>
<p>Takes a fiber from fiber cache, if it's not empty. Can fail only if there is not enough memory for the fiber structure or fiber stack.</p>
<p>The created fiber automatically returns itself to the fiber cache when its "main" function completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>string with fiber name </td></tr>
    <tr><td class="paramname">f</td><td>func for run inside fiber</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2" title="Start execution of created fiber.">fiber_start</a> </dd></dl>

</div>
</div>
<a id="a4aa5816817a59a6929404d6ad93f5efc" name="a4aa5816817a59a6929404d6ad93f5efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa5816817a59a6929404d6ad93f5efc">&#9670;&#160;</a></span>fiber_new_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber * fiber_new_ex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber with defined attributes. </p>
<p>Can fail only if there is not enough memory for the fiber structure or fiber stack.</p>
<p>The created fiber automatically returns itself to the fiber cache if has default stack size when its "main" function completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>string with fiber name </td></tr>
    <tr><td class="paramname">fiber_attr</td><td>fiber attributes </td></tr>
    <tr><td class="paramname">f</td><td>func for run inside fiber</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2" title="Start execution of created fiber.">fiber_start</a> </dd></dl>

</div>
</div>
<a id="a4078cbddc22b0ed941548f86672224d9" name="a4078cbddc22b0ed941548f86672224d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4078cbddc22b0ed941548f86672224d9">&#9670;&#160;</a></span>fiber_set_cancellable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fiber_set_cancellable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yesno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="ac596a2d875dcfa8477bbfc1ccc7b809d" name="ac596a2d875dcfa8477bbfc1ccc7b809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac596a2d875dcfa8477bbfc1ccc7b809d">&#9670;&#160;</a></span>fiber_set_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_set_ctx </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a pointer to context for the fiber. </p>
<p>Can be used to avoid calling fiber_start which means no yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to set the context for if NULL, the current fiber is used </td></tr>
    <tr><td class="paramname">f_arg</td><td>context for the fiber function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee4e98a4e9c2239b5d7eb98c2b0b208" name="a8ee4e98a4e9c2239b5d7eb98c2b0b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee4e98a4e9c2239b5d7eb98c2b0b208">&#9670;&#160;</a></span>fiber_set_joinable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_set_joinable </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yesno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fiber to be joinable (false by default). </p>
<p>The fiber must not be joined already nor dead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the fiber is not dead (panic if not). </dd>
<dd>
the fiber is not joined yet (panic if not).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber</td><td>to (un)set the joinable property. If set to NULL, the current fiber is used. </td></tr>
    <tr><td class="paramname">yesno</td><td>status to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a1b21447c8f1e31be96d47a293529bb" name="a0a1b21447c8f1e31be96d47a293529bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1b21447c8f1e31be96d47a293529bb">&#9670;&#160;</a></span>fiber_set_name_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_set_name_n </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fiber name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber</td><td>Target fiber, if it's NULL the current fiber is used. </td></tr>
    <tr><td class="paramname">name</td><td>A new name of <em>fiber</em>. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the string pointed to by <em>name</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ab0816e3ddf7e11b448926569e6bc49" name="a0ab0816e3ddf7e11b448926569e6bc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab0816e3ddf7e11b448926569e6bc49">&#9670;&#160;</a></span>fiber_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_sleep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current fiber to sleep for at least 's' seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>time to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a cancellation point </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a972d46a2ac9d787bc69b61ce09938587" title="Check current fiber for cancellation (it must be checked manually).">fiber_is_cancelled</a> </dd></dl>

</div>
</div>
<a id="abca18eb68ebf89507d4cf5eb3c402cb2" name="abca18eb68ebf89507d4cf5eb3c402cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca18eb68ebf89507d4cf5eb3c402cb2">&#9670;&#160;</a></span>fiber_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_start </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start execution of created fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callee</td><td>fiber to start </td></tr>
    <tr><td class="paramname">...</td><td>arguments to start the fiber with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8757a0f2f38964c8f1201768043c7a3c" title="Create a new fiber.">fiber_new</a> </dd></dl>

</div>
</div>
<a id="a077a6068c998d2e548168be5e1a6008f" name="a077a6068c998d2e548168be5e1a6008f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077a6068c998d2e548168be5e1a6008f">&#9670;&#160;</a></span>fiber_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fiber_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as double (cheap). </p>
<p>Uses real time clock. </p>

</div>
</div>
<a id="ae1e9fb25b47b6090a587c92aaf536aed" name="ae1e9fb25b47b6090a587c92aaf536aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e9fb25b47b6090a587c92aaf536aed">&#9670;&#160;</a></span>fiber_time64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fiber_time64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as 64-bit int. </p>
<p>Uses real time clock. </p>

</div>
</div>
<a id="a661de7f72aa265ff6ffcb8b3acfafe40" name="a661de7f72aa265ff6ffcb8b3acfafe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661de7f72aa265ff6ffcb8b3acfafe40">&#9670;&#160;</a></span>fiber_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_wakeup </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt a synchronous wait of a fiber. </p>
<p>Nop for the currently running fiber.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5beb40f119b9400bb57b81820b24ff" name="aaa5beb40f119b9400bb57b81820b24ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5beb40f119b9400bb57b81820b24ff">&#9670;&#160;</a></span>fiber_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return control to another fiber and wait until it'll be woken. </p>
<dl class="section note"><dt>Note</dt><dd>this is not a cancellation point (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fiber_testcancel()), but it is considered a good practice to call fiber_testcancel() after each yield.</dd>
<dd>
<a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40" title="Interrupt a synchronous wait of a fiber.">fiber_wakeup</a> </dd></dl>

</div>
</div>
<a id="a498681c0c56f0aebe938004ab8947b0f" name="a498681c0c56f0aebe938004ab8947b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498681c0c56f0aebe938004ab8947b0f">&#9670;&#160;</a></span>luaL_cdef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_cdef </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctypename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare symbols for FFI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypename</td><td>C definitions, e.g "struct stat" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>ffi.cdef(def) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">LUA_ERRRUN,LUA_ERRMEM,LUA_ERRERR</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad6199825fbbd80b6f27ff6bc2f2a1b7" name="aad6199825fbbd80b6f27ff6bc2f2a1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6199825fbbd80b6f27ff6bc2f2a1b7">&#9670;&#160;</a></span>luaL_checkcdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * luaL_checkcdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ctypeid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the function argument idx is a cdata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>stack index </td></tr>
    <tr><td class="paramname">ctypeid</td><td>FFI's CTypeID of this cdata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a71cf0ae8133e330bcc1ccf9beabf7637" title="Push cdata of given ctypeid onto the stack.">luaL_pushcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>memory associated with this cdata </dd></dl>

</div>
</div>
<a id="a159fe92272b876c3fa7b130f026705bd" name="a159fe92272b876c3fa7b130f026705bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159fe92272b876c3fa7b130f026705bd">&#9670;&#160;</a></span>luaL_checkint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t luaL_checkint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a int64 or a convertible string and returns this number. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument can't be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5247fbc8230e2f49464e25e27b87d35" name="ac5247fbc8230e2f49464e25e27b87d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5247fbc8230e2f49464e25e27b87d35">&#9670;&#160;</a></span>luaL_checkuint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t luaL_checkuint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a uint64 or a convertible string and returns this number. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument can't be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1f07b7fe39b8bd9b7a87f7c84d5d73" name="a5d1f07b7fe39b8bd9b7a87f7c84d5d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1f07b7fe39b8bd9b7a87f7c84d5d73">&#9670;&#160;</a></span>luaL_ctypeid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t luaL_ctypeid </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctypename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CTypeID (FFI) of given DATA type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypename</td><td> type name as string (e.g. "struct request" or "uint32_t") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a71cf0ae8133e330bcc1ccf9beabf7637" title="Push cdata of given ctypeid onto the stack.">luaL_pushcdata</a> </dd>
<dd>
<a class="el" href="module_8h.html#aad6199825fbbd80b6f27ff6bc2f2a1b7" title="Checks whether the function argument idx is a cdata.">luaL_checkcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CTypeID </dd></dl>

</div>
</div>
<a id="ac765ca13d67a265532e8fe4cceb4aa5a" name="ac765ca13d67a265532e8fe4cceb4aa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac765ca13d67a265532e8fe4cceb4aa5a">&#9670;&#160;</a></span>luaL_getgctotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t luaL_getgctotal </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return size of currently allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ca887563c2bcd2e17ad199dac627b2" name="a08ca887563c2bcd2e17ad199dac627b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ca887563c2bcd2e17ad199dac627b2">&#9670;&#160;</a></span>luaL_iscallable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_iscallable </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a Lua object is a function or has metatable/metatype with a __call field. </p>
<p>Note: It does not check type of __call metatable/metatype field. </p>

</div>
</div>
<a id="acc9bcfc8296607ac6cbfdd9d44cd7451" name="acc9bcfc8296607ac6cbfdd9d44cd7451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9bcfc8296607ac6cbfdd9d44cd7451">&#9670;&#160;</a></span>luaL_iscdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_iscdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Checks whether a value on the Lua stack is a cdata.</p>
<p>Unlike <a class="el" href="module_8h.html#aad6199825fbbd80b6f27ff6bc2f2a1b7" title="Checks whether the function argument idx is a cdata.">luaL_checkcdata()</a> this function does not raise an error. It is useful to raise a domain specific error.</p>
<p>Lua API and module API don't expose LUA_TCDATA constant. We have no guarantee that this constant will remain the same in future LuaJIT versions. So this function should be used in modules instead of <code>lua_type(L, idx) == LUA_TCDATA</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua state. </td></tr>
    <tr><td class="paramname">idx</td><td>Acceptable index on the Lua stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the value at the given index is a cdata. </td></tr>
    <tr><td class="paramname">0</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d39020c975535bd3b17446d866ee4c8" name="a9d39020c975535bd3b17446d866ee4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d39020c975535bd3b17446d866ee4c8">&#9670;&#160;</a></span>luaL_isnull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool luaL_isnull </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the value at Lua stack is ffi's NULL (cdata&lt;void *&gt;: NULL). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>stack </td></tr>
    <tr><td class="paramname">idx</td><td>stack index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71cf0ae8133e330bcc1ccf9beabf7637" name="a71cf0ae8133e330bcc1ccf9beabf7637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cf0ae8133e330bcc1ccf9beabf7637">&#9670;&#160;</a></span>luaL_pushcdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * luaL_pushcdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctypeid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push cdata of given <em>ctypeid</em> onto the stack. </p>
<p>CTypeID must be used from FFI at least once. Allocated memory returned uninitialized. Only numbers and pointers are supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypeid</td><td>FFI's CTypeID of this cdata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#aad6199825fbbd80b6f27ff6bc2f2a1b7" title="Checks whether the function argument idx is a cdata.">luaL_checkcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>memory associated with this cdata </dd></dl>

</div>
</div>
<a id="a1dcccfbc48bac7e8cf4802e839c2f198" name="a1dcccfbc48bac7e8cf4802e839c2f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcccfbc48bac7e8cf4802e839c2f198">&#9670;&#160;</a></span>luaL_pushint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_pushint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push int64_t onto the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>is a Lua State </td></tr>
    <tr><td class="paramname">val</td><td>is a value to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeb6909b96e0c27329d9de8e05e6a805" name="adeb6909b96e0c27329d9de8e05e6a805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb6909b96e0c27329d9de8e05e6a805">&#9670;&#160;</a></span>luaL_pushnull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_pushnull </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push ffi's NULL (cdata&lt;void *&gt;: NULL) onto the stack. </p>
<p>Can be used as replacement of nil in Lua tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6439d4dd158b27d2567e1bfd6243e084" name="a6439d4dd158b27d2567e1bfd6243e084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6439d4dd158b27d2567e1bfd6243e084">&#9670;&#160;</a></span>luaL_pushuint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_pushuint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Push uint64_t onto the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>is a Lua State </td></tr>
    <tr><td class="paramname">val</td><td>is a value to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa62fc5e919f74956a06a9b40fb24f691" name="aa62fc5e919f74956a06a9b40fb24f691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62fc5e919f74956a06a9b40fb24f691">&#9670;&#160;</a></span>luaL_setcdatagc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_setcdatagc </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets finalizer function on a cdata object. </p>
<p>Equivalent to call ffi.gc(obj, function). Finalizer function must be on the top of the stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31727f17a0a09ff7fb92ac3d2eaa2dce" name="a31727f17a0a09ff7fb92ac3d2eaa2dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31727f17a0a09ff7fb92ac3d2eaa2dce">&#9670;&#160;</a></span>luaL_toint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t luaL_toint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a int64 or a convertible string and returns this number. </p>
<dl class="section return"><dt>Returns</dt><dd>the converted number or 0 of argument can't be converted. </dd></dl>

</div>
</div>
<a id="a20e035148bc707412c054291f9b51855" name="a20e035148bc707412c054291f9b51855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e035148bc707412c054291f9b51855">&#9670;&#160;</a></span>luaL_touint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t luaL_touint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a uint64 or a convertible string and returns this number. </p>
<dl class="section return"><dt>Returns</dt><dd>the converted number or 0 of argument can't be converted. </dd></dl>

</div>
</div>
<a id="a4c95f4e99d2f7b5be64ca3918fdc4ccf" name="a4c95f4e99d2f7b5be64ca3918fdc4ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95f4e99d2f7b5be64ca3918fdc4ccf">&#9670;&#160;</a></span>luaT_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_call </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nreturns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lua_call(), but with the proper support of Tarantool errors. </p>
<dl class="section see"><dt>See also</dt><dd>lua_call() </dd></dl>

</div>
</div>
<a id="a4703451fd9a5ddf2b0a5e5c2f828aa4a" name="a4703451fd9a5ddf2b0a5e5c2f828aa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4703451fd9a5ddf2b0a5e5c2f828aa4a">&#9670;&#160;</a></span>luaT_checktuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * luaT_checktuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Checks whether the argument idx is a tuple and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>the stack index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>argument is tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument is not a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08aafb8aaa59640f2b7130e9281e53ec" name="a08aafb8aaa59640f2b7130e9281e53ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aafb8aaa59640f2b7130e9281e53ec">&#9670;&#160;</a></span>luaT_cpcall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_cpcall </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lua_CFunction&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lua_cpcall(), but with the proper support of Tarantool errors. </p>
<dl class="section see"><dt>See also</dt><dd>lua_cpcall() </dd></dl>

</div>
</div>
<a id="aa1a5310ad259a9b8ea40603a3d7f1946" name="aa1a5310ad259a9b8ea40603a3d7f1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a5310ad259a9b8ea40603a3d7f1946">&#9670;&#160;</a></span>luaT_dostring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_dostring </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like luaL_dostring(), but in case of error sets fiber diag instead of putting error on stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua state </td></tr>
    <tr><td class="paramname">str</td><td>string with Lua code to load and run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5e643c0eff90628dd8cb09ddd8dfc68" name="ae5e643c0eff90628dd8cb09ddd8dfc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e643c0eff90628dd8cb09ddd8dfc68">&#9670;&#160;</a></span>luaT_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_error </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-throws the last Tarantool error as a Lua object. </p>
<p>Set trace frame of to the caller of Lua C API.</p>
<dl class="section see"><dt>See also</dt><dd>lua_error() </dd>
<dd>
<a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a8fccc46b7877086aefbcce5535e8b1cf" name="a8fccc46b7877086aefbcce5535e8b1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fccc46b7877086aefbcce5535e8b1cf">&#9670;&#160;</a></span>luaT_error_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_error_at </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as luaT_error but set error trace frame according to given level. </p>
<p>luaT_error same as this function with level equal to 1. If level is 0 then error trace is unchanged. </p>

</div>
</div>
<a id="a15b19d5a4c0f109f4a8db17bb886d863" name="a15b19d5a4c0f109f4a8db17bb886d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b19d5a4c0f109f4a8db17bb886d863">&#9670;&#160;</a></span>luaT_isdecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * luaT_isdecimal </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a value on the Lua stack is a decimal. </p>
<p>Returns a pointer to the decimal on a successful check, NULL otherwise. </p>

</div>
</div>
<a id="a3c8ffde3785c473470bf52bba05787c7" name="a3c8ffde3785c473470bf52bba05787c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8ffde3785c473470bf52bba05787c7">&#9670;&#160;</a></span>luaT_istuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * luaT_istuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether argument idx is a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>the stack index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>argument is tuple </td></tr>
    <tr><td class="paramname">NULL</td><td>argument is not tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99ce5d3090eafea3a46709aaa68c7a5b" name="a99ce5d3090eafea3a46709aaa68c7a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ce5d3090eafea3a46709aaa68c7a5b">&#9670;&#160;</a></span>luaT_newdecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> * luaT_newdecimal </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Allocate a new decimal on the Lua stack and return a pointer to it. </p>

</div>
</div>
<a id="aa1740670301221218d3780f2a4df33c6" name="aa1740670301221218d3780f2a4df33c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1740670301221218d3780f2a4df33c6">&#9670;&#160;</a></span>luaT_push_nil_and_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_push_nil_and_error </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return nil as the first return value and an error as the second. </p>
<p>The error is received using <a class="el" href="module_8h.html#a29b4ebee3bb9402fb8621b4e96b93b5d" title="Get the information about the last API call error.">box_error_last()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9f0f763644cd5edc43ac632078b471" name="aff9f0f763644cd5edc43ac632078b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9f0f763644cd5edc43ac632078b471">&#9670;&#160;</a></span>luaT_pusherror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaT_pusherror </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct error *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push error to a Lua stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua stack. </td></tr>
    <tr><td class="paramname">e</td><td>error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddb8bf7e1f41149fe67352de0f276d4" name="a0ddb8bf7e1f41149fe67352de0f276d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddb8bf7e1f41149fe67352de0f276d4">&#9670;&#160;</a></span>luaT_pushtuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaT_pushtuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a tuple onto the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">tuple</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a3c8ffde3785c473470bf52bba05787c7" title="Checks whether argument idx is a tuple.">luaT_istuple</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">on</td><td>OOM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff1bdf425a10a3cb4e51f732195e9b39" name="aff1bdf425a10a3cb4e51f732195e9b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1bdf425a10a3cb4e51f732195e9b39">&#9670;&#160;</a></span>luaT_toibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> * luaT_toibuf </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a value on <em>L</em> stack by index <em>idx</em> is an ibuf object. </p>
<p>Both 'struct ibuf' and 'struct ibuf *' are accepted. Returns NULL, if can't convert - not an ibuf object. </p>

</div>
</div>
<a id="a1a399adb96af280b9faedf642f5549cf" name="a1a399adb96af280b9faedf642f5549cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a399adb96af280b9faedf642f5549cf">&#9670;&#160;</a></span>luaT_tuple_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * luaT_tuple_encode </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tuple_len_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a table or a tuple on the Lua stack as an MsgPack array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua state. </td></tr>
    <tr><td class="paramname">idx</td><td>Acceptable index on the Lua stack. </td></tr>
    <tr><td class="paramname">tuple_len_ptr</td><td>Where to store tuple data size in bytes (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>The storage for data is allocated on the box region. A caller should call <a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4" title="Truncate the box region to the given size.">box_region_truncate()</a> to release the data.</p>
<p>In case of an error set a diag and return NULL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8f9fba67e9a46d465bcefba3fd06f305" title="Create a new tuple with specific format from a Lua table or a tuple.">luaT_tuple_new()</a> </dd></dl>

</div>
</div>
<a id="a8f9fba67e9a46d465bcefba3fd06f305" name="a8f9fba67e9a46d465bcefba3fd06f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9fba67e9a46d465bcefba3fd06f305">&#9670;&#160;</a></span>luaT_tuple_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> * luaT_tuple_new </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new tuple with specific format from a Lua table or a tuple. </p>
<p>The new tuple is referenced in the same way as one created by <a class="el" href="module_8h.html#a283636709357b346d38a44345a0a7297" title="Allocate and initialize a new tuple from a raw MsgPack Array data.">box_tuple_new()</a>. There are two possible usage scenarios:</p>
<ol type="1">
<li>A short living tuple may not be referenced explicitly and will be collected automatically at the next module API call that yields or returns a tuple.</li>
<li>A long living tuple must be referenced using <a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a> and unreferenced then with <a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc" title="Decrease the reference counter of tuple.">box_tuple_unref()</a>.</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a></dd></dl>
<p>In case of an error set a diag and return NULL. </p>

</div>
</div>
<a id="a78be466e9dc2ecebafa253b4f1658c7b" name="a78be466e9dc2ecebafa253b4f1658c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78be466e9dc2ecebafa253b4f1658c7b">&#9670;&#160;</a></span>tnt_tx_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tnt_tx_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send all the pending callbacks of this thread to TX thread. </p>
<p>Note, that it doesn't guarantee that they are already executed when this function returns. They are only sent to TX thread, not called yet. It is the caller's responsibility to ensure that the messages are not being sent faster than TX thread is handling them. Otherwise the queue in TX thread grows faster than shrinks and could lead to unpredictable latency and even OOM.</p>
<p>Note, that push is very cheap while flush is relatively expensive both for this thread and for TX thread. Avoid calling it on each push if possible. </p>

</div>
</div>
<a id="a616f82352b7ba1ee74c02d402dfefc52" name="a616f82352b7ba1ee74c02d402dfefc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616f82352b7ba1ee74c02d402dfefc52">&#9670;&#160;</a></span>tnt_tx_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tnt_tx_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#abba432143f6c7876ea8704638e9c9e5d">tnt_tx_func_f</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the given callback to be executed in TX thread with the provided argument. </p>
<p>In order for the messages to be actually sent to TX thread the user must call <a class="el" href="module_8h.html#a78be466e9dc2ecebafa253b4f1658c7b" title="Send all the pending callbacks of this thread to TX thread.">tnt_tx_flush()</a> in the same thread as the pushes.</p>
<p>In TX thread the callbacks are guaranteed to start execution in the same order as the push, but the order of completion is undefined if they are yielding, since they get executed potentially in different fibers.</p>
<p>The callbacks are handled by an internal fiber pool running in TX thread. The pool has a limited size. In case the callbacks are yielding and the user wants to execute more of them concurrently than the default size of the fiber pool, then the size can be extended (or reduced) using fiber.tx_user_pool_size() Lua API or <code>fiber.tx_user_pool_size</code> YAML config.</p>
<p>If called during Tarantool shutdown, the behaviour is undefined. The external threads must be terminated before that.</p>
<p>If called in TX thread, the behaviour is undefined.</p>
<p>The function relies on <code>thread_local</code> C++ data to have properly working destructors and constructors and won't be suitable for any other runtime. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 4 2025 10:25:19 for Tarantool by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
