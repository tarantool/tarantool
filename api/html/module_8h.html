<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tarantool: src/module.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tarantool
   </div>
   <div id="projectbrief">Get your data in RAM. Get compute close to data. Enjoy the performance.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">module.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;lua.h&quot;</code><br />
</div>
<p><a href="module_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPACKED.html">PACKED</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public representation of a key part definition.  <a href="unionPACKED.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbox__decimal.html">box_decimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="structbox__decimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac5f2c7580fd5bf200c5027443420902f"><td class="memItemLeft" align="right" valign="top"><a id="ac5f2c7580fd5bf200c5027443420902f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac5f2c7580fd5bf200c5027443420902f">PACKAGE_VERSION_MAJOR</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ac5f2c7580fd5bf200c5027443420902f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package major version - 1 for 1.6.7. <br /></td></tr>
<tr class="separator:ac5f2c7580fd5bf200c5027443420902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab155eaff0a115e522c1faae631196e"><td class="memItemLeft" align="right" valign="top"><a id="a4ab155eaff0a115e522c1faae631196e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4ab155eaff0a115e522c1faae631196e">PACKAGE_VERSION_MINOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a4ab155eaff0a115e522c1faae631196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package minor version - 6 for 1.6.7. <br /></td></tr>
<tr class="separator:a4ab155eaff0a115e522c1faae631196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1dbec4fd6761084d3e0c05afe2b138"><td class="memItemLeft" align="right" valign="top"><a id="abd1dbec4fd6761084d3e0c05afe2b138"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abd1dbec4fd6761084d3e0c05afe2b138">PACKAGE_VERSION_PATCH</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:abd1dbec4fd6761084d3e0c05afe2b138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Package patch version - 7 for 1.6.7. <br /></td></tr>
<tr class="separator:abd1dbec4fd6761084d3e0c05afe2b138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa326a05d5e30f9e9a4bb0b4469d5d0c0">PACKAGE_VERSION</a>&#160;&#160;&#160;&quot;3.0.0-entrypoint-80-g3dbbf2d39&quot;</td></tr>
<tr class="memdesc:aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string with major-minor-patch-commit-id identifier of the release, e.g.  <a href="module_8h.html#aa326a05d5e30f9e9a4bb0b4469d5d0c0">More...</a><br /></td></tr>
<tr class="separator:aa326a05d5e30f9e9a4bb0b4469d5d0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6d1259777e8f56c6260be6faed183e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adb6d1259777e8f56c6260be6faed183e">SYSCONF_DIR</a>&#160;&#160;&#160;&quot;etc&quot;</td></tr>
<tr class="memdesc:adb6d1259777e8f56c6260be6faed183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#adb6d1259777e8f56c6260be6faed183e">More...</a><br /></td></tr>
<tr class="separator:adb6d1259777e8f56c6260be6faed183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643b6b7ac15874197420e2adbea8b6bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a643b6b7ac15874197420e2adbea8b6bb">INSTALL_PREFIX</a>&#160;&#160;&#160;&quot;/usr/local&quot;</td></tr>
<tr class="memdesc:a643b6b7ac15874197420e2adbea8b6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install prefix (e.g.  <a href="module_8h.html#a643b6b7ac15874197420e2adbea8b6bb">More...</a><br /></td></tr>
<tr class="separator:a643b6b7ac15874197420e2adbea8b6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040141d0f88e012c0b915e3531fef5cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a040141d0f88e012c0b915e3531fef5cc">BUILD_TYPE</a>&#160;&#160;&#160;&quot;Debug&quot;</td></tr>
<tr class="memdesc:a040141d0f88e012c0b915e3531fef5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build type, e.g.  <a href="module_8h.html#a040141d0f88e012c0b915e3531fef5cc">More...</a><br /></td></tr>
<tr class="separator:a040141d0f88e012c0b915e3531fef5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac8c9f90a1d4b7435c509fd2020e4aa88">BUILD_INFO</a>&#160;&#160;&#160;&quot;Linux-x86_64-Debug&quot;</td></tr>
<tr class="memdesc:ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">CMake build type signature, e.g.  <a href="module_8h.html#ac8c9f90a1d4b7435c509fd2020e4aa88">More...</a><br /></td></tr>
<tr class="separator:ac8c9f90a1d4b7435c509fd2020e4aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863d95c06ae4d073ea443a8ae48c5b6"><td class="memItemLeft" align="right" valign="top"><a id="a2863d95c06ae4d073ea443a8ae48c5b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2863d95c06ae4d073ea443a8ae48c5b6">BUILD_OPTIONS</a>&#160;&#160;&#160;&quot;cmake . -DCMAKE_INSTALL_PREFIX=/usr/local -DENABLE_BACKTRACE=TRUE&quot;</td></tr>
<tr class="memdesc:a2863d95c06ae4d073ea443a8ae48c5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line used to run CMake. <br /></td></tr>
<tr class="separator:a2863d95c06ae4d073ea443a8ae48c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835dbb7b4216a8258c588d9781a3b66b"><td class="memItemLeft" align="right" valign="top"><a id="a835dbb7b4216a8258c588d9781a3b66b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a835dbb7b4216a8258c588d9781a3b66b">COMPILER_INFO</a>&#160;&#160;&#160;&quot;GNU-11.3.0&quot;</td></tr>
<tr class="memdesc:a835dbb7b4216a8258c588d9781a3b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiler ID and version, assuming the C and C++ compiler IDs are equal. <br /></td></tr>
<tr class="separator:a835dbb7b4216a8258c588d9781a3b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc01d1a8b018ef75d112a8f51dde4e27"><td class="memItemLeft" align="right" valign="top"><a id="adc01d1a8b018ef75d112a8f51dde4e27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adc01d1a8b018ef75d112a8f51dde4e27">TARANTOOL_C_FLAGS</a>&#160;&#160;&#160;&quot; -fexceptions -funwind-tables -fasynchronous-unwind-tables -fno-common -fopenmp -msse2 -Wformat -Wformat-security -Werror=format-security -fstack-protector-strong -fPIC -fmacro-prefix-map=/home/runner/work/tarantool/tarantool=. -std=c11 -Wall -Wextra -Wno-gnu-<a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>-expression -fno-gnu89-inline -Wno-cast-function-type -Werror&quot;</td></tr>
<tr class="memdesc:adc01d1a8b018ef75d112a8f51dde4e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">C compile flags used to build Tarantool. <br /></td></tr>
<tr class="separator:adc01d1a8b018ef75d112a8f51dde4e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2118c0a1a997878f04f860b4049ca934"><td class="memItemLeft" align="right" valign="top"><a id="a2118c0a1a997878f04f860b4049ca934"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2118c0a1a997878f04f860b4049ca934">TARANTOOL_CXX_FLAGS</a>&#160;&#160;&#160;&quot; -fexceptions -funwind-tables -fasynchronous-unwind-tables -fno-common -fopenmp -msse2 -Wformat -Wformat-security -Werror=format-security -fstack-protector-strong -fPIC -fmacro-prefix-map=/home/runner/work/tarantool/tarantool=. -std=c++11 -Wall -Wextra -Wno-invalid-<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a> -Wno-gnu-<a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>-expression -Wno-cast-function-type -Werror&quot;</td></tr>
<tr class="memdesc:a2118c0a1a997878f04f860b4049ca934"><td class="mdescLeft">&#160;</td><td class="mdescRight">CXX compile flags used to build Tarantool. <br /></td></tr>
<tr class="separator:a2118c0a1a997878f04f860b4049ca934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bca7e3d39f063be25a9d61a0a9d421"><td class="memItemLeft" align="right" valign="top"><a id="a44bca7e3d39f063be25a9d61a0a9d421"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a44bca7e3d39f063be25a9d61a0a9d421">MODULE_LIBDIR</a>&#160;&#160;&#160;&quot;/usr/local/lib/tarantool&quot;</td></tr>
<tr class="memdesc:a44bca7e3d39f063be25a9d61a0a9d421"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to install *.lua module files. <br /></td></tr>
<tr class="separator:a44bca7e3d39f063be25a9d61a0a9d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114e8df5bc35951db601268ec25d600"><td class="memItemLeft" align="right" valign="top"><a id="a8114e8df5bc35951db601268ec25d600"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8114e8df5bc35951db601268ec25d600">MODULE_LUADIR</a>&#160;&#160;&#160;&quot;/usr/local/share/tarantool&quot;</td></tr>
<tr class="memdesc:a8114e8df5bc35951db601268ec25d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to install *.so / *.dylib module files. <br /></td></tr>
<tr class="separator:a8114e8df5bc35951db601268ec25d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a42b6eee771a85d83b371c0f22337"><td class="memItemLeft" align="right" valign="top"><a id="a516a42b6eee771a85d83b371c0f22337"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a516a42b6eee771a85d83b371c0f22337">MODULE_INCLUDEDIR</a>&#160;&#160;&#160;&quot;/usr/local/include/tarantool&quot;</td></tr>
<tr class="memdesc:a516a42b6eee771a85d83b371c0f22337"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path to Lua includes (the same directory where this file is contained) <br /></td></tr>
<tr class="separator:a516a42b6eee771a85d83b371c0f22337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e471f2a326d5e86e09a56f9da3d383f"><td class="memItemLeft" align="right" valign="top"><a id="a5e471f2a326d5e86e09a56f9da3d383f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5e471f2a326d5e86e09a56f9da3d383f">MODULE_LUAPATH</a>&#160;&#160;&#160;&quot;/usr/local/share/tarantool/?.lua;/usr/local/share/tarantool/?/init.lua;/usr/share/tarantool/?.lua;/usr/share/tarantool/?/init.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua&quot;</td></tr>
<tr class="memdesc:a5e471f2a326d5e86e09a56f9da3d383f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant added to package.path in Lua to find *.lua module files. <br /></td></tr>
<tr class="separator:a5e471f2a326d5e86e09a56f9da3d383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a0a80ad0559e26298ce670050609e2"><td class="memItemLeft" align="right" valign="top"><a id="a83a0a80ad0559e26298ce670050609e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a83a0a80ad0559e26298ce670050609e2">MODULE_LIBPATH</a>&#160;&#160;&#160;&quot;/usr/local/lib/x86_64-linux-gnu/tarantool/?.so;/usr/local/lib/tarantool/?.so;/usr/lib/x86_64-linux-gnu/tarantool/?.so;/usr/local/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/local/lib/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so&quot;</td></tr>
<tr class="memdesc:a83a0a80ad0559e26298ce670050609e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant added to package.cpath in Lua to find *.so module files. <br /></td></tr>
<tr class="separator:a83a0a80ad0559e26298ce670050609e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894125cfa770b79267d0eb49e83c2279"><td class="memItemLeft" align="right" valign="top"><a id="a894125cfa770b79267d0eb49e83c2279"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a894125cfa770b79267d0eb49e83c2279">MODULE_LIBSUFFIX</a>&#160;&#160;&#160;&quot;.so&quot;</td></tr>
<tr class="memdesc:a894125cfa770b79267d0eb49e83c2279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared library suffix - ".so" on Linux, ".dylib" on Mac. <br /></td></tr>
<tr class="separator:a894125cfa770b79267d0eb49e83c2279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af989845e24678c452b9222afdac95e7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af989845e24678c452b9222afdac95e7f">__has_feature</a>(x)&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:af989845e24678c452b9222afdac95e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af989845e24678c452b9222afdac95e7f">More...</a><br /></td></tr>
<tr class="separator:af989845e24678c452b9222afdac95e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447121dcab4275b7839a56082b7a1ab8"><td class="memItemLeft" align="right" valign="top"><a id="a447121dcab4275b7839a56082b7a1ab8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_builtin</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a447121dcab4275b7839a56082b7a1ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memItemLeft" align="right" valign="top"><a id="a54d2d7742701f3f112afbcd8d4f9ccdb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_attribute</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:a54d2d7742701f3f112afbcd8d4f9ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed0a618f017e128a5d8654754f792db"><td class="memItemLeft" align="right" valign="top"><a id="aeed0a618f017e128a5d8654754f792db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__has_cpp_attribute</b>(x)&#160;&#160;&#160;0</td></tr>
<tr class="separator:aeed0a618f017e128a5d8654754f792db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a0bd562b98ae8c2ffce44935351e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="memdesc:a217a0bd562b98ae8c2ffce44935351e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiler-independent built-ins.  <a href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1">More...</a><br /></td></tr>
<tr class="separator:a217a0bd562b98ae8c2ffce44935351e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c45889010c1bd68631771b64f18101"><td class="memItemLeft" align="right" valign="top"><a id="ac6c45889010c1bd68631771b64f18101"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>unlikely</b>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:ac6c45889010c1bd68631771b64f18101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6458adcc00e90c64bc87db324d1602"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#add6458adcc00e90c64bc87db324d1602">prefetch</a>(addr, ...)&#160;&#160;&#160;((void) addr)</td></tr>
<tr class="memdesc:add6458adcc00e90c64bc87db324d1602"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed.  <a href="module_8h.html#add6458adcc00e90c64bc87db324d1602">More...</a><br /></td></tr>
<tr class="separator:add6458adcc00e90c64bc87db324d1602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d08c1b23d67eca942da0ac012d89f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3">unreachable</a>()&#160;&#160;&#160;(assert(0))</td></tr>
<tr class="memdesc:a86d08c1b23d67eca942da0ac012d89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If control flow reaches the point of the <a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3" title="If control flow reaches the point of the unreachable(), the program is undefined.">unreachable()</a>, the program is undefined.  <a href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3">More...</a><br /></td></tr>
<tr class="separator:a86d08c1b23d67eca942da0ac012d89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd049f7ad59dbe455f460807475c2841"><td class="memItemLeft" align="right" valign="top"><a id="afd049f7ad59dbe455f460807475c2841"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(type,  member)&#160;&#160;&#160;((size_t) &amp;((type *)0)-&gt;member)</td></tr>
<tr class="memdesc:afd049f7ad59dbe455f460807475c2841"><td class="mdescLeft">&#160;</td><td class="mdescRight">The macro offsetof expands to an integral constant expression of type size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any. <br /></td></tr>
<tr class="separator:afd049f7ad59dbe455f460807475c2841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c317a42292b61c93aae91e59118a46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>(ptr,  type,  member)</td></tr>
<tr class="memdesc:af8c317a42292b61c93aae91e59118a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to retrieve an enclosing structure from a pointer to a nested element.  <a href="module_8h.html#af8c317a42292b61c93aae91e59118a46">More...</a><br /></td></tr>
<tr class="separator:af8c317a42292b61c93aae91e59118a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f3cf1114cea323f428ee90a531c62"><td class="memItemLeft" align="right" valign="top"><a id="a131f3cf1114cea323f428ee90a531c62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>alignas</b>(_n)</td></tr>
<tr class="separator:a131f3cf1114cea323f428ee90a531c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed9482331696beaadb8ab2e6b4dfead"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">alignof</a>(_T)&#160;&#160;&#160;<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(struct { char c; _T member; }, member)</td></tr>
<tr class="memdesc:a3ed9482331696beaadb8ab2e6b4dfead"><td class="mdescLeft">&#160;</td><td class="mdescRight">C11/C++11 operator.  <a href="module_8h.html#a3ed9482331696beaadb8ab2e6b4dfead">More...</a><br /></td></tr>
<tr class="separator:a3ed9482331696beaadb8ab2e6b4dfead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7779ca95ec13deccfed1299cf0bb571"><td class="memItemLeft" align="right" valign="top"><a id="ac7779ca95ec13deccfed1299cf0bb571"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__alignof_is_defined</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac7779ca95ec13deccfed1299cf0bb571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d932791f722cd5b75c111e51ef2023"><td class="memItemLeft" align="right" valign="top"><a id="a07d932791f722cd5b75c111e51ef2023"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAYBE_UNUSED</b></td></tr>
<tr class="separator:a07d932791f722cd5b75c111e51ef2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13e44576a768044e199191d4f26f7e"><td class="memItemLeft" align="right" valign="top"><a id="abf13e44576a768044e199191d4f26f7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NODISCARD</b></td></tr>
<tr class="separator:abf13e44576a768044e199191d4f26f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b173d22e57d9395897acbd8de62d505"><td class="memItemLeft" align="right" valign="top"><a id="a1b173d22e57d9395897acbd8de62d505"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOINLINE</b></td></tr>
<tr class="separator:a1b173d22e57d9395897acbd8de62d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1728270d73c5d1598de1fd691762eb1"><td class="memItemLeft" align="right" valign="top"><a id="aa1728270d73c5d1598de1fd691762eb1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NORETURN</b></td></tr>
<tr class="separator:aa1728270d73c5d1598de1fd691762eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033c6face33bc7db165c0ba591696fcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a033c6face33bc7db165c0ba591696fcc">DEPRECATED</a>(_msg)</td></tr>
<tr class="memdesc:a033c6face33bc7db165c0ba591696fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DEPRECATED attribute can be applied to a function, a variable, or a type.  <a href="module_8h.html#a033c6face33bc7db165c0ba591696fcc">More...</a><br /></td></tr>
<tr class="separator:a033c6face33bc7db165c0ba591696fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="memItemLeft" align="right" valign="top"><a id="a5e3652cae8b48c1ad174f0b06bbd06d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5e3652cae8b48c1ad174f0b06bbd06d0">API_EXPORT</a>&#160;&#160;&#160;extern</td></tr>
<tr class="memdesc:a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API_EXPORT attribute declares public C API function. <br /></td></tr>
<tr class="separator:a5e3652cae8b48c1ad174f0b06bbd06d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df7795fe4158ac681564ae0520d975"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a75df7795fe4158ac681564ae0520d975">CFORMAT</a>(archetype,  stringindex,  firsttocheck)</td></tr>
<tr class="memdesc:a75df7795fe4158ac681564ae0520d975"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CFORMAT attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments that should be type-checked against a format string.  <a href="module_8h.html#a75df7795fe4158ac681564ae0520d975">More...</a><br /></td></tr>
<tr class="separator:a75df7795fe4158ac681564ae0520d975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d525cf4d116b2fe4ecc00222b256f1"><td class="memItemLeft" align="right" valign="top"><a id="a36d525cf4d116b2fe4ecc00222b256f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PACKED</b></td></tr>
<tr class="separator:a36d525cf4d116b2fe4ecc00222b256f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0cf2d82c57a09723ab59e6f4dcc45b84">FALLTHROUGH</a></td></tr>
<tr class="memdesc:a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Attributes }}}.  <a href="module_8h.html#a0cf2d82c57a09723ab59e6f4dcc45b84">More...</a><br /></td></tr>
<tr class="separator:a0cf2d82c57a09723ab59e6f4dcc45b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82e9747a226e287b0355deecfee5d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aed82e9747a226e287b0355deecfee5d1">say_file_line</a>(level,  file,  line,  error,  format, ...)</td></tr>
<tr class="memdesc:aed82e9747a226e287b0355deecfee5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#aed82e9747a226e287b0355deecfee5d1">More...</a><br /></td></tr>
<tr class="separator:aed82e9747a226e287b0355deecfee5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2bb360001f6dfb4f946335950cabbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(level,  error,  format, ...)</td></tr>
<tr class="memdesc:a5b2bb360001f6dfb4f946335950cabbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">More...</a><br /></td></tr>
<tr class="separator:a5b2bb360001f6dfb4f946335950cabbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0a7d66a81cb7c12fdb2bf2c16b9c563e">say_error</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_ERROR, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#a0a7d66a81cb7c12fdb2bf2c16b9c563e">More...</a><br /></td></tr>
<tr class="separator:a0a7d66a81cb7c12fdb2bf2c16b9c563e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7971b0f41c615be5a0b7100b5e42dcb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7971b0f41c615be5a0b7100b5e42dcb3">say_crit</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_CRIT, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a7971b0f41c615be5a0b7100b5e42dcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#a7971b0f41c615be5a0b7100b5e42dcb3">More...</a><br /></td></tr>
<tr class="separator:a7971b0f41c615be5a0b7100b5e42dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac1ea95f80b8aa81fe56ca4291814b8a3">say_warn</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_WARN, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#ac1ea95f80b8aa81fe56ca4291814b8a3">More...</a><br /></td></tr>
<tr class="separator:ac1ea95f80b8aa81fe56ca4291814b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d530f5d4ff18fd7786c3648dac2cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_INFO, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ae02d530f5d4ff18fd7786c3648dac2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">More...</a><br /></td></tr>
<tr class="separator:ae02d530f5d4ff18fd7786c3648dac2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a0037b2d3389e850c9bd7d66996b42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a01a0037b2d3389e850c9bd7d66996b42">say_verbose</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_VERBOSE, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:a01a0037b2d3389e850c9bd7d66996b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#a01a0037b2d3389e850c9bd7d66996b42">More...</a><br /></td></tr>
<tr class="separator:a01a0037b2d3389e850c9bd7d66996b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab318c2435df2b04c7180df57a3c217ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab318c2435df2b04c7180df57a3c217ae">say_debug</a>(format, ...)&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_DEBUG, NULL, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:ab318c2435df2b04c7180df57a3c217ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#ab318c2435df2b04c7180df57a3c217ae">More...</a><br /></td></tr>
<tr class="separator:ab318c2435df2b04c7180df57a3c217ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39929109aefade22a76048b9ac73bd8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a39929109aefade22a76048b9ac73bd8d">say_syserror</a>(format, ...)</td></tr>
<tr class="memdesc:a39929109aefade22a76048b9ac73bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and print a message to Tarantool log file.  <a href="module_8h.html#a39929109aefade22a76048b9ac73bd8d">More...</a><br /></td></tr>
<tr class="separator:a39929109aefade22a76048b9ac73bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef61141a7db6fda3c9710bbc8c340e2e"><td class="memItemLeft" align="right" valign="top"><a id="aef61141a7db6fda3c9710bbc8c340e2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aef61141a7db6fda3c9710bbc8c340e2e">box_error_raise</a>(code,  format, ...)&#160;&#160;&#160;	<a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b">box_error_set</a>(__FILE__, __LINE__, code, format, ##__VA_ARGS__)</td></tr>
<tr class="memdesc:aef61141a7db6fda3c9710bbc8c340e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A backward-compatible API define. <br /></td></tr>
<tr class="separator:aef61141a7db6fda3c9710bbc8c340e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0415940d06f795e1f4dcfd40dd6c5b"><td class="memItemLeft" align="right" valign="top"><a id="afd0415940d06f795e1f4dcfd40dd6c5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afd0415940d06f795e1f4dcfd40dd6c5b">BOX_DECIMAL_STRING_BUFFER_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:afd0415940d06f795e1f4dcfd40dd6c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer of this size is enough to hold any <a class="el" href="module_8h.html#a7a20acf8704e0a8de6b2c6e70cabda94" title="Write the decimal as a string into the passed buffer.">box_decimal_to_string()</a> result. <br /></td></tr>
<tr class="separator:afd0415940d06f795e1f4dcfd40dd6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24a548551bdc95d156210ec216ded4f9"><td class="memItemLeft" align="right" valign="top"><a id="a24a548551bdc95d156210ec216ded4f9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a24a548551bdc95d156210ec216ded4f9">sayfunc_t</a>) (int, const char *, int, const char *, const char *,...)</td></tr>
<tr class="memdesc:a24a548551bdc95d156210ec216ded4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a24a548551bdc95d156210ec216ded4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94849dd4556ce6560a898d5af2d20779"><td class="memItemLeft" align="right" valign="top"><a id="a94849dd4556ce6560a898d5af2d20779"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a>) (va_list)</td></tr>
<tr class="memdesc:a94849dd4556ce6560a898d5af2d20779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber - contains information about fiber. <br /></td></tr>
<tr class="separator:a94849dd4556ce6560a898d5af2d20779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cb16b1acef0772ea4192316f742aa8"><td class="memItemLeft" align="right" valign="top"><a id="ae1cb16b1acef0772ea4192316f742aa8"></a>
typedef struct ibuf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a></td></tr>
<tr class="memdesc:ae1cb16b1acef0772ea4192316f742aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:ae1cb16b1acef0772ea4192316f742aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab230ff08fb24d580407126fc905cc271"><td class="memItemLeft" align="right" valign="top"><a id="ab230ff08fb24d580407126fc905cc271"></a>
typedef struct tuple_format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a></td></tr>
<tr class="memdesc:ab230ff08fb24d580407126fc905cc271"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:ab230ff08fb24d580407126fc905cc271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880c3e1e8e63b9a12353853fb6aefa3f"><td class="memItemLeft" align="right" valign="top"><a id="a880c3e1e8e63b9a12353853fb6aefa3f"></a>
typedef struct tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a></td></tr>
<tr class="memdesc:a880c3e1e8e63b9a12353853fb6aefa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple. <br /></td></tr>
<tr class="separator:a880c3e1e8e63b9a12353853fb6aefa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289ab037764b9f065d4b683cb186bda"><td class="memItemLeft" align="right" valign="top"><a id="aa289ab037764b9f065d4b683cb186bda"></a>
typedef struct tuple_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a></td></tr>
<tr class="memdesc:aa289ab037764b9f065d4b683cb186bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple iterator. <br /></td></tr>
<tr class="separator:aa289ab037764b9f065d4b683cb186bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbe4043908ad1b4a106689ad2da8814"><td class="memItemLeft" align="right" valign="top"><a id="acfbe4043908ad1b4a106689ad2da8814"></a>
typedef struct key_def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a></td></tr>
<tr class="memdesc:acfbe4043908ad1b4a106689ad2da8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:acfbe4043908ad1b4a106689ad2da8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302d3f85cf14f03ace911e9541c95c4d"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionPACKED.html">PACKED</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a></td></tr>
<tr class="memdesc:a302d3f85cf14f03ace911e9541c95c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public representation of a key part definition.  <a href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">More...</a><br /></td></tr>
<tr class="separator:a302d3f85cf14f03ace911e9541c95c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37ca06842be0fe827d5272493e2311f"><td class="memItemLeft" align="right" valign="top"><a id="aa37ca06842be0fe827d5272493e2311f"></a>
typedef struct box_function_ctx&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a></td></tr>
<tr class="memdesc:aa37ca06842be0fe827d5272493e2311f"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:aa37ca06842be0fe827d5272493e2311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dc8ff47cfc25ee92d0f74cdf459070"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a>) (const char *header, const char *header_end, const char *body, const char *body_end, void *ctx)</td></tr>
<tr class="memdesc:a19dc8ff47cfc25ee92d0f74cdf459070"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPROTO request handler signature: receives MsgPack encoded header and body, a context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a>, and must return one of the status codes from iproto_handler_status.  <a href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">More...</a><br /></td></tr>
<tr class="separator:a19dc8ff47cfc25ee92d0f74cdf459070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb59c79a9b32bb8a23204e89bced9d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a>) (void *ctx)</td></tr>
<tr class="memdesc:aa9eb59c79a9b32bb8a23204e89bced9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPROTO request handler destructor called when the corresponding handler is removed.  <a href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">More...</a><br /></td></tr>
<tr class="separator:aa9eb59c79a9b32bb8a23204e89bced9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="memItemLeft" align="right" valign="top"><a id="a2b04d0397e455b7ed42b530c1c1ea9e6"></a>
typedef struct iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a></td></tr>
<tr class="memdesc:a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a2b04d0397e455b7ed42b530c1c1ea9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49d5e355555804f6b46b79513715be8"><td class="memItemLeft" align="right" valign="top"><a id="ad49d5e355555804f6b46b79513715be8"></a>
typedef struct error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a></td></tr>
<tr class="memdesc:ad49d5e355555804f6b46b79513715be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error - contains information about error. <br /></td></tr>
<tr class="separator:ad49d5e355555804f6b46b79513715be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d13f137e4bdb8c852ea04637da58d"><td class="memItemLeft" align="right" valign="top">typedef struct box_latch&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a></td></tr>
<tr class="memdesc:a923d13f137e4bdb8c852ea04637da58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">More...</a><br /></td></tr>
<tr class="separator:a923d13f137e4bdb8c852ea04637da58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d26cf0c54dfa5e878e95ca0f73202a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structbox__decimal.html">box_decimal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a></td></tr>
<tr class="memdesc:a90d26cf0c54dfa5e878e95ca0f73202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a decimal number.  <a href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">More...</a><br /></td></tr>
<tr class="separator:a90d26cf0c54dfa5e878e95ca0f73202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af667a90dfe6a8cc25b510af73d98bb82"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a> { <br />
&#160;&#160;<b>S_FATAL</b>
, <br />
&#160;&#160;<b>S_SYSERROR</b>
, <br />
&#160;&#160;<b>S_ERROR</b>
, <br />
&#160;&#160;<b>S_CRIT</b>
, <br />
&#160;&#160;<b>S_WARN</b>
, <br />
&#160;&#160;<b>S_INFO</b>
, <br />
&#160;&#160;<b>S_VERBOSE</b>
, <br />
&#160;&#160;<b>S_DEBUG</b>
<br />
 }</td></tr>
<tr class="memdesc:af667a90dfe6a8cc25b510af73d98bb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">More...</a><br /></td></tr>
<tr class="separator:af667a90dfe6a8cc25b510af73d98bb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="memItemLeft" align="right" valign="top"><a id="ade0789f1bee95be5f9005c6ff4e0b2ad"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ade0789f1bee95be5f9005c6ff4e0b2ad">say_format</a> { <br />
&#160;&#160;<b>SF_PLAIN</b>
, <br />
&#160;&#160;<b>SF_JSON</b>
, <br />
&#160;&#160;<b>say_format_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log formats. <br /></td></tr>
<tr class="separator:ade0789f1bee95be5f9005c6ff4e0b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4e556d3f75a54e162feaa8e9451cfce7">COIO_READ</a> = 0x1
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba9ccd504861956d107f717efa66b3f1b7">COIO_WRITE</a> = 0x2
<br />
 }</td></tr>
<tr class="memdesc:a06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a06fc87d81c62e9abb8790b6e5713c55b">More...</a><br /></td></tr>
<tr class="separator:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d527c62a52f85cb173c79c31d20ce1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">txn_isolation_level</a> { <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a4f9fb36818af61558b13124ca0e02363">TXN_ISOLATION_DEFAULT</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a351aceaaa55693a90f5e33103d051947">TXN_ISOLATION_READ_COMMITTED</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1ab2411f8d6a9d68367da464d9fcff932f">TXN_ISOLATION_READ_CONFIRMED</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1afa0bc338b3e678625a61d16254991c7b">TXN_ISOLATION_BEST_EFFORT</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a6236950c80e86644457d27e158639b60">TXN_ISOLATION_LINEARIZABLE</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1a8e225c05de0c630a787eb113f64e3af4">txn_isolation_level_MAX</a>
<br />
 }</td></tr>
<tr class="memdesc:af2d527c62a52f85cb173c79c31d20ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">More...</a><br /></td></tr>
<tr class="separator:af2d527c62a52f85cb173c79c31d20ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top"><a id="adf764cbdea00d65edcd07bb9953ad2b7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>BOX_KEY_PART_DEF_IS_NULLABLE</b> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<b>BOX_KEY_PART_DEF_EXCLUDE_NULL</b> = 1 &lt;&lt; 1
<br />
 }</td></tr>
<tr class="memdesc:adf764cbdea00d65edcd07bb9953ad2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key part definition flags. <br /></td></tr>
<tr class="separator:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb83031ce9923c84392b4e92f956b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>BOX_KEY_PART_DEF_T_SIZE</b> = 64
 }</td></tr>
<tr class="memdesc:a99fb83031ce9923c84392b4e92f956b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is recommended to verify size of &lt;box_key_part_def_t&gt; against this constant on the module side at build time.  <a href="module_8h.html#a99fb83031ce9923c84392b4e92f956b5">More...</a><br /></td></tr>
<tr class="separator:a99fb83031ce9923c84392b4e92f956b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e6ca114114786cc23f3d5a1f8d14bf"><td class="memItemLeft" align="right" valign="top"><a id="af4e6ca114114786cc23f3d5a1f8d14bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af4e6ca114114786cc23f3d5a1f8d14bf">field_type</a> { <br />
&#160;&#160;<b>FIELD_TYPE_ANY</b> = 0
, <br />
&#160;&#160;<b>FIELD_TYPE_UNSIGNED</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_STRING</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_NUMBER</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DOUBLE</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INTEGER</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_BOOLEAN</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_VARBINARY</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_SCALAR</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DECIMAL</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_UUID</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_DATETIME</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_INTERVAL</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_ARRAY</b>
, <br />
&#160;&#160;<b>FIELD_TYPE_MAP</b>
, <br />
&#160;&#160;<b>field_type_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:af4e6ca114114786cc23f3d5a1f8d14bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:af4e6ca114114786cc23f3d5a1f8d14bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b7e2d98df6589252f8ede07932619"><td class="memItemLeft" align="right" valign="top"><a id="ac42b7e2d98df6589252f8ede07932619"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>on_conflict_action</b> { <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_NONE</b> = 0
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_ROLLBACK</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_ABORT</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_FAIL</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_IGNORE</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_REPLACE</b>
, <br />
&#160;&#160;<b>ON_CONFLICT_ACTION_DEFAULT</b>
, <br />
&#160;&#160;<b>on_conflict_action_MAX</b>
<br />
 }</td></tr>
<tr class="separator:ac42b7e2d98df6589252f8ede07932619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6126af1d45847bc59afa0aa3216b04"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a05cae1bfc9671a38779ffd9dde4d7f58">BOX_SYSTEM_ID_MIN</a> = 256
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ab14386b6fac3c938ed3a3b614510bb72">BOX_VINYL_DEFERRED_DELETE_ID</a> = 257
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a97f8ff937bc22208ebe19175eb0016a0">BOX_SCHEMA_ID</a> = 272
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a3bcd934a5e27f4aee628e875fd422af5">BOX_COLLATION_ID</a> = 276
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a3879bb29a2f51b4de4a923e4d6ba1b63">BOX_VCOLLATION_ID</a> = 277
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a2f5e17bb60cab866ec35b516c75c686a">BOX_SPACE_ID</a> = 280
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04abd4d512ca7fdebf9ec1a6bf7f11e1840">BOX_VSPACE_ID</a> = 281
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a43c8f5e53b0c9db9be2da424c152cec9">BOX_SEQUENCE_ID</a> = 284
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ad41b03d39d656d7612c911d8a60582c3">BOX_SEQUENCE_DATA_ID</a> = 285
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04adb9d519142826402c9efc166df12428e">BOX_VSEQUENCE_ID</a> = 286
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a482bf0fb6fc52ff01f40edb92705c95f">BOX_INDEX_ID</a> = 288
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ac27ac3d0508d4e5f19f91053f7971cb7">BOX_VINDEX_ID</a> = 289
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a744b39a5e9efc8559776daba88b01dd3">BOX_FUNC_ID</a> = 296
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a8cb7f39326f7dfc0afcf9dc32f5314da">BOX_VFUNC_ID</a> = 297
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a0f673849e4f92136273e92af04637e81">BOX_USER_ID</a> = 304
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ab508bf1accff87e8422bb32785e505bb">BOX_VUSER_ID</a> = 305
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a1bbd73fc6936dfa1977c7ea18677c4f9">BOX_PRIV_ID</a> = 312
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a37bb51c69ca47d95c4ce5777c9640613">BOX_VPRIV_ID</a> = 313
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ab05d38e39c97e255ecaf3e48db943d62">BOX_CLUSTER_ID</a> = 320
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04add17b7c9ec4c6322a8344e00e8c25c62">BOX_TRIGGER_ID</a> = 328
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a41c61daeecfce31f01f55ac6eb971f72">BOX_TRUNCATE_ID</a> = 330
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ad4db1b50b1f6446f75a8db82e0327374">BOX_SPACE_SEQUENCE_ID</a> = 340
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04abe8471169b17b8ad853f4bd201c71785">BOX_VSPACE_SEQUENCE_ID</a> = 341
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a99e954bd1de658ba6586d7354fe06378">BOX_FK_CONSTRAINT_ID</a> = 356
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04ae97c7da44f193fcfea35afe2dfe98dc8">BOX_CK_CONSTRAINT_ID</a> = 364
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a5590980099004e7b53cd73cd5418f98b">BOX_FUNC_INDEX_ID</a> = 372
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04a03e08a677af627a4199839a08b9020e8">BOX_SESSION_SETTINGS_ID</a> = 380
, <br />
&#160;&#160;<a class="el" href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04abb87df1b61192ee3aea178534071b9cd">BOX_SYSTEM_ID_MAX</a> = 511
, <br />
&#160;&#160;<b>BOX_ID_NIL</b> = 2147483647
<br />
 }</td></tr>
<tr class="memdesc:abc6126af1d45847bc59afa0aa3216b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#abc6126af1d45847bc59afa0aa3216b04">More...</a><br /></td></tr>
<tr class="separator:abc6126af1d45847bc59afa0aa3216b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dab01cb6470a8177e9618558523ff7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a> { <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7ba964fc0581c3169c5047abaebcbc6a190">IPROTO_HANDLER_OK</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7ba3838e3dc0206744064024e6948f5f214">IPROTO_HANDLER_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7badb3e2b86bb68c8ef55af839fc59a63a5">IPROTO_HANDLER_FALLBACK</a>
<br />
 }</td></tr>
<tr class="memdesc:a4dab01cb6470a8177e9618558523ff7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes for IPROTO request handlers.  <a href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">More...</a><br /></td></tr>
<tr class="separator:a4dab01cb6470a8177e9618558523ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a> { <br />
&#160;&#160;<b>ITER_EQ</b> = 0
, <br />
&#160;&#160;<b>ITER_REQ</b> = 1
, <br />
&#160;&#160;<b>ITER_ALL</b> = 2
, <br />
&#160;&#160;<b>ITER_LT</b> = 3
, <br />
&#160;&#160;<b>ITER_LE</b> = 4
, <br />
&#160;&#160;<b>ITER_GE</b> = 5
, <br />
&#160;&#160;<b>ITER_GT</b> = 6
, <br />
&#160;&#160;<b>ITER_BITS_ALL_SET</b> = 7
, <br />
&#160;&#160;<b>ITER_BITS_ANY_SET</b> = 8
, <br />
&#160;&#160;<b>ITER_BITS_ALL_NOT_SET</b> = 9
, <br />
&#160;&#160;<b>ITER_OVERLAPS</b> = 10
, <br />
&#160;&#160;<b>ITER_NEIGHBOR</b> = 11
, <br />
&#160;&#160;<b>iterator_type_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">More...</a><br /></td></tr>
<tr class="separator:a2693ce4bd8fa71e8ac1e5272fc64d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029e9d16d637a97b37560ccf24c4adce"><td class="memItemLeft" align="right" valign="top"><a id="a029e9d16d637a97b37560ccf24c4adce"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce">box_error_code</a> { <br />
&#160;&#160;<b>ER_UNKNOWN</b>
, <br />
&#160;&#160;<b>ER_ILLEGAL_PARAMS</b>
, <br />
&#160;&#160;<b>ER_MEMORY_ISSUE</b>
, <br />
&#160;&#160;<b>ER_TUPLE_FOUND</b>
, <br />
&#160;&#160;<b>ER_TUPLE_NOT_FOUND</b>
, <br />
&#160;&#160;<b>ER_UNSUPPORTED</b>
, <br />
&#160;&#160;<b>ER_NONMASTER</b>
, <br />
&#160;&#160;<b>ER_READONLY</b>
, <br />
&#160;&#160;<b>ER_INJECTION</b>
, <br />
&#160;&#160;<b>ER_CREATE_SPACE</b>
, <br />
&#160;&#160;<b>ER_SPACE_EXISTS</b>
, <br />
&#160;&#160;<b>ER_DROP_SPACE</b>
, <br />
&#160;&#160;<b>ER_ALTER_SPACE</b>
, <br />
&#160;&#160;<b>ER_INDEX_TYPE</b>
, <br />
&#160;&#160;<b>ER_MODIFY_INDEX</b>
, <br />
&#160;&#160;<b>ER_LAST_DROP</b>
, <br />
&#160;&#160;<b>ER_TUPLE_FORMAT_LIMIT</b>
, <br />
&#160;&#160;<b>ER_DROP_PRIMARY_KEY</b>
, <br />
&#160;&#160;<b>ER_KEY_PART_TYPE</b>
, <br />
&#160;&#160;<b>ER_EXACT_MATCH</b>
, <br />
&#160;&#160;<b>ER_INVALID_MSGPACK</b>
, <br />
&#160;&#160;<b>ER_PROC_RET</b>
, <br />
&#160;&#160;<b>ER_TUPLE_NOT_ARRAY</b>
, <br />
&#160;&#160;<b>ER_FIELD_TYPE</b>
, <br />
&#160;&#160;<b>ER_INDEX_PART_TYPE_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_UPDATE_SPLICE</b>
, <br />
&#160;&#160;<b>ER_UPDATE_ARG_TYPE</b>
, <br />
&#160;&#160;<b>ER_FORMAT_MISMATCH_INDEX_PART</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_UPDATE_OP</b>
, <br />
&#160;&#160;<b>ER_UPDATE_FIELD</b>
, <br />
&#160;&#160;<b>ER_FUNCTION_TX_ACTIVE</b>
, <br />
&#160;&#160;<b>ER_KEY_PART_COUNT</b>
, <br />
&#160;&#160;<b>ER_PROC_LUA</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_PROC</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_TRIGGER</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_INDEX_ID</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_SPACE</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NO</b>
, <br />
&#160;&#160;<b>ER_EXACT_FIELD_COUNT</b>
, <br />
&#160;&#160;<b>ER_FIELD_MISSING</b>
, <br />
&#160;&#160;<b>ER_WAL_IO</b>
, <br />
&#160;&#160;<b>ER_MORE_THAN_ONE_TUPLE</b>
, <br />
&#160;&#160;<b>ER_ACCESS_DENIED</b>
, <br />
&#160;&#160;<b>ER_CREATE_USER</b>
, <br />
&#160;&#160;<b>ER_DROP_USER</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_USER</b>
, <br />
&#160;&#160;<b>ER_USER_EXISTS</b>
, <br />
&#160;&#160;<b>ER_CREDS_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_REQUEST_TYPE</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_SCHEMA_OBJECT</b>
, <br />
&#160;&#160;<b>ER_CREATE_FUNCTION</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_FUNCTION</b>
, <br />
&#160;&#160;<b>ER_FUNCTION_EXISTS</b>
, <br />
&#160;&#160;<b>ER_BEFORE_REPLACE_RET</b>
, <br />
&#160;&#160;<b>ER_MULTISTATEMENT_TRANSACTION</b>
, <br />
&#160;&#160;<b>ER_TRIGGER_EXISTS</b>
, <br />
&#160;&#160;<b>ER_USER_MAX</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_ENGINE</b>
, <br />
&#160;&#160;<b>ER_RELOAD_CFG</b>
, <br />
&#160;&#160;<b>ER_CFG</b>
, <br />
&#160;&#160;<b>ER_SAVEPOINT_EMPTY_TX</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_SAVEPOINT</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_REPLICA</b>
, <br />
&#160;&#160;<b>ER_REPLICASET_UUID_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_INVALID_UUID</b>
, <br />
&#160;&#160;<b>ER_REPLICASET_UUID_IS_RO</b>
, <br />
&#160;&#160;<b>ER_INSTANCE_UUID_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_REPLICA_ID_IS_RESERVED</b>
, <br />
&#160;&#160;<b>ER_INVALID_ORDER</b>
, <br />
&#160;&#160;<b>ER_MISSING_REQUEST_FIELD</b>
, <br />
&#160;&#160;<b>ER_IDENTIFIER</b>
, <br />
&#160;&#160;<b>ER_DROP_FUNCTION</b>
, <br />
&#160;&#160;<b>ER_ITERATOR_TYPE</b>
, <br />
&#160;&#160;<b>ER_REPLICA_MAX</b>
, <br />
&#160;&#160;<b>ER_INVALID_XLOG</b>
, <br />
&#160;&#160;<b>ER_INVALID_XLOG_NAME</b>
, <br />
&#160;&#160;<b>ER_INVALID_XLOG_ORDER</b>
, <br />
&#160;&#160;<b>ER_NO_CONNECTION</b>
, <br />
&#160;&#160;<b>ER_TIMEOUT</b>
, <br />
&#160;&#160;<b>ER_ACTIVE_TRANSACTION</b>
, <br />
&#160;&#160;<b>ER_CURSOR_NO_TRANSACTION</b>
, <br />
&#160;&#160;<b>ER_CROSS_ENGINE_TRANSACTION</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_ROLE</b>
, <br />
&#160;&#160;<b>ER_ROLE_EXISTS</b>
, <br />
&#160;&#160;<b>ER_CREATE_ROLE</b>
, <br />
&#160;&#160;<b>ER_INDEX_EXISTS</b>
, <br />
&#160;&#160;<b>ER_SESSION_CLOSED</b>
, <br />
&#160;&#160;<b>ER_ROLE_LOOP</b>
, <br />
&#160;&#160;<b>ER_GRANT</b>
, <br />
&#160;&#160;<b>ER_PRIV_GRANTED</b>
, <br />
&#160;&#160;<b>ER_ROLE_GRANTED</b>
, <br />
&#160;&#160;<b>ER_PRIV_NOT_GRANTED</b>
, <br />
&#160;&#160;<b>ER_ROLE_NOT_GRANTED</b>
, <br />
&#160;&#160;<b>ER_MISSING_SNAPSHOT</b>
, <br />
&#160;&#160;<b>ER_CANT_UPDATE_PRIMARY_KEY</b>
, <br />
&#160;&#160;<b>ER_UPDATE_INTEGER_OVERFLOW</b>
, <br />
&#160;&#160;<b>ER_GUEST_USER_PASSWORD</b>
, <br />
&#160;&#160;<b>ER_TRANSACTION_CONFLICT</b>
, <br />
&#160;&#160;<b>ER_UNSUPPORTED_PRIV</b>
, <br />
&#160;&#160;<b>ER_LOAD_FUNCTION</b>
, <br />
&#160;&#160;<b>ER_FUNCTION_LANGUAGE</b>
, <br />
&#160;&#160;<b>ER_RTREE_RECT</b>
, <br />
&#160;&#160;<b>ER_PROC_C</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_RTREE_INDEX_DISTANCE_TYPE</b>
, <br />
&#160;&#160;<b>ER_PROTOCOL</b>
, <br />
&#160;&#160;<b>ER_UPSERT_UNIQUE_SECONDARY_KEY</b>
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_RECORD</b>
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_PARTS</b>
, <br />
&#160;&#160;<b>ER_WRONG_INDEX_OPTIONS</b>
, <br />
&#160;&#160;<b>ER_WRONG_SCHEMA_VERSION</b>
, <br />
&#160;&#160;<b>ER_MEMTX_MAX_TUPLE_SIZE</b>
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_OPTIONS</b>
, <br />
&#160;&#160;<b>ER_UNSUPPORTED_INDEX_FEATURE</b>
, <br />
&#160;&#160;<b>ER_VIEW_IS_RO</b>
, <br />
&#160;&#160;<b>ER_NO_TRANSACTION</b>
, <br />
&#160;&#160;<b>ER_SYSTEM</b>
, <br />
&#160;&#160;<b>ER_LOADING</b>
, <br />
&#160;&#160;<b>ER_CONNECTION_TO_SELF</b>
, <br />
&#160;&#160;<b>ER_KEY_PART_IS_TOO_LONG</b>
, <br />
&#160;&#160;<b>ER_COMPRESSION</b>
, <br />
&#160;&#160;<b>ER_CHECKPOINT_IN_PROGRESS</b>
, <br />
&#160;&#160;<b>ER_SUB_STMT_MAX</b>
, <br />
&#160;&#160;<b>ER_COMMIT_IN_SUB_STMT</b>
, <br />
&#160;&#160;<b>ER_ROLLBACK_IN_SUB_STMT</b>
, <br />
&#160;&#160;<b>ER_DECOMPRESSION</b>
, <br />
&#160;&#160;<b>ER_INVALID_XLOG_TYPE</b>
, <br />
&#160;&#160;<b>ER_ALREADY_RUNNING</b>
, <br />
&#160;&#160;<b>ER_INDEX_FIELD_COUNT_LIMIT</b>
, <br />
&#160;&#160;<b>ER_LOCAL_INSTANCE_ID_IS_READ_ONLY</b>
, <br />
&#160;&#160;<b>ER_BACKUP_IN_PROGRESS</b>
, <br />
&#160;&#160;<b>ER_READ_VIEW_ABORTED</b>
, <br />
&#160;&#160;<b>ER_INVALID_INDEX_FILE</b>
, <br />
&#160;&#160;<b>ER_INVALID_RUN_FILE</b>
, <br />
&#160;&#160;<b>ER_INVALID_VYLOG_FILE</b>
, <br />
&#160;&#160;<b>ER_CASCADE_ROLLBACK</b>
, <br />
&#160;&#160;<b>ER_VY_QUOTA_TIMEOUT</b>
, <br />
&#160;&#160;<b>ER_PARTIAL_KEY</b>
, <br />
&#160;&#160;<b>ER_TRUNCATE_SYSTEM_SPACE</b>
, <br />
&#160;&#160;<b>ER_LOAD_MODULE</b>
, <br />
&#160;&#160;<b>ER_VINYL_MAX_TUPLE_SIZE</b>
, <br />
&#160;&#160;<b>ER_WRONG_DD_VERSION</b>
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_FORMAT</b>
, <br />
&#160;&#160;<b>ER_CREATE_SEQUENCE</b>
, <br />
&#160;&#160;<b>ER_ALTER_SEQUENCE</b>
, <br />
&#160;&#160;<b>ER_DROP_SEQUENCE</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_SEQUENCE</b>
, <br />
&#160;&#160;<b>ER_SEQUENCE_EXISTS</b>
, <br />
&#160;&#160;<b>ER_SEQUENCE_OVERFLOW</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_INDEX_NAME</b>
, <br />
&#160;&#160;<b>ER_SPACE_FIELD_IS_DUPLICATE</b>
, <br />
&#160;&#160;<b>ER_CANT_CREATE_COLLATION</b>
, <br />
&#160;&#160;<b>ER_WRONG_COLLATION_OPTIONS</b>
, <br />
&#160;&#160;<b>ER_NULLABLE_PRIMARY</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NAME_IN_SPACE</b>
, <br />
&#160;&#160;<b>ER_TRANSACTION_YIELD</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_GROUP</b>
, <br />
&#160;&#160;<b>ER_SQL_BIND_VALUE</b>
, <br />
&#160;&#160;<b>ER_SQL_BIND_TYPE</b>
, <br />
&#160;&#160;<b>ER_SQL_BIND_PARAMETER_MAX</b>
, <br />
&#160;&#160;<b>ER_SQL_EXECUTE</b>
, <br />
&#160;&#160;<b>ER_UPDATE_DECIMAL_OVERFLOW</b>
, <br />
&#160;&#160;<b>ER_SQL_BIND_NOT_FOUND</b>
, <br />
&#160;&#160;<b>ER_ACTION_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_VIEW_MISSING_SQL</b>
, <br />
&#160;&#160;<b>ER_FOREIGN_KEY_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_MODULE</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_COLLATION</b>
, <br />
&#160;&#160;<b>ER_CREATE_FK_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_DROP_FK_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_CONSTRAINT_EXISTS</b>
, <br />
&#160;&#160;<b>ER_SQL_TYPE_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_ROWID_OVERFLOW</b>
, <br />
&#160;&#160;<b>ER_DROP_COLLATION</b>
, <br />
&#160;&#160;<b>ER_ILLEGAL_COLLATION_MIX</b>
, <br />
&#160;&#160;<b>ER_SQL_NO_SUCH_PRAGMA</b>
, <br />
&#160;&#160;<b>ER_SQL_CANT_RESOLVE_FIELD</b>
, <br />
&#160;&#160;<b>ER_INDEX_EXISTS_IN_SPACE</b>
, <br />
&#160;&#160;<b>ER_INCONSISTENT_TYPES</b>
, <br />
&#160;&#160;<b>ER_SQL_SYNTAX_WITH_POS</b>
, <br />
&#160;&#160;<b>ER_SQL_STACK_OVERFLOW</b>
, <br />
&#160;&#160;<b>ER_SQL_SELECT_WILDCARD</b>
, <br />
&#160;&#160;<b>ER_SQL_STATEMENT_EMPTY</b>
, <br />
&#160;&#160;<b>ER_SQL_KEYWORD_IS_RESERVED</b>
, <br />
&#160;&#160;<b>ER_SQL_SYNTAX_NEAR_TOKEN</b>
, <br />
&#160;&#160;<b>ER_SQL_UNKNOWN_TOKEN</b>
, <br />
&#160;&#160;<b>ER_SQL_PARSER_GENERIC</b>
, <br />
&#160;&#160;<b>ER_SQL_ANALYZE_ARGUMENT</b>
, <br />
&#160;&#160;<b>ER_SQL_COLUMN_COUNT_MAX</b>
, <br />
&#160;&#160;<b>ER_HEX_LITERAL_MAX</b>
, <br />
&#160;&#160;<b>ER_INT_LITERAL_MAX</b>
, <br />
&#160;&#160;<b>ER_SQL_PARSER_LIMIT</b>
, <br />
&#160;&#160;<b>ER_INDEX_DEF_UNSUPPORTED</b>
, <br />
&#160;&#160;<b>ER_CK_DEF_UNSUPPORTED</b>
, <br />
&#160;&#160;<b>ER_MULTIKEY_INDEX_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_CREATE_CK_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_CK_CONSTRAINT_FAILED</b>
, <br />
&#160;&#160;<b>ER_SQL_COLUMN_COUNT</b>
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_FUNC</b>
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_FORMAT</b>
, <br />
&#160;&#160;<b>ER_FUNC_INDEX_PARTS</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_FIELD_NAME</b>
, <br />
&#160;&#160;<b>ER_FUNC_WRONG_ARG_COUNT</b>
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_READONLY</b>
, <br />
&#160;&#160;<b>ER_SQL_FUNC_WRONG_RET_COUNT</b>
, <br />
&#160;&#160;<b>ER_FUNC_INVALID_RETURN_TYPE</b>
, <br />
&#160;&#160;<b>ER_SQL_PARSER_GENERIC_WITH_POS</b>
, <br />
&#160;&#160;<b>ER_REPLICA_NOT_ANON</b>
, <br />
&#160;&#160;<b>ER_CANNOT_REGISTER</b>
, <br />
&#160;&#160;<b>ER_SESSION_SETTING_INVALID_VALUE</b>
, <br />
&#160;&#160;<b>ER_SQL_PREPARE</b>
, <br />
&#160;&#160;<b>ER_WRONG_QUERY_ID</b>
, <br />
&#160;&#160;<b>ER_SEQUENCE_NOT_STARTED</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_SESSION_SETTING</b>
, <br />
&#160;&#160;<b>ER_UNCOMMITTED_FOREIGN_SYNC_TXNS</b>
, <br />
&#160;&#160;<b>ER_SYNC_MASTER_MISMATCH</b>
, <br />
&#160;&#160;<b>ER_SYNC_QUORUM_TIMEOUT</b>
, <br />
&#160;&#160;<b>ER_SYNC_ROLLBACK</b>
, <br />
&#160;&#160;<b>ER_TUPLE_METADATA_IS_TOO_BIG</b>
, <br />
&#160;&#160;<b>ER_XLOG_GAP</b>
, <br />
&#160;&#160;<b>ER_TOO_EARLY_SUBSCRIBE</b>
, <br />
&#160;&#160;<b>ER_SQL_CANT_ADD_AUTOINC</b>
, <br />
&#160;&#160;<b>ER_QUORUM_WAIT</b>
, <br />
&#160;&#160;<b>ER_INTERFERING_PROMOTE</b>
, <br />
&#160;&#160;<b>ER_ELECTION_DISABLED</b>
, <br />
&#160;&#160;<b>ER_TXN_ROLLBACK</b>
, <br />
&#160;&#160;<b>ER_NOT_LEADER</b>
, <br />
&#160;&#160;<b>ER_SYNC_QUEUE_UNCLAIMED</b>
, <br />
&#160;&#160;<b>ER_SYNC_QUEUE_FOREIGN</b>
, <br />
&#160;&#160;<b>ER_UNABLE_TO_PROCESS_IN_STREAM</b>
, <br />
&#160;&#160;<b>ER_UNABLE_TO_PROCESS_OUT_OF_STREAM</b>
, <br />
&#160;&#160;<b>ER_TRANSACTION_TIMEOUT</b>
, <br />
&#160;&#160;<b>ER_ACTIVE_TIMER</b>
, <br />
&#160;&#160;<b>ER_TUPLE_FIELD_COUNT_LIMIT</b>
, <br />
&#160;&#160;<b>ER_CREATE_CONSTRAINT</b>
, <br />
&#160;&#160;<b>ER_FIELD_CONSTRAINT_FAILED</b>
, <br />
&#160;&#160;<b>ER_TUPLE_CONSTRAINT_FAILED</b>
, <br />
&#160;&#160;<b>ER_CREATE_FOREIGN_KEY</b>
, <br />
&#160;&#160;<b>ER_FOREIGN_KEY_INTEGRITY</b>
, <br />
&#160;&#160;<b>ER_FIELD_FOREIGN_KEY_FAILED</b>
, <br />
&#160;&#160;<b>ER_COMPLEX_FOREIGN_KEY_FAILED</b>
, <br />
&#160;&#160;<b>ER_WRONG_SPACE_UPGRADE_OPTIONS</b>
, <br />
&#160;&#160;<b>ER_NO_ELECTION_QUORUM</b>
, <br />
&#160;&#160;<b>ER_SSL</b>
, <br />
&#160;&#160;<b>ER_SPLIT_BRAIN</b>
, <br />
&#160;&#160;<b>ER_OLD_TERM</b>
, <br />
&#160;&#160;<b>ER_INTERFERING_ELECTIONS</b>
, <br />
&#160;&#160;<b>ER_ITERATOR_POSITION</b>
, <br />
&#160;&#160;<b>ER_UNUSED</b>
, <br />
&#160;&#160;<b>ER_UNKNOWN_AUTH_METHOD</b>
, <br />
&#160;&#160;<b>ER_INVALID_AUTH_DATA</b>
, <br />
&#160;&#160;<b>ER_INVALID_AUTH_REQUEST</b>
, <br />
&#160;&#160;<b>ER_WEAK_PASSWORD</b>
, <br />
&#160;&#160;<b>ER_OLD_PASSWORD</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_SESSION</b>
, <br />
&#160;&#160;<b>ER_WRONG_SESSION_TYPE</b>
, <br />
&#160;&#160;<b>ER_PASSWORD_EXPIRED</b>
, <br />
&#160;&#160;<b>ER_AUTH_DELAY</b>
, <br />
&#160;&#160;<b>ER_AUTH_REQUIRED</b>
, <br />
&#160;&#160;<b>ER_SQL_SEQ_SCAN</b>
, <br />
&#160;&#160;<b>ER_NO_SUCH_EVENT</b>
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_NOT_UNANIMOUS</b>
, <br />
&#160;&#160;<b>ER_CANT_CHECK_BOOTSTRAP_LEADER</b>
, <br />
&#160;&#160;<b>ER_BOOTSTRAP_CONNECTION_NOT_TO_ALL</b>
, <br />
&#160;&#160;<b>ER_NIL_UUID</b>
, <br />
&#160;&#160;<b>ER_WRONG_FUNCTION_OPTIONS</b>
, <br />
&#160;&#160;<b>ER_MISSING_SYSTEM_SPACES</b>
, <br />
&#160;&#160;<b>box_error_code_MAX</b>
<br />
 }</td></tr>
<tr class="memdesc:a029e9d16d637a97b37560ccf24c4adce"><td class="mdescLeft">&#160;</td><td class="mdescRight">public <br /></td></tr>
<tr class="separator:a029e9d16d637a97b37560ccf24c4adce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a35d7a7fe53c673112e06ab78794216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4a35d7a7fe53c673112e06ab78794216">box_on_shutdown</a> (void *arg, int(*new_handler)(void *), int(*old_handler)(void *))</td></tr>
<tr class="memdesc:a4a35d7a7fe53c673112e06ab78794216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement Attributes }}}.  <a href="module_8h.html#a4a35d7a7fe53c673112e06ab78794216">More...</a><br /></td></tr>
<tr class="separator:a4a35d7a7fe53c673112e06ab78794216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9d5dc245f23922392835e55fccba9"><td class="memItemLeft" align="right" valign="top"><a id="a11d9d5dc245f23922392835e55fccba9"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>say_log_level_is_enabled</b> (int level)</td></tr>
<tr class="separator:a11d9d5dc245f23922392835e55fccba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f14b4a77bc8ce8ba99c67004083d23"><td class="memItemLeft" align="right" valign="top"><a id="aa0f14b4a77bc8ce8ba99c67004083d23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa0f14b4a77bc8ce8ba99c67004083d23">CFORMAT</a> (printf, 5, 6) extern <a class="el" href="module_8h.html#a24a548551bdc95d156210ec216ded4f9">sayfunc_t</a> _say</td></tr>
<tr class="memdesc:aa0f14b4a77bc8ce8ba99c67004083d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used to implement <a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf" title="Format and print a message to Tarantool log file.">say()</a> macros. <br /></td></tr>
<tr class="separator:aa0f14b4a77bc8ce8ba99c67004083d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bffd74e9753961e0568d85db8e2304b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9bffd74e9753961e0568d85db8e2304b">_say_strerror</a> (int errnum)</td></tr>
<tr class="memdesc:a9bffd74e9753961e0568d85db8e2304b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that implements MT-Safe strerror().  <a href="module_8h.html#a9bffd74e9753961e0568d85db8e2304b">More...</a><br /></td></tr>
<tr class="separator:a9bffd74e9753961e0568d85db8e2304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615728b106aa274514dea63a9a693fd1"><td class="memItemLeft" align="right" valign="top">struct fiber_attr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a615728b106aa274514dea63a9a693fd1">fiber_attr_new</a> (void)</td></tr>
<tr class="memdesc:a615728b106aa274514dea63a9a693fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber attribute container and initialize it with default parameters.  <a href="module_8h.html#a615728b106aa274514dea63a9a693fd1">More...</a><br /></td></tr>
<tr class="separator:a615728b106aa274514dea63a9a693fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4003e7d28985f1573cf3faf8b4d38ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac4003e7d28985f1573cf3faf8b4d38ee">fiber_attr_delete</a> (struct fiber_attr *fiber_attr)</td></tr>
<tr class="memdesc:ac4003e7d28985f1573cf3faf8b4d38ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the fiber_attr and free all allocated resources.  <a href="module_8h.html#ac4003e7d28985f1573cf3faf8b4d38ee">More...</a><br /></td></tr>
<tr class="separator:ac4003e7d28985f1573cf3faf8b4d38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f42c1a444922edf2163806c5433ae1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4f42c1a444922edf2163806c5433ae1a">fiber_attr_setstacksize</a> (struct fiber_attr *fiber_attr, size_t stack_size)</td></tr>
<tr class="memdesc:a4f42c1a444922edf2163806c5433ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stack size for the fiber attribute.  <a href="module_8h.html#a4f42c1a444922edf2163806c5433ae1a">More...</a><br /></td></tr>
<tr class="separator:a4f42c1a444922edf2163806c5433ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad628f573827cf2393f0849c194719a94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad628f573827cf2393f0849c194719a94">fiber_attr_getstacksize</a> (struct fiber_attr *fiber_attr)</td></tr>
<tr class="memdesc:ad628f573827cf2393f0849c194719a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stack size from the fiber attribute.  <a href="module_8h.html#ad628f573827cf2393f0849c194719a94">More...</a><br /></td></tr>
<tr class="separator:ad628f573827cf2393f0849c194719a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de8ea84fe46359b0a3dc9d6a401e0ab"><td class="memItemLeft" align="right" valign="top"><a id="a6de8ea84fe46359b0a3dc9d6a401e0ab"></a>
struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6de8ea84fe46359b0a3dc9d6a401e0ab">fiber_self</a> (void)</td></tr>
<tr class="memdesc:a6de8ea84fe46359b0a3dc9d6a401e0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current fiber. <br /></td></tr>
<tr class="separator:a6de8ea84fe46359b0a3dc9d6a401e0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d955b4ac367ab3b95c6c0d0df31050"><td class="memItemLeft" align="right" valign="top">struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac0d955b4ac367ab3b95c6c0d0df31050">fiber_new</a> (const char *name, <a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a> f)</td></tr>
<tr class="memdesc:ac0d955b4ac367ab3b95c6c0d0df31050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber.  <a href="module_8h.html#ac0d955b4ac367ab3b95c6c0d0df31050">More...</a><br /></td></tr>
<tr class="separator:ac0d955b4ac367ab3b95c6c0d0df31050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8dbdb4656ce6c89ea1e3215c0d6adf"><td class="memItemLeft" align="right" valign="top">struct fiber *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8e8dbdb4656ce6c89ea1e3215c0d6adf">fiber_new_ex</a> (const char *name, const struct fiber_attr *fiber_attr, <a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a> f)</td></tr>
<tr class="memdesc:a8e8dbdb4656ce6c89ea1e3215c0d6adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new fiber with defined attributes.  <a href="module_8h.html#a8e8dbdb4656ce6c89ea1e3215c0d6adf">More...</a><br /></td></tr>
<tr class="separator:a8e8dbdb4656ce6c89ea1e3215c0d6adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5beb40f119b9400bb57b81820b24ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaa5beb40f119b9400bb57b81820b24ff">fiber_yield</a> (void)</td></tr>
<tr class="memdesc:aaa5beb40f119b9400bb57b81820b24ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return control to another fiber and wait until it'll be woken.  <a href="module_8h.html#aaa5beb40f119b9400bb57b81820b24ff">More...</a><br /></td></tr>
<tr class="separator:aaa5beb40f119b9400bb57b81820b24ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca18eb68ebf89507d4cf5eb3c402cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2">fiber_start</a> (struct fiber *callee,...)</td></tr>
<tr class="memdesc:abca18eb68ebf89507d4cf5eb3c402cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start execution of created fiber.  <a href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2">More...</a><br /></td></tr>
<tr class="separator:abca18eb68ebf89507d4cf5eb3c402cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac596a2d875dcfa8477bbfc1ccc7b809d">fiber_set_ctx</a> (struct fiber *f, void *f_arg)</td></tr>
<tr class="memdesc:ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a pointer to context for the fiber.  <a href="module_8h.html#ac596a2d875dcfa8477bbfc1ccc7b809d">More...</a><br /></td></tr>
<tr class="separator:ac596a2d875dcfa8477bbfc1ccc7b809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292f6964c2f9336780175623c94f0be2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a292f6964c2f9336780175623c94f0be2">fiber_get_ctx</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a292f6964c2f9336780175623c94f0be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context for the fiber which was set via the fiber_set_ctx function.  <a href="module_8h.html#a292f6964c2f9336780175623c94f0be2">More...</a><br /></td></tr>
<tr class="separator:a292f6964c2f9336780175623c94f0be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661de7f72aa265ff6ffcb8b3acfafe40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40">fiber_wakeup</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a661de7f72aa265ff6ffcb8b3acfafe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt a synchronous wait of a fiber.  <a href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40">More...</a><br /></td></tr>
<tr class="separator:a661de7f72aa265ff6ffcb8b3acfafe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5b700b2122f08e6bc1298ac7eb0435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435">fiber_cancel</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a9a5b700b2122f08e6bc1298ac7eb0435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the subject fiber.  <a href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435">More...</a><br /></td></tr>
<tr class="separator:a9a5b700b2122f08e6bc1298ac7eb0435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4078cbddc22b0ed941548f86672224d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4078cbddc22b0ed941548f86672224d9">fiber_set_cancellable</a> (bool yesno)</td></tr>
<tr class="memdesc:a4078cbddc22b0ed941548f86672224d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="module_8h.html#a4078cbddc22b0ed941548f86672224d9">More...</a><br /></td></tr>
<tr class="separator:a4078cbddc22b0ed941548f86672224d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208">fiber_set_joinable</a> (struct fiber *fiber, bool yesno)</td></tr>
<tr class="memdesc:a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fiber to be joinable (false by default).  <a href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208">More...</a><br /></td></tr>
<tr class="separator:a8ee4e98a4e9c2239b5d7eb98c2b0b208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ac22e89f3fdab0556cc5f6922f0f59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a58ac22e89f3fdab0556cc5f6922f0f59">fiber_join</a> (struct fiber *f)</td></tr>
<tr class="memdesc:a58ac22e89f3fdab0556cc5f6922f0f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the fiber is dead and then move its execution status to the caller.  <a href="module_8h.html#a58ac22e89f3fdab0556cc5f6922f0f59">More...</a><br /></td></tr>
<tr class="separator:a58ac22e89f3fdab0556cc5f6922f0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e8a263a2592320b7260095f5c10f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a676e8a263a2592320b7260095f5c10f3">fiber_join_timeout</a> (struct fiber *f, double timeout)</td></tr>
<tr class="memdesc:a676e8a263a2592320b7260095f5c10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the fiber is dead or timeout exceeded.  <a href="module_8h.html#a676e8a263a2592320b7260095f5c10f3">More...</a><br /></td></tr>
<tr class="separator:a676e8a263a2592320b7260095f5c10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab0816e3ddf7e11b448926569e6bc49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0ab0816e3ddf7e11b448926569e6bc49">fiber_sleep</a> (double s)</td></tr>
<tr class="memdesc:a0ab0816e3ddf7e11b448926569e6bc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current fiber to sleep for at least 's' seconds.  <a href="module_8h.html#a0ab0816e3ddf7e11b448926569e6bc49">More...</a><br /></td></tr>
<tr class="separator:a0ab0816e3ddf7e11b448926569e6bc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d46a2ac9d787bc69b61ce09938587"><td class="memItemLeft" align="right" valign="top"><a id="a972d46a2ac9d787bc69b61ce09938587"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a972d46a2ac9d787bc69b61ce09938587">fiber_is_cancelled</a> (void)</td></tr>
<tr class="memdesc:a972d46a2ac9d787bc69b61ce09938587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check current fiber for cancellation (it must be checked manually). <br /></td></tr>
<tr class="separator:a972d46a2ac9d787bc69b61ce09938587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077a6068c998d2e548168be5e1a6008f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a077a6068c998d2e548168be5e1a6008f">fiber_time</a> (void)</td></tr>
<tr class="memdesc:a077a6068c998d2e548168be5e1a6008f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as double (cheap).  <a href="module_8h.html#a077a6068c998d2e548168be5e1a6008f">More...</a><br /></td></tr>
<tr class="separator:a077a6068c998d2e548168be5e1a6008f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e9fb25b47b6090a587c92aaf536aed"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae1e9fb25b47b6090a587c92aaf536aed">fiber_time64</a> (void)</td></tr>
<tr class="memdesc:ae1e9fb25b47b6090a587c92aaf536aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as 64-bit int.  <a href="module_8h.html#ae1e9fb25b47b6090a587c92aaf536aed">More...</a><br /></td></tr>
<tr class="separator:ae1e9fb25b47b6090a587c92aaf536aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c835fac5180f57e01c388a95440d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0e1c835fac5180f57e01c388a95440d5">fiber_clock</a> (void)</td></tr>
<tr class="memdesc:a0e1c835fac5180f57e01c388a95440d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as double (cheap).  <a href="module_8h.html#a0e1c835fac5180f57e01c388a95440d5">More...</a><br /></td></tr>
<tr class="separator:a0e1c835fac5180f57e01c388a95440d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed4eb4281eaa96a74c6e052995af645"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8ed4eb4281eaa96a74c6e052995af645">fiber_clock64</a> (void)</td></tr>
<tr class="memdesc:a8ed4eb4281eaa96a74c6e052995af645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report loop begin time as 64-bit int.  <a href="module_8h.html#a8ed4eb4281eaa96a74c6e052995af645">More...</a><br /></td></tr>
<tr class="separator:a8ed4eb4281eaa96a74c6e052995af645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0122a4705796fd32c2a54e218c2ff8"><td class="memItemLeft" align="right" valign="top"><a id="a1d0122a4705796fd32c2a54e218c2ff8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1d0122a4705796fd32c2a54e218c2ff8">fiber_reschedule</a> (void)</td></tr>
<tr class="memdesc:a1d0122a4705796fd32c2a54e218c2ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule fiber to end of event loop cycle. <br /></td></tr>
<tr class="separator:a1d0122a4705796fd32c2a54e218c2ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1439a55742e08aed110099945d6eb8"><td class="memItemLeft" align="right" valign="top"><a id="a8f1439a55742e08aed110099945d6eb8"></a>
struct slab_cache *&#160;</td><td class="memItemRight" valign="bottom"><b>cord_slab_cache</b> (void)</td></tr>
<tr class="separator:a8f1439a55742e08aed110099945d6eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113af82955ade6d52b5a03fc327b266f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">box_region_used</a> (void)</td></tr>
<tr class="memdesc:a113af82955ade6d52b5a03fc327b266f"><td class="mdescLeft">&#160;</td><td class="mdescRight">box region allocator  <a href="module_8h.html#a113af82955ade6d52b5a03fc327b266f">More...</a><br /></td></tr>
<tr class="separator:a113af82955ade6d52b5a03fc327b266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7d6a912f5f8230bd8c8035735ef2f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac8e7d6a912f5f8230bd8c8035735ef2f">box_region_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:ac8e7d6a912f5f8230bd8c8035735ef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size bytes from the box region.  <a href="module_8h.html#ac8e7d6a912f5f8230bd8c8035735ef2f">More...</a><br /></td></tr>
<tr class="separator:ac8e7d6a912f5f8230bd8c8035735ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541b6608e37fc392112a9aee229432fa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a541b6608e37fc392112a9aee229432fa">box_region_aligned_alloc</a> (size_t size, size_t alignment)</td></tr>
<tr class="memdesc:a541b6608e37fc392112a9aee229432fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate size bytes from the box region with given alignment.  <a href="module_8h.html#a541b6608e37fc392112a9aee229432fa">More...</a><br /></td></tr>
<tr class="separator:a541b6608e37fc392112a9aee229432fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6575301cf1bd4df1bfad9a319b80a0b4"><td class="memItemLeft" align="right" valign="top"><a id="a6575301cf1bd4df1bfad9a319b80a0b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6575301cf1bd4df1bfad9a319b80a0b4">box_region_truncate</a> (size_t size)</td></tr>
<tr class="memdesc:a6575301cf1bd4df1bfad9a319b80a0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the box region to the given size. <br /></td></tr>
<tr class="separator:a6575301cf1bd4df1bfad9a319b80a0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670f12ab6752093a3e2ae0ff48ccd491"><td class="memItemLeft" align="right" valign="top">struct fiber_cond *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a670f12ab6752093a3e2ae0ff48ccd491">fiber_cond_new</a> (void)</td></tr>
<tr class="memdesc:a670f12ab6752093a3e2ae0ff48ccd491"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a670f12ab6752093a3e2ae0ff48ccd491">More...</a><br /></td></tr>
<tr class="separator:a670f12ab6752093a3e2ae0ff48ccd491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64787aacecdc620e9b7e402babf9ae1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a64787aacecdc620e9b7e402babf9ae1e">fiber_cond_delete</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a64787aacecdc620e9b7e402babf9ae1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the fiber cond object.  <a href="module_8h.html#a64787aacecdc620e9b7e402babf9ae1e">More...</a><br /></td></tr>
<tr class="separator:a64787aacecdc620e9b7e402babf9ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13caca027d090cc02574e333c78f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c">fiber_cond_signal</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a3f13caca027d090cc02574e333c78f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake one fiber waiting for the cond.  <a href="module_8h.html#a3f13caca027d090cc02574e333c78f3c">More...</a><br /></td></tr>
<tr class="separator:a3f13caca027d090cc02574e333c78f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abbca6fff4cd2ccf2b65528ea5e1e1e39">fiber_cond_broadcast</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up all fibers waiting for the cond.  <a href="module_8h.html#abbca6fff4cd2ccf2b65528ea5e1e1e39">More...</a><br /></td></tr>
<tr class="separator:abbca6fff4cd2ccf2b65528ea5e1e1e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7882234efd30663364ded133ab3fad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad">fiber_cond_wait_timeout</a> (struct fiber_cond *cond, double timeout)</td></tr>
<tr class="memdesc:a9e7882234efd30663364ded133ab3fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the execution of the current fiber (i.e.  <a href="module_8h.html#a9e7882234efd30663364ded133ab3fad">More...</a><br /></td></tr>
<tr class="separator:a9e7882234efd30663364ded133ab3fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd72e262e9e59a14c1337bc0fa2447c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1dd72e262e9e59a14c1337bc0fa2447c">fiber_cond_wait</a> (struct fiber_cond *cond)</td></tr>
<tr class="memdesc:a1dd72e262e9e59a14c1337bc0fa2447c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for <a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a>.  <a href="module_8h.html#a1dd72e262e9e59a14c1337bc0fa2447c">More...</a><br /></td></tr>
<tr class="separator:a1dd72e262e9e59a14c1337bc0fa2447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c521a569fd78b25f355f3b7525ba9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab9c521a569fd78b25f355f3b7525ba9a">coio_wait</a> (int fd, int event, double timeout)</td></tr>
<tr class="memdesc:ab9c521a569fd78b25f355f3b7525ba9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until READ or WRITE event on socket (<em>fd</em>).  <a href="module_8h.html#ab9c521a569fd78b25f355f3b7525ba9a">More...</a><br /></td></tr>
<tr class="separator:ab9c521a569fd78b25f355f3b7525ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23dc320746ce4ec9afdf433a66ef596"><td class="memItemLeft" align="right" valign="top"><a id="af23dc320746ce4ec9afdf433a66ef596"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af23dc320746ce4ec9afdf433a66ef596">coio_close</a> (int fd)</td></tr>
<tr class="memdesc:af23dc320746ce4ec9afdf433a66ef596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the fd and wake any fiber blocked in <a class="el" href="module_8h.html#ab9c521a569fd78b25f355f3b7525ba9a" title="Wait until READ or WRITE event on socket (fd).">coio_wait()</a> call on this fd. <br /></td></tr>
<tr class="separator:af23dc320746ce4ec9afdf433a66ef596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9433c7d42d7747f1f69b79a0d98df13"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a> (ssize_t(*func)(va_list),...)</td></tr>
<tr class="memdesc:af9433c7d42d7747f1f69b79a0d98df13"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">More...</a><br /></td></tr>
<tr class="separator:af9433c7d42d7747f1f69b79a0d98df13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832b67e03175570d9f6fa17ffd77bf83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a832b67e03175570d9f6fa17ffd77bf83">coio_getaddrinfo</a> (const char *host, const char *port, const struct addrinfo *hints, struct addrinfo **res, double timeout)</td></tr>
<tr class="memdesc:a832b67e03175570d9f6fa17ffd77bf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber-friendly version of getaddrinfo(3).  <a href="module_8h.html#a832b67e03175570d9f6fa17ffd77bf83">More...</a><br /></td></tr>
<tr class="separator:a832b67e03175570d9f6fa17ffd77bf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6dd91e6e7f26a9b57f4c317c2af203"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4b6dd91e6e7f26a9b57f4c317c2af203">box_ibuf_reserve</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, size_t size)</td></tr>
<tr class="memdesc:a4b6dd91e6e7f26a9b57f4c317c2af203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve requested amount of bytes in ibuf buffer.  <a href="module_8h.html#a4b6dd91e6e7f26a9b57f4c317c2af203">More...</a><br /></td></tr>
<tr class="separator:a4b6dd91e6e7f26a9b57f4c317c2af203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9d369f674c637b476fd92b00d3da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1fb9d369f674c637b476fd92b00d3da5">box_ibuf_read_range</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, char ***rpos, char ***wpos)</td></tr>
<tr class="memdesc:a1fb9d369f674c637b476fd92b00d3da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to read range pointers used [rpos..wpos)  <a href="module_8h.html#a1fb9d369f674c637b476fd92b00d3da5">More...</a><br /></td></tr>
<tr class="separator:a1fb9d369f674c637b476fd92b00d3da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b2d0e25c3a295f9ae0200a787c432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac74b2d0e25c3a295f9ae0200a787c432">box_ibuf_write_range</a> (<a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *ibuf, char ***wpos, char ***end)</td></tr>
<tr class="memdesc:ac74b2d0e25c3a295f9ae0200a787c432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to write range pointers used [wpos..end)  <a href="module_8h.html#ac74b2d0e25c3a295f9ae0200a787c432">More...</a><br /></td></tr>
<tr class="separator:ac74b2d0e25c3a295f9ae0200a787c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acc9bcfc8296607ac6cbfdd9d44cd7451">luaL_iscdata</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#acc9bcfc8296607ac6cbfdd9d44cd7451">More...</a><br /></td></tr>
<tr class="separator:acc9bcfc8296607ac6cbfdd9d44cd7451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6016a29a15957c333f568d4059923fad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6016a29a15957c333f568d4059923fad">luaL_pushcdata</a> (struct lua_State *L, uint32_t ctypeid)</td></tr>
<tr class="memdesc:a6016a29a15957c333f568d4059923fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push cdata of given <em>ctypeid</em> onto the stack.  <a href="module_8h.html#a6016a29a15957c333f568d4059923fad">More...</a><br /></td></tr>
<tr class="separator:a6016a29a15957c333f568d4059923fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8d32a69bc903b97ee3379b34fb2af"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a09b8d32a69bc903b97ee3379b34fb2af">luaL_checkcdata</a> (struct lua_State *L, int idx, uint32_t *ctypeid)</td></tr>
<tr class="memdesc:a09b8d32a69bc903b97ee3379b34fb2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the function argument idx is a cdata.  <a href="module_8h.html#a09b8d32a69bc903b97ee3379b34fb2af">More...</a><br /></td></tr>
<tr class="separator:a09b8d32a69bc903b97ee3379b34fb2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fc5e919f74956a06a9b40fb24f691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa62fc5e919f74956a06a9b40fb24f691">luaL_setcdatagc</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:aa62fc5e919f74956a06a9b40fb24f691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets finalizer function on a cdata object.  <a href="module_8h.html#aa62fc5e919f74956a06a9b40fb24f691">More...</a><br /></td></tr>
<tr class="separator:aa62fc5e919f74956a06a9b40fb24f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5d1f07b7fe39b8bd9b7a87f7c84d5d73">luaL_ctypeid</a> (struct lua_State *L, const char *ctypename)</td></tr>
<tr class="memdesc:a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CTypeID (FFI) of given DATA type.  <a href="module_8h.html#a5d1f07b7fe39b8bd9b7a87f7c84d5d73">More...</a><br /></td></tr>
<tr class="separator:a5d1f07b7fe39b8bd9b7a87f7c84d5d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498681c0c56f0aebe938004ab8947b0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a498681c0c56f0aebe938004ab8947b0f">luaL_cdef</a> (struct lua_State *L, const char *ctypename)</td></tr>
<tr class="memdesc:a498681c0c56f0aebe938004ab8947b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare symbols for FFI.  <a href="module_8h.html#a498681c0c56f0aebe938004ab8947b0f">More...</a><br /></td></tr>
<tr class="separator:a498681c0c56f0aebe938004ab8947b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6439d4dd158b27d2567e1bfd6243e084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6439d4dd158b27d2567e1bfd6243e084">luaL_pushuint64</a> (struct lua_State *L, uint64_t val)</td></tr>
<tr class="memdesc:a6439d4dd158b27d2567e1bfd6243e084"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a6439d4dd158b27d2567e1bfd6243e084">More...</a><br /></td></tr>
<tr class="separator:a6439d4dd158b27d2567e1bfd6243e084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcccfbc48bac7e8cf4802e839c2f198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1dcccfbc48bac7e8cf4802e839c2f198">luaL_pushint64</a> (struct lua_State *L, int64_t val)</td></tr>
<tr class="memdesc:a1dcccfbc48bac7e8cf4802e839c2f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push int64_t onto the stack.  <a href="module_8h.html#a1dcccfbc48bac7e8cf4802e839c2f198">More...</a><br /></td></tr>
<tr class="separator:a1dcccfbc48bac7e8cf4802e839c2f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5247fbc8230e2f49464e25e27b87d35"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac5247fbc8230e2f49464e25e27b87d35">luaL_checkuint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:ac5247fbc8230e2f49464e25e27b87d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a uint64 or a convertible string and returns this number.  <a href="module_8h.html#ac5247fbc8230e2f49464e25e27b87d35">More...</a><br /></td></tr>
<tr class="separator:ac5247fbc8230e2f49464e25e27b87d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159fe92272b876c3fa7b130f026705bd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a159fe92272b876c3fa7b130f026705bd">luaL_checkint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a159fe92272b876c3fa7b130f026705bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a int64 or a convertible string and returns this number.  <a href="module_8h.html#a159fe92272b876c3fa7b130f026705bd">More...</a><br /></td></tr>
<tr class="separator:a159fe92272b876c3fa7b130f026705bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e035148bc707412c054291f9b51855"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a20e035148bc707412c054291f9b51855">luaL_touint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a20e035148bc707412c054291f9b51855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a uint64 or a convertible string and returns this number.  <a href="module_8h.html#a20e035148bc707412c054291f9b51855">More...</a><br /></td></tr>
<tr class="separator:a20e035148bc707412c054291f9b51855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a31727f17a0a09ff7fb92ac3d2eaa2dce">luaL_toint64</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the argument idx is a int64 or a convertible string and returns this number.  <a href="module_8h.html#a31727f17a0a09ff7fb92ac3d2eaa2dce">More...</a><br /></td></tr>
<tr class="separator:a31727f17a0a09ff7fb92ac3d2eaa2dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4c95f4e99d2f7b5be64ca3918fdc4ccf">luaT_call</a> (lua_State *L, int nargs, int nreturns)</td></tr>
<tr class="memdesc:a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_call(), but with the proper support of Tarantool errors.  <a href="module_8h.html#a4c95f4e99d2f7b5be64ca3918fdc4ccf">More...</a><br /></td></tr>
<tr class="separator:a4c95f4e99d2f7b5be64ca3918fdc4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5310ad259a9b8ea40603a3d7f1946"><td class="memItemLeft" align="right" valign="top"><a id="aa1a5310ad259a9b8ea40603a3d7f1946"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>luaT_dostring</b> (struct lua_State *L, const char *str)</td></tr>
<tr class="separator:aa1a5310ad259a9b8ea40603a3d7f1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aafb8aaa59640f2b7130e9281e53ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08aafb8aaa59640f2b7130e9281e53ec">luaT_cpcall</a> (lua_State *L, lua_CFunction func, void *ud)</td></tr>
<tr class="memdesc:a08aafb8aaa59640f2b7130e9281e53ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_cpcall(), but with the proper support of Tarantool errors.  <a href="module_8h.html#a08aafb8aaa59640f2b7130e9281e53ec">More...</a><br /></td></tr>
<tr class="separator:a08aafb8aaa59640f2b7130e9281e53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc2559396474f5dff737adf04edc382"><td class="memItemLeft" align="right" valign="top"><a id="adcc2559396474f5dff737adf04edc382"></a>
lua_State *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adcc2559396474f5dff737adf04edc382">luaT_state</a> (void)</td></tr>
<tr class="memdesc:adcc2559396474f5dff737adf04edc382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global Lua state used by Tarantool. <br /></td></tr>
<tr class="separator:adcc2559396474f5dff737adf04edc382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0f168f5234ddb59713defe03029118"><td class="memItemLeft" align="right" valign="top"><a id="acb0f168f5234ddb59713defe03029118"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acb0f168f5234ddb59713defe03029118">luaT_tolstring</a> (lua_State *L, int idx, size_t *ssize)</td></tr>
<tr class="memdesc:acb0f168f5234ddb59713defe03029118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lua_tolstring, but supports metatables, booleans and nil properly. <br /></td></tr>
<tr class="separator:acb0f168f5234ddb59713defe03029118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ca887563c2bcd2e17ad199dac627b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08ca887563c2bcd2e17ad199dac627b2">luaL_iscallable</a> (lua_State *L, int idx)</td></tr>
<tr class="memdesc:a08ca887563c2bcd2e17ad199dac627b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a Lua object is a function or has metatable/metatype with a __call field.  <a href="module_8h.html#a08ca887563c2bcd2e17ad199dac627b2">More...</a><br /></td></tr>
<tr class="separator:a08ca887563c2bcd2e17ad199dac627b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac572fcff70dbc1c4c33339f1db082315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac572fcff70dbc1c4c33339f1db082315">luaT_toibuf</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:ac572fcff70dbc1c4c33339f1db082315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value on <em>L</em> stack by index <em>idx</em> is an ibuf object.  <a href="module_8h.html#ac572fcff70dbc1c4c33339f1db082315">More...</a><br /></td></tr>
<tr class="separator:ac572fcff70dbc1c4c33339f1db082315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae5e643c0eff90628dd8cb09ddd8dfc68">luaT_error</a> (lua_State *L)</td></tr>
<tr class="memdesc:ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-throws the last Tarantool error as a Lua object.  <a href="module_8h.html#ae5e643c0eff90628dd8cb09ddd8dfc68">More...</a><br /></td></tr>
<tr class="separator:ae5e643c0eff90628dd8cb09ddd8dfc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1740670301221218d3780f2a4df33c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa1740670301221218d3780f2a4df33c6">luaT_push_nil_and_error</a> (lua_State *L)</td></tr>
<tr class="memdesc:aa1740670301221218d3780f2a4df33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return nil as the first return value and an error as the second.  <a href="module_8h.html#aa1740670301221218d3780f2a4df33c6">More...</a><br /></td></tr>
<tr class="separator:aa1740670301221218d3780f2a4df33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9f0f763644cd5edc43ac632078b471"><td class="memItemLeft" align="right" valign="top"><a id="aff9f0f763644cd5edc43ac632078b471"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>luaT_pusherror</b> (struct lua_State *L, struct error *e)</td></tr>
<tr class="separator:aff9f0f763644cd5edc43ac632078b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf484fef1147b9e53323cd5082b505"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a94bf484fef1147b9e53323cd5082b505">box_txn_id</a> (void)</td></tr>
<tr class="memdesc:a94bf484fef1147b9e53323cd5082b505"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a94bf484fef1147b9e53323cd5082b505">More...</a><br /></td></tr>
<tr class="separator:a94bf484fef1147b9e53323cd5082b505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab434c9ba079ac5578be4699220b1860f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab434c9ba079ac5578be4699220b1860f">box_txn_isolation</a> (void)</td></tr>
<tr class="memdesc:ab434c9ba079ac5578be4699220b1860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get isolation level of current transaction, one of enum txn_isolation_level values (but cannot be TXN_ISOLATION_DEFAULT (which is zero) by design).  <a href="module_8h.html#ab434c9ba079ac5578be4699220b1860f">More...</a><br /></td></tr>
<tr class="separator:ab434c9ba079ac5578be4699220b1860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44f82b5dd34b12026c33baf63ba3fee"><td class="memItemLeft" align="right" valign="top"><a id="af44f82b5dd34b12026c33baf63ba3fee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af44f82b5dd34b12026c33baf63ba3fee">box_txn</a> (void)</td></tr>
<tr class="memdesc:af44f82b5dd34b12026c33baf63ba3fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is an active transaction. <br /></td></tr>
<tr class="separator:af44f82b5dd34b12026c33baf63ba3fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88346fff21ac55ecf5e8e7e8750093ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a88346fff21ac55ecf5e8e7e8750093ce">box_txn_begin</a> (void)</td></tr>
<tr class="memdesc:a88346fff21ac55ecf5e8e7e8750093ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a transaction in the current fiber.  <a href="module_8h.html#a88346fff21ac55ecf5e8e7e8750093ce">More...</a><br /></td></tr>
<tr class="separator:a88346fff21ac55ecf5e8e7e8750093ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c69864552de6ae21c4edce2bbf949"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a541c69864552de6ae21c4edce2bbf949">box_txn_commit</a> (void)</td></tr>
<tr class="memdesc:a541c69864552de6ae21c4edce2bbf949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the current transaction.  <a href="module_8h.html#a541c69864552de6ae21c4edce2bbf949">More...</a><br /></td></tr>
<tr class="separator:a541c69864552de6ae21c4edce2bbf949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59188d28eb2a8cd892d48f74041fec45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a59188d28eb2a8cd892d48f74041fec45">box_txn_rollback</a> (void)</td></tr>
<tr class="memdesc:a59188d28eb2a8cd892d48f74041fec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rollback the current transaction.  <a href="module_8h.html#a59188d28eb2a8cd892d48f74041fec45">More...</a><br /></td></tr>
<tr class="separator:a59188d28eb2a8cd892d48f74041fec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5cc88ba87d8e5afe81604385609191"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#adf5cc88ba87d8e5afe81604385609191">box_txn_alloc</a> (size_t size)</td></tr>
<tr class="memdesc:adf5cc88ba87d8e5afe81604385609191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory on txn memory pool.  <a href="module_8h.html#adf5cc88ba87d8e5afe81604385609191">More...</a><br /></td></tr>
<tr class="separator:adf5cc88ba87d8e5afe81604385609191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e930976f6e8e73e213f701c3761fce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3e930976f6e8e73e213f701c3761fce4">box_txn_set_timeout</a> (double timeout)</td></tr>
<tr class="memdesc:a3e930976f6e8e73e213f701c3761fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>timeout</em> for transaction, when it expires, transaction will be rolled back.  <a href="module_8h.html#a3e930976f6e8e73e213f701c3761fce4">More...</a><br /></td></tr>
<tr class="separator:a3e930976f6e8e73e213f701c3761fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24686e9b0f80d53ded039aa69dfd33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8a24686e9b0f80d53ded039aa69dfd33">box_txn_set_isolation</a> (uint32_t level)</td></tr>
<tr class="memdesc:a8a24686e9b0f80d53ded039aa69dfd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an isolation <em>level</em> for a transaction.  <a href="module_8h.html#a8a24686e9b0f80d53ded039aa69dfd33">More...</a><br /></td></tr>
<tr class="separator:a8a24686e9b0f80d53ded039aa69dfd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a457c9503bb15df42c4854fbede340e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5a457c9503bb15df42c4854fbede340e">box_tuple_format_default</a> (void)</td></tr>
<tr class="memdesc:a5a457c9503bb15df42c4854fbede340e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple Format.  <a href="module_8h.html#a5a457c9503bb15df42c4854fbede340e">More...</a><br /></td></tr>
<tr class="separator:a5a457c9503bb15df42c4854fbede340e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2211f2682d19f564c55f2888e35d6430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430">box_tuple_ref</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a2211f2682d19f564c55f2888e35d6430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference counter of tuple.  <a href="module_8h.html#a2211f2682d19f564c55f2888e35d6430">More...</a><br /></td></tr>
<tr class="separator:a2211f2682d19f564c55f2888e35d6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc">box_tuple_unref</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the reference counter of tuple.  <a href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc">More...</a><br /></td></tr>
<tr class="separator:a22d7b12b1afbff0c3cc20726c10cc6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d61b749ed483d35b65025eaa3039e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a800d61b749ed483d35b65025eaa3039e">box_tuple_field_count</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a800d61b749ed483d35b65025eaa3039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of fields in tuple (the size of MsgPack Array).  <a href="module_8h.html#a800d61b749ed483d35b65025eaa3039e">More...</a><br /></td></tr>
<tr class="separator:a800d61b749ed483d35b65025eaa3039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6812d20a87dc1f55648679680d0d2272"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6812d20a87dc1f55648679680d0d2272">box_tuple_bsize</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a6812d20a87dc1f55648679680d0d2272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes used to store internal tuple data (MsgPack Array).  <a href="module_8h.html#a6812d20a87dc1f55648679680d0d2272">More...</a><br /></td></tr>
<tr class="separator:a6812d20a87dc1f55648679680d0d2272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af520a6742b61a5bcb879b75d09d72f4e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af520a6742b61a5bcb879b75d09d72f4e">box_tuple_to_buf</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, char *buf, size_t size)</td></tr>
<tr class="memdesc:af520a6742b61a5bcb879b75d09d72f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump raw MsgPack data to the memory buffer <em>buf</em> of size <em>size</em>.  <a href="module_8h.html#af520a6742b61a5bcb879b75d09d72f4e">More...</a><br /></td></tr>
<tr class="separator:af520a6742b61a5bcb879b75d09d72f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7195d3207b3d7e034473d26b6d24dd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7195d3207b3d7e034473d26b6d24dd2f">box_tuple_format</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a7195d3207b3d7e034473d26b6d24dd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the associated format.  <a href="module_8h.html#a7195d3207b3d7e034473d26b6d24dd2f">More...</a><br /></td></tr>
<tr class="separator:a7195d3207b3d7e034473d26b6d24dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0c6fa0fbeb5d6f2974e8b82aa83f0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a13b0c6fa0fbeb5d6f2974e8b82aa83f0">box_tuple_field</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, uint32_t fieldno)</td></tr>
<tr class="memdesc:a13b0c6fa0fbeb5d6f2974e8b82aa83f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw tuple field in MsgPack format.  <a href="module_8h.html#a13b0c6fa0fbeb5d6f2974e8b82aa83f0">More...</a><br /></td></tr>
<tr class="separator:a13b0c6fa0fbeb5d6f2974e8b82aa83f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74729917c4ca28b3044569f5eccaecd9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a74729917c4ca28b3044569f5eccaecd9">box_tuple_field_by_path</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *path, uint32_t path_len, int index_base)</td></tr>
<tr class="memdesc:a74729917c4ca28b3044569f5eccaecd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw tuple field in the MsgPack format pointed by a JSON path.  <a href="module_8h.html#a74729917c4ca28b3044569f5eccaecd9">More...</a><br /></td></tr>
<tr class="separator:a74729917c4ca28b3044569f5eccaecd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aabe2cc4f09abaa070664c6d7156cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1aabe2cc4f09abaa070664c6d7156cd1">box_tuple_iterator</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a1aabe2cc4f09abaa070664c6d7156cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tuple iterator.  <a href="module_8h.html#a1aabe2cc4f09abaa070664c6d7156cd1">More...</a><br /></td></tr>
<tr class="separator:a1aabe2cc4f09abaa070664c6d7156cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbb37bc35f4c2eac665acb61f08da95"><td class="memItemLeft" align="right" valign="top"><a id="acbbb37bc35f4c2eac665acb61f08da95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acbbb37bc35f4c2eac665acb61f08da95">box_tuple_iterator_free</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:acbbb37bc35f4c2eac665acb61f08da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free tuple iterator. <br /></td></tr>
<tr class="separator:acbbb37bc35f4c2eac665acb61f08da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24865c6c4138cd6a252f32c55c812c6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:ac24865c6c4138cd6a252f32c55c812c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return zero-based next position in iterator.  <a href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">More...</a><br /></td></tr>
<tr class="separator:ac24865c6c4138cd6a252f32c55c812c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa998b89aa550c51d8576d3b766d1a67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:aaa998b89aa550c51d8576d3b766d1a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind iterator to the initial position.  <a href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">More...</a><br /></td></tr>
<tr class="separator:aaa998b89aa550c51d8576d3b766d1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc6a76579c761e9c7b2b9ced89290a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a76dc6a76579c761e9c7b2b9ced89290a">box_tuple_seek</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it, uint32_t fieldno)</td></tr>
<tr class="memdesc:a76dc6a76579c761e9c7b2b9ced89290a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek the tuple iterator.  <a href="module_8h.html#a76dc6a76579c761e9c7b2b9ced89290a">More...</a><br /></td></tr>
<tr class="separator:a76dc6a76579c761e9c7b2b9ced89290a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b88a4ee472624416d875a906a82d99b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7b88a4ee472624416d875a906a82d99b">box_tuple_next</a> (<a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *it)</td></tr>
<tr class="memdesc:a7b88a4ee472624416d875a906a82d99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next tuple field from tuple iterator.  <a href="module_8h.html#a7b88a4ee472624416d875a906a82d99b">More...</a><br /></td></tr>
<tr class="separator:a7b88a4ee472624416d875a906a82d99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442eb6797ae4d114d00dc68f2b1e361a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a442eb6797ae4d114d00dc68f2b1e361a">box_tuple_new</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format, const char *data, const char *end)</td></tr>
<tr class="memdesc:a442eb6797ae4d114d00dc68f2b1e361a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new tuple from a raw MsgPack Array data.  <a href="module_8h.html#a442eb6797ae4d114d00dc68f2b1e361a">More...</a><br /></td></tr>
<tr class="separator:a442eb6797ae4d114d00dc68f2b1e361a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83720cf7cd56310193b5026cfc58a151"><td class="memItemLeft" align="right" valign="top"><a id="a83720cf7cd56310193b5026cfc58a151"></a>
<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_update</b> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *expr, const char *expr_end)</td></tr>
<tr class="separator:a83720cf7cd56310193b5026cfc58a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a1df2e276a8abe83c5187e93971697"><td class="memItemLeft" align="right" valign="top"><a id="a37a1df2e276a8abe83c5187e93971697"></a>
<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>box_tuple_upsert</b> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, const char *expr, const char *expr_end)</td></tr>
<tr class="separator:a37a1df2e276a8abe83c5187e93971697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05611324090cd538b14e0728cf185a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8f05611324090cd538b14e0728cf185a">box_tuple_validate</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, <a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a8f05611324090cd538b14e0728cf185a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tuple data correspondence to the space format.  <a href="module_8h.html#a8f05611324090cd538b14e0728cf185a">More...</a><br /></td></tr>
<tr class="separator:a8f05611324090cd538b14e0728cf185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6977b1c26a2a187c8d4de4e93799186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa6977b1c26a2a187c8d4de4e93799186">box_key_def_new</a> (uint32_t *fields, uint32_t *types, uint32_t part_count)</td></tr>
<tr class="memdesc:aa6977b1c26a2a187c8d4de4e93799186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create key definition with given field numbers and field types.  <a href="module_8h.html#aa6977b1c26a2a187c8d4de4e93799186">More...</a><br /></td></tr>
<tr class="separator:aa6977b1c26a2a187c8d4de4e93799186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f751905f893144ead356172137e796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a52f751905f893144ead356172137e796">box_key_part_def_create</a> (<a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *part)</td></tr>
<tr class="memdesc:a52f751905f893144ead356172137e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a key part with default values.  <a href="module_8h.html#a52f751905f893144ead356172137e796">More...</a><br /></td></tr>
<tr class="separator:a52f751905f893144ead356172137e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591006ff571eb1ac2b05f5e41a8a8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3591006ff571eb1ac2b05f5e41a8a8ca">box_key_def_new_v2</a> (<a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *parts, uint32_t part_count)</td></tr>
<tr class="memdesc:a3591006ff571eb1ac2b05f5e41a8a8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key_def from given key parts.  <a href="module_8h.html#a3591006ff571eb1ac2b05f5e41a8a8ca">More...</a><br /></td></tr>
<tr class="separator:a3591006ff571eb1ac2b05f5e41a8a8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af072fd108644a06c68d5ba1f74efb460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af072fd108644a06c68d5ba1f74efb460">box_key_def_dup</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:af072fd108644a06c68d5ba1f74efb460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate key_def.  <a href="module_8h.html#af072fd108644a06c68d5ba1f74efb460">More...</a><br /></td></tr>
<tr class="separator:af072fd108644a06c68d5ba1f74efb460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fdf05e0d276baa072123358c29e046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a82fdf05e0d276baa072123358c29e046">box_key_def_delete</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:a82fdf05e0d276baa072123358c29e046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete key definition.  <a href="module_8h.html#a82fdf05e0d276baa072123358c29e046">More...</a><br /></td></tr>
<tr class="separator:a82fdf05e0d276baa072123358c29e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ea5a24503d921ba39fab504eac17fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab6ea5a24503d921ba39fab504eac17fe">box_key_def_dump_parts</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, uint32_t *part_count_ptr)</td></tr>
<tr class="memdesc:ab6ea5a24503d921ba39fab504eac17fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump key part definitions of given key_def.  <a href="module_8h.html#ab6ea5a24503d921ba39fab504eac17fe">More...</a><br /></td></tr>
<tr class="separator:ab6ea5a24503d921ba39fab504eac17fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01aea33b0593fd1b84243be7033469"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3c01aea33b0593fd1b84243be7033469">box_key_def_validate_tuple</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a3c01aea33b0593fd1b84243be7033469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that tuple fields match with given key definition.  <a href="module_8h.html#a3c01aea33b0593fd1b84243be7033469">More...</a><br /></td></tr>
<tr class="separator:a3c01aea33b0593fd1b84243be7033469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b978e168708341cb358a15c5e42430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a88b978e168708341cb358a15c5e42430">box_tuple_compare</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_a, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_b, <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:a88b978e168708341cb358a15c5e42430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare tuples using the key definition.  <a href="module_8h.html#a88b978e168708341cb358a15c5e42430">More...</a><br /></td></tr>
<tr class="separator:a88b978e168708341cb358a15c5e42430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fec3862fabe2eb885bb71517b99a5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae8fec3862fabe2eb885bb71517b99a5f">box_tuple_compare_with_key</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple_a, const char *key_b, <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def)</td></tr>
<tr class="memdesc:ae8fec3862fabe2eb885bb71517b99a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare tuple with key using the key definition.  <a href="module_8h.html#ae8fec3862fabe2eb885bb71517b99a5f">More...</a><br /></td></tr>
<tr class="separator:ae8fec3862fabe2eb885bb71517b99a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ee8761b613b5a518f94dc7f2ca0073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad2ee8761b613b5a518f94dc7f2ca0073">box_key_def_merge</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *first, const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *second)</td></tr>
<tr class="memdesc:ad2ee8761b613b5a518f94dc7f2ca0073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new key_def with a set union of key parts from first and second key defs.  <a href="module_8h.html#ad2ee8761b613b5a518f94dc7f2ca0073">More...</a><br /></td></tr>
<tr class="separator:ad2ee8761b613b5a518f94dc7f2ca0073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3e05887ff307b8ac5390f70f60158"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a28e3e05887ff307b8ac5390f70f60158">box_key_def_extract_key</a> (<a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, int multikey_idx, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:a28e3e05887ff307b8ac5390f70f60158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract key from tuple by given key definition and return buffer allocated on the box region with this key.  <a href="module_8h.html#a28e3e05887ff307b8ac5390f70f60158">More...</a><br /></td></tr>
<tr class="separator:a28e3e05887ff307b8ac5390f70f60158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32868fa25087aa7d7249fd2692a0ac52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a32868fa25087aa7d7249fd2692a0ac52">box_key_def_validate_key</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, const char *key, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:a32868fa25087aa7d7249fd2692a0ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a key against given key definition.  <a href="module_8h.html#a32868fa25087aa7d7249fd2692a0ac52">More...</a><br /></td></tr>
<tr class="separator:a32868fa25087aa7d7249fd2692a0ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237492509ee5f9e478b72077c4c65833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a237492509ee5f9e478b72077c4c65833">box_key_def_validate_full_key</a> (const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *key_def, const char *key, uint32_t *key_size_ptr)</td></tr>
<tr class="memdesc:a237492509ee5f9e478b72077c4c65833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a full key against given key definition.  <a href="module_8h.html#a237492509ee5f9e478b72077c4c65833">More...</a><br /></td></tr>
<tr class="separator:a237492509ee5f9e478b72077c4c65833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1515eaa49be2b9990eab5fff279600be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1515eaa49be2b9990eab5fff279600be">box_tuple_format_new</a> (struct key_def **keys, uint16_t key_count)</td></tr>
<tr class="memdesc:a1515eaa49be2b9990eab5fff279600be"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a1515eaa49be2b9990eab5fff279600be">More...</a><br /></td></tr>
<tr class="separator:a1515eaa49be2b9990eab5fff279600be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc998b676589a854eaf71e2e1fd4debc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#acc998b676589a854eaf71e2e1fd4debc">box_tuple_format_ref</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:acc998b676589a854eaf71e2e1fd4debc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment tuple format ref count.  <a href="module_8h.html#acc998b676589a854eaf71e2e1fd4debc">More...</a><br /></td></tr>
<tr class="separator:acc998b676589a854eaf71e2e1fd4debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134eab27cb960c030d553d3881d8d074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a134eab27cb960c030d553d3881d8d074">box_tuple_format_unref</a> (<a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a134eab27cb960c030d553d3881d8d074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement tuple format ref count.  <a href="module_8h.html#a134eab27cb960c030d553d3881d8d074">More...</a><br /></td></tr>
<tr class="separator:a134eab27cb960c030d553d3881d8d074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8b1e8f1e92bb906daefd5666e0ff2f4d">box_schema_version</a> (void)</td></tr>
<tr class="memdesc:a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a8b1e8f1e92bb906daefd5666e0ff2f4d">More...</a><br /></td></tr>
<tr class="separator:a8b1e8f1e92bb906daefd5666e0ff2f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7fb00cd4eac4d388d58e9e5ef1ea1b3f">box_return_tuple</a> (<a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *ctx, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tuple from stored C procedure.  <a href="module_8h.html#a7fb00cd4eac4d388d58e9e5ef1ea1b3f">More...</a><br /></td></tr>
<tr class="separator:a7fb00cd4eac4d388d58e9e5ef1ea1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf7ae13f994a18d2f9dcf7816578ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a96bf7ae13f994a18d2f9dcf7816578ca">box_return_mp</a> (<a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *ctx, const char *mp, const char *mp_end)</td></tr>
<tr class="memdesc:a96bf7ae13f994a18d2f9dcf7816578ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return MessagePack from a stored C procedure.  <a href="module_8h.html#a96bf7ae13f994a18d2f9dcf7816578ca">More...</a><br /></td></tr>
<tr class="separator:a96bf7ae13f994a18d2f9dcf7816578ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a816d0fc386d810b874b50db1f50293"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4a816d0fc386d810b874b50db1f50293">box_space_id_by_name</a> (const char *name, uint32_t len)</td></tr>
<tr class="memdesc:a4a816d0fc386d810b874b50db1f50293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find space id by name.  <a href="module_8h.html#a4a816d0fc386d810b874b50db1f50293">More...</a><br /></td></tr>
<tr class="separator:a4a816d0fc386d810b874b50db1f50293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abb8381625fb1364af63d58a0235b3a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4abb8381625fb1364af63d58a0235b3a">box_index_id_by_name</a> (uint32_t space_id, const char *name, uint32_t len)</td></tr>
<tr class="memdesc:a4abb8381625fb1364af63d58a0235b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find index id by name.  <a href="module_8h.html#a4abb8381625fb1364af63d58a0235b3a">More...</a><br /></td></tr>
<tr class="separator:a4abb8381625fb1364af63d58a0235b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08571f03c05abf96fd6e98a590d78822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a08571f03c05abf96fd6e98a590d78822">box_insert</a> (uint32_t space_id, const char *tuple, const char *tuple_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a08571f03c05abf96fd6e98a590d78822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an INSERT request.  <a href="module_8h.html#a08571f03c05abf96fd6e98a590d78822">More...</a><br /></td></tr>
<tr class="separator:a08571f03c05abf96fd6e98a590d78822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a933b6e9cbf9d4fc05e3964b0949b5bd0">box_replace</a> (uint32_t space_id, const char *tuple, const char *tuple_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an REPLACE request.  <a href="module_8h.html#a933b6e9cbf9d4fc05e3964b0949b5bd0">More...</a><br /></td></tr>
<tr class="separator:a933b6e9cbf9d4fc05e3964b0949b5bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a740bf8f0f5f912dfa78221c9fe5f21bb">box_delete</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an DELETE request.  <a href="module_8h.html#a740bf8f0f5f912dfa78221c9fe5f21bb">More...</a><br /></td></tr>
<tr class="separator:a740bf8f0f5f912dfa78221c9fe5f21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9badf4d5cc54e424a157439fcb58b96a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a">box_update</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, const char *ops, const char *ops_end, int index_base, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a9badf4d5cc54e424a157439fcb58b96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an UPDATE request.  <a href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a">More...</a><br /></td></tr>
<tr class="separator:a9badf4d5cc54e424a157439fcb58b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268a03389cd856206f0ddfc90f3cbf84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84">box_upsert</a> (uint32_t space_id, uint32_t index_id, const char *tuple, const char *tuple_end, const char *ops, const char *ops_end, int index_base, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a268a03389cd856206f0ddfc90f3cbf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an UPSERT request.  <a href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84">More...</a><br /></td></tr>
<tr class="separator:a268a03389cd856206f0ddfc90f3cbf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20de21b171ded688588f1063ac04a9d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a20de21b171ded688588f1063ac04a9d3">box_truncate</a> (uint32_t space_id)</td></tr>
<tr class="memdesc:a20de21b171ded688588f1063ac04a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate space.  <a href="module_8h.html#a20de21b171ded688588f1063ac04a9d3">More...</a><br /></td></tr>
<tr class="separator:a20de21b171ded688588f1063ac04a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5fd9116818749f73bf868d4e780256"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3e5fd9116818749f73bf868d4e780256">box_sequence_next</a> (uint32_t seq_id, int64_t *result)</td></tr>
<tr class="memdesc:a3e5fd9116818749f73bf868d4e780256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance a sequence.  <a href="module_8h.html#a3e5fd9116818749f73bf868d4e780256">More...</a><br /></td></tr>
<tr class="separator:a3e5fd9116818749f73bf868d4e780256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ac5f1357a07acaae764e5d2e2e55fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a66ac5f1357a07acaae764e5d2e2e55fa">box_sequence_current</a> (uint32_t seq_id, int64_t *result)</td></tr>
<tr class="memdesc:a66ac5f1357a07acaae764e5d2e2e55fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last value returned by a sequence.  <a href="module_8h.html#a66ac5f1357a07acaae764e5d2e2e55fa">More...</a><br /></td></tr>
<tr class="separator:a66ac5f1357a07acaae764e5d2e2e55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2243f60e2773d3522a540103f645110"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac2243f60e2773d3522a540103f645110">box_sequence_set</a> (uint32_t seq_id, int64_t value)</td></tr>
<tr class="memdesc:ac2243f60e2773d3522a540103f645110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a sequence value.  <a href="module_8h.html#ac2243f60e2773d3522a540103f645110">More...</a><br /></td></tr>
<tr class="separator:ac2243f60e2773d3522a540103f645110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8f9c3210df64b1f6fd89eb2c5e088e94">box_sequence_reset</a> (uint32_t seq_id)</td></tr>
<tr class="memdesc:a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a sequence.  <a href="module_8h.html#a8f9c3210df64b1f6fd89eb2c5e088e94">More...</a><br /></td></tr>
<tr class="separator:a8f9c3210df64b1f6fd89eb2c5e088e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9c91d463ce4aca081e5bd376aac1d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0e9c91d463ce4aca081e5bd376aac1d9">box_session_push</a> (const char *data, const char *data_end)</td></tr>
<tr class="memdesc:a0e9c91d463ce4aca081e5bd376aac1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push MessagePack data into a session data channel - socket, console or whatever is behind the session.  <a href="module_8h.html#a0e9c91d463ce4aca081e5bd376aac1d9">More...</a><br /></td></tr>
<tr class="separator:a0e9c91d463ce4aca081e5bd376aac1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a6ea7f0c101d1986f27de9f8ec25c8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a14a6ea7f0c101d1986f27de9f8ec25c8">box_session_id</a> (void)</td></tr>
<tr class="separator:a14a6ea7f0c101d1986f27de9f8ec25c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcef363e704e69cb0cc4efb80c6a648e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abcef363e704e69cb0cc4efb80c6a648e">box_iproto_send</a> (uint64_t sid, const char *header, const char *header_end, const char *body, const char *body_end)</td></tr>
<tr class="memdesc:abcef363e704e69cb0cc4efb80c6a648e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet with the given header and body over the IPROTO session's socket.  <a href="module_8h.html#abcef363e704e69cb0cc4efb80c6a648e">More...</a><br /></td></tr>
<tr class="separator:abcef363e704e69cb0cc4efb80c6a648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7">box_iproto_override</a> (uint32_t req_type, <a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a> handler, <a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a> destroy, void *ctx)</td></tr>
<tr class="memdesc:a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an IPROTO request handler with the provided context for the given request type.  <a href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7">More...</a><br /></td></tr>
<tr class="separator:a6f6d1752bccac95ed2d154a98c3fe9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8b69829c8d89799a9fb0e5d360e84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aab8b69829c8d89799a9fb0e5d360e84b">box_index_iterator</a> (uint32_t space_id, uint32_t index_id, int type, const char *key, const char *key_end)</td></tr>
<tr class="memdesc:aab8b69829c8d89799a9fb0e5d360e84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize iterator for space_id, index_id.  <a href="module_8h.html#aab8b69829c8d89799a9fb0e5d360e84b">More...</a><br /></td></tr>
<tr class="separator:aab8b69829c8d89799a9fb0e5d360e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4361728e6abe6243e7f02b098e7b347"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347">box_iterator_next</a> (<a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *iterator, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:ae4361728e6abe6243e7f02b098e7b347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next item from the <em>iterator</em>.  <a href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347">More...</a><br /></td></tr>
<tr class="separator:ae4361728e6abe6243e7f02b098e7b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7fe762b15009de313fdf915378429c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a> (<a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *iterator)</td></tr>
<tr class="memdesc:a6f7fe762b15009de313fdf915378429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and deallocate iterator.  <a href="module_8h.html#a6f7fe762b15009de313fdf915378429c">More...</a><br /></td></tr>
<tr class="separator:a6f7fe762b15009de313fdf915378429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698d8991fa015a4b490f078b29e8d929"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a698d8991fa015a4b490f078b29e8d929">box_index_len</a> (uint32_t space_id, uint32_t index_id)</td></tr>
<tr class="memdesc:a698d8991fa015a4b490f078b29e8d929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of element in the index.  <a href="module_8h.html#a698d8991fa015a4b490f078b29e8d929">More...</a><br /></td></tr>
<tr class="separator:a698d8991fa015a4b490f078b29e8d929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaeda3d99d32c382bc5ac2bc8f0a09f48">box_index_bsize</a> (uint32_t space_id, uint32_t index_id)</td></tr>
<tr class="memdesc:aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes used in memory by the index.  <a href="module_8h.html#aaeda3d99d32c382bc5ac2bc8f0a09f48">More...</a><br /></td></tr>
<tr class="separator:aaeda3d99d32c382bc5ac2bc8f0a09f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56e2bf2a5720259ea3997149ae53ca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa56e2bf2a5720259ea3997149ae53ca9">box_index_random</a> (uint32_t space_id, uint32_t index_id, uint32_t rnd, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:aa56e2bf2a5720259ea3997149ae53ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random tuple from the index (useful for statistical analysis).  <a href="module_8h.html#aa56e2bf2a5720259ea3997149ae53ca9">More...</a><br /></td></tr>
<tr class="separator:aa56e2bf2a5720259ea3997149ae53ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a5c9cedd4198d62ddfe6c77ef2bf89f56">box_index_get</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a tuple from index by the key.  <a href="module_8h.html#a5c9cedd4198d62ddfe6c77ef2bf89f56">More...</a><br /></td></tr>
<tr class="separator:a5c9cedd4198d62ddfe6c77ef2bf89f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd278987613571a9d6475de6103a4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4fbd278987613571a9d6475de6103a4f">box_index_min</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a4fbd278987613571a9d6475de6103a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a first (minimal) tuple matched the provided key.  <a href="module_8h.html#a4fbd278987613571a9d6475de6103a4f">More...</a><br /></td></tr>
<tr class="separator:a4fbd278987613571a9d6475de6103a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e5f79addcfd9c7312fe66e7be7514"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a044e5f79addcfd9c7312fe66e7be7514">box_index_max</a> (uint32_t space_id, uint32_t index_id, const char *key, const char *key_end, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **result)</td></tr>
<tr class="memdesc:a044e5f79addcfd9c7312fe66e7be7514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a last (maximal) tuple matched the provided key.  <a href="module_8h.html#a044e5f79addcfd9c7312fe66e7be7514">More...</a><br /></td></tr>
<tr class="separator:a044e5f79addcfd9c7312fe66e7be7514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f06a7df9e461267455477bd84ce02ed"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3f06a7df9e461267455477bd84ce02ed">box_index_count</a> (uint32_t space_id, uint32_t index_id, int type, const char *key, const char *key_end)</td></tr>
<tr class="memdesc:a3f06a7df9e461267455477bd84ce02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of tuple matched the provided key.  <a href="module_8h.html#a3f06a7df9e461267455477bd84ce02ed">More...</a><br /></td></tr>
<tr class="separator:a3f06a7df9e461267455477bd84ce02ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1314851b7b1ec2fab6908eaef71f52"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4b1314851b7b1ec2fab6908eaef71f52">box_tuple_extract_key</a> (<a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple, uint32_t space_id, uint32_t index_id, uint32_t *key_size)</td></tr>
<tr class="memdesc:a4b1314851b7b1ec2fab6908eaef71f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract key from tuple according to key definition of given index.  <a href="module_8h.html#a4b1314851b7b1ec2fab6908eaef71f52">More...</a><br /></td></tr>
<tr class="separator:a4b1314851b7b1ec2fab6908eaef71f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b58e493b5515222c6bb9c0393d092ce"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a9b58e493b5515222c6bb9c0393d092ce">box_error_type</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:a9b58e493b5515222c6bb9c0393d092ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error type, e.g.  <a href="module_8h.html#a9b58e493b5515222c6bb9c0393d092ce">More...</a><br /></td></tr>
<tr class="separator:a9b58e493b5515222c6bb9c0393d092ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a57f7e18f0b9c3880d4e516589e73"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a800a57f7e18f0b9c3880d4e516589e73">box_error_code</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:a800a57f7e18f0b9c3880d4e516589e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return IPROTO error code.  <a href="module_8h.html#a800a57f7e18f0b9c3880d4e516589e73">More...</a><br /></td></tr>
<tr class="separator:a800a57f7e18f0b9c3880d4e516589e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2a8679174320da6a54edc6df4681ae"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aff2a8679174320da6a54edc6df4681ae">box_error_message</a> (const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *error)</td></tr>
<tr class="memdesc:aff2a8679174320da6a54edc6df4681ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error message.  <a href="module_8h.html#aff2a8679174320da6a54edc6df4681ae">More...</a><br /></td></tr>
<tr class="separator:aff2a8679174320da6a54edc6df4681ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f82c313ba49fc97782663ffba71f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58">box_error_last</a> (void)</td></tr>
<tr class="memdesc:af8f82c313ba49fc97782663ffba71f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about the last API call error.  <a href="module_8h.html#af8f82c313ba49fc97782663ffba71f58">More...</a><br /></td></tr>
<tr class="separator:af8f82c313ba49fc97782663ffba71f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2143635d7ff4aeb2ced40ffa033527"><td class="memItemLeft" align="right" valign="top"><a id="a1c2143635d7ff4aeb2ced40ffa033527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1c2143635d7ff4aeb2ced40ffa033527">box_error_clear</a> (void)</td></tr>
<tr class="memdesc:a1c2143635d7ff4aeb2ced40ffa033527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the last error. <br /></td></tr>
<tr class="separator:a1c2143635d7ff4aeb2ced40ffa033527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e6803bc4309c3f59b93e2709cb418b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b">box_error_set</a> (const char *file, unsigned line, uint32_t code, const char *format,...)</td></tr>
<tr class="memdesc:aa6e6803bc4309c3f59b93e2709cb418b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the last error.  <a href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b">More...</a><br /></td></tr>
<tr class="separator:aa6e6803bc4309c3f59b93e2709cb418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f106407ff1e6560bd8cba9b4698040d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a6f106407ff1e6560bd8cba9b4698040d">luaT_checktuple</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:a6f106407ff1e6560bd8cba9b4698040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a6f106407ff1e6560bd8cba9b4698040d">More...</a><br /></td></tr>
<tr class="separator:a6f106407ff1e6560bd8cba9b4698040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddb8bf7e1f41149fe67352de0f276d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a0ddb8bf7e1f41149fe67352de0f276d4">luaT_pushtuple</a> (struct lua_State *L, <a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *tuple)</td></tr>
<tr class="memdesc:a0ddb8bf7e1f41149fe67352de0f276d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a tuple onto the stack.  <a href="module_8h.html#a0ddb8bf7e1f41149fe67352de0f276d4">More...</a><br /></td></tr>
<tr class="separator:a0ddb8bf7e1f41149fe67352de0f276d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dce37206b2951e42b76a9ce704f9f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab1dce37206b2951e42b76a9ce704f9f2">luaT_istuple</a> (struct lua_State *L, int idx)</td></tr>
<tr class="memdesc:ab1dce37206b2951e42b76a9ce704f9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether argument idx is a tuple.  <a href="module_8h.html#ab1dce37206b2951e42b76a9ce704f9f2">More...</a><br /></td></tr>
<tr class="separator:ab1dce37206b2951e42b76a9ce704f9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d953ad39d6f1e0704a6c536b7ab60"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab57d953ad39d6f1e0704a6c536b7ab60">luaT_tuple_encode</a> (struct lua_State *L, int idx, size_t *tuple_len_ptr)</td></tr>
<tr class="memdesc:ab57d953ad39d6f1e0704a6c536b7ab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a table or a tuple on the Lua stack as an MsgPack array.  <a href="module_8h.html#ab57d953ad39d6f1e0704a6c536b7ab60">More...</a><br /></td></tr>
<tr class="separator:ab57d953ad39d6f1e0704a6c536b7ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9365f857b2bb2b02d03b0c075fd793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2a9365f857b2bb2b02d03b0c075fd793">luaT_tuple_new</a> (struct lua_State *L, int idx, <a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *format)</td></tr>
<tr class="memdesc:a2a9365f857b2bb2b02d03b0c075fd793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new tuple with specific format from a Lua table or a tuple.  <a href="module_8h.html#a2a9365f857b2bb2b02d03b0c075fd793">More...</a><br /></td></tr>
<tr class="separator:a2a9365f857b2bb2b02d03b0c075fd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c106ac756a1b7fa422a72e71b379b0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7c106ac756a1b7fa422a72e71b379b0a">box_latch_new</a> (void)</td></tr>
<tr class="memdesc:a7c106ac756a1b7fa422a72e71b379b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the new latch.  <a href="module_8h.html#a7c106ac756a1b7fa422a72e71b379b0a">More...</a><br /></td></tr>
<tr class="separator:a7c106ac756a1b7fa422a72e71b379b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a897e7386e946cd5ffd2ea1cb47a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a83a897e7386e946cd5ffd2ea1cb47a52">box_latch_delete</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a83a897e7386e946cd5ffd2ea1cb47a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy and free the latch.  <a href="module_8h.html#a83a897e7386e946cd5ffd2ea1cb47a52">More...</a><br /></td></tr>
<tr class="separator:a83a897e7386e946cd5ffd2ea1cb47a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef397199dd9a19cb7b9362233a1d4a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aef397199dd9a19cb7b9362233a1d4a98">box_latch_lock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:aef397199dd9a19cb7b9362233a1d4a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a latch.  <a href="module_8h.html#aef397199dd9a19cb7b9362233a1d4a98">More...</a><br /></td></tr>
<tr class="separator:aef397199dd9a19cb7b9362233a1d4a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294e53c819e91f172428d580a29f434f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a294e53c819e91f172428d580a29f434f">box_latch_trylock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a294e53c819e91f172428d580a29f434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a latch.  <a href="module_8h.html#a294e53c819e91f172428d580a29f434f">More...</a><br /></td></tr>
<tr class="separator:a294e53c819e91f172428d580a29f434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dea9d7a0347d38956ed59f739c68ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a11dea9d7a0347d38956ed59f739c68ca">box_latch_unlock</a> (<a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *latch)</td></tr>
<tr class="memdesc:a11dea9d7a0347d38956ed59f739c68ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a latch.  <a href="module_8h.html#a11dea9d7a0347d38956ed59f739c68ca">More...</a><br /></td></tr>
<tr class="separator:a11dea9d7a0347d38956ed59f739c68ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b915cd0f2fbf8da0031594334d1161"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a82b915cd0f2fbf8da0031594334d1161">clock_realtime</a> (void)</td></tr>
<tr class="memdesc:a82b915cd0f2fbf8da0031594334d1161"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a82b915cd0f2fbf8da0031594334d1161">More...</a><br /></td></tr>
<tr class="separator:a82b915cd0f2fbf8da0031594334d1161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35900530fb24b7e882c37016b01603aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a35900530fb24b7e882c37016b01603aa">clock_monotonic</a> (void)</td></tr>
<tr class="memdesc:a35900530fb24b7e882c37016b01603aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonsettable system-wide clock that represents monotonic time.  <a href="module_8h.html#a35900530fb24b7e882c37016b01603aa">More...</a><br /></td></tr>
<tr class="separator:a35900530fb24b7e882c37016b01603aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf77597c056216e310c34951bf21b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7ecf77597c056216e310c34951bf21b9">clock_process</a> (void)</td></tr>
<tr class="memdesc:a7ecf77597c056216e310c34951bf21b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock that measures CPU time consumed by this process (by all threads in the process).  <a href="module_8h.html#a7ecf77597c056216e310c34951bf21b9">More...</a><br /></td></tr>
<tr class="separator:a7ecf77597c056216e310c34951bf21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aac6c5ad4ed25168dd171bd2f9d112d0d">clock_thread</a> (void)</td></tr>
<tr class="memdesc:aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock that measures CPU time consumed by this thread.  <a href="module_8h.html#aac6c5ad4ed25168dd171bd2f9d112d0d">More...</a><br /></td></tr>
<tr class="separator:aac6c5ad4ed25168dd171bd2f9d112d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbe6ebb913f8356f36c68e724473b45"><td class="memItemLeft" align="right" valign="top"><a id="a3bbe6ebb913f8356f36c68e724473b45"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3bbe6ebb913f8356f36c68e724473b45">clock_realtime64</a> (void)</td></tr>
<tr class="memdesc:a3bbe6ebb913f8356f36c68e724473b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a82b915cd0f2fbf8da0031594334d1161" title="public">clock_realtime()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a3bbe6ebb913f8356f36c68e724473b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29caad1a3f9995d2a2844a1d4672e3cd"><td class="memItemLeft" align="right" valign="top"><a id="a29caad1a3f9995d2a2844a1d4672e3cd"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a29caad1a3f9995d2a2844a1d4672e3cd">clock_monotonic64</a> (void)</td></tr>
<tr class="memdesc:a29caad1a3f9995d2a2844a1d4672e3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a35900530fb24b7e882c37016b01603aa" title="A nonsettable system-wide clock that represents monotonic time.">clock_monotonic()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a29caad1a3f9995d2a2844a1d4672e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162cf2a3d31840c4a904d5c543980104"><td class="memItemLeft" align="right" valign="top"><a id="a162cf2a3d31840c4a904d5c543980104"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a162cf2a3d31840c4a904d5c543980104">clock_process64</a> (void)</td></tr>
<tr class="memdesc:a162cf2a3d31840c4a904d5c543980104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#a7ecf77597c056216e310c34951bf21b9" title="A clock that measures CPU time consumed by this process (by all threads in the process).">clock_process()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:a162cf2a3d31840c4a904d5c543980104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="memItemLeft" align="right" valign="top"><a id="afac4e0ab14aaaf4b7d101e28c55c18cf"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afac4e0ab14aaaf4b7d101e28c55c18cf">clock_thread64</a> (void)</td></tr>
<tr class="memdesc:afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="module_8h.html#aac6c5ad4ed25168dd171bd2f9d112d0d" title="A clock that measures CPU time consumed by this thread.">clock_thread()</a>, but returns the time as 64 bit signed integer. <br /></td></tr>
<tr class="separator:afac4e0ab14aaaf4b7d101e28c55c18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1815f3add53077a6f1383db1d9347c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1815f3add53077a6f1383db1d9347c99">box_decimal_precision</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a1815f3add53077a6f1383db1d9347c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimal precision.  <a href="module_8h.html#a1815f3add53077a6f1383db1d9347c99">More...</a><br /></td></tr>
<tr class="separator:a1815f3add53077a6f1383db1d9347c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499bd306b660788339570ea8b9f4733"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a3499bd306b660788339570ea8b9f4733">box_decimal_scale</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a3499bd306b660788339570ea8b9f4733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimal scale.  <a href="module_8h.html#a3499bd306b660788339570ea8b9f4733">More...</a><br /></td></tr>
<tr class="separator:a3499bd306b660788339570ea8b9f4733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adad9501fc38ba6e6a54f58d6152840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a1adad9501fc38ba6e6a54f58d6152840">box_decimal_is_int</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a1adad9501fc38ba6e6a54f58d6152840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the fractional part of a decimal number is 0.  <a href="module_8h.html#a1adad9501fc38ba6e6a54f58d6152840">More...</a><br /></td></tr>
<tr class="separator:a1adad9501fc38ba6e6a54f58d6152840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74749ee03d5f2860c5813b0bf36cabe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a74749ee03d5f2860c5813b0bf36cabe4">box_decimal_is_neg</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a74749ee03d5f2860c5813b0bf36cabe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a decimal number is negative.  <a href="module_8h.html#a74749ee03d5f2860c5813b0bf36cabe4">More...</a><br /></td></tr>
<tr class="separator:a74749ee03d5f2860c5813b0bf36cabe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5057a778894e99543a07aecbce998af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab5057a778894e99543a07aecbce998af">box_decimal_zero</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:ab5057a778894e99543a07aecbce998af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a zero decimal number.  <a href="module_8h.html#ab5057a778894e99543a07aecbce998af">More...</a><br /></td></tr>
<tr class="separator:ab5057a778894e99543a07aecbce998af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81c9e590563ab312a470066e732c874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae81c9e590563ab312a470066e732c874">box_decimal_from_string</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char *str)</td></tr>
<tr class="memdesc:ae81c9e590563ab312a470066e732c874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a value from a string.  <a href="module_8h.html#ae81c9e590563ab312a470066e732c874">More...</a><br /></td></tr>
<tr class="separator:ae81c9e590563ab312a470066e732c874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69214f1ba250729dbf5d06894ff7d4cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a69214f1ba250729dbf5d06894ff7d4cc">box_decimal_from_double</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, double d)</td></tr>
<tr class="memdesc:a69214f1ba250729dbf5d06894ff7d4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal from double.  <a href="module_8h.html#a69214f1ba250729dbf5d06894ff7d4cc">More...</a><br /></td></tr>
<tr class="separator:a69214f1ba250729dbf5d06894ff7d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0a0856aae8c1c80208eee4027e5f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a4e0a0856aae8c1c80208eee4027e5f83">box_decimal_from_int64</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int64_t num)</td></tr>
<tr class="memdesc:a4e0a0856aae8c1c80208eee4027e5f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a signed integer value.  <a href="module_8h.html#a4e0a0856aae8c1c80208eee4027e5f83">More...</a><br /></td></tr>
<tr class="separator:a4e0a0856aae8c1c80208eee4027e5f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74864d2137cbd53f64999bd419a721fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a74864d2137cbd53f64999bd419a721fb">box_decimal_from_uint64</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, uint64_t num)</td></tr>
<tr class="memdesc:a74864d2137cbd53f64999bd419a721fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a decimal with a unsigned integer value.  <a href="module_8h.html#a74864d2137cbd53f64999bd419a721fb">More...</a><br /></td></tr>
<tr class="separator:a74864d2137cbd53f64999bd419a721fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fc69b043029952787aeb05b146145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ab67fc69b043029952787aeb05b146145">box_decimal_copy</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dest, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *src)</td></tr>
<tr class="memdesc:ab67fc69b043029952787aeb05b146145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy decimal value from one storage to another.  <a href="module_8h.html#ab67fc69b043029952787aeb05b146145">More...</a><br /></td></tr>
<tr class="separator:ab67fc69b043029952787aeb05b146145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a20acf8704e0a8de6b2c6e70cabda94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7a20acf8704e0a8de6b2c6e70cabda94">box_decimal_to_string</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, char *buf)</td></tr>
<tr class="memdesc:a7a20acf8704e0a8de6b2c6e70cabda94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the decimal as a string into the passed buffer.  <a href="module_8h.html#a7a20acf8704e0a8de6b2c6e70cabda94">More...</a><br /></td></tr>
<tr class="separator:a7a20acf8704e0a8de6b2c6e70cabda94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa213d0898e63876e3ca57cbe506bdfe6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa213d0898e63876e3ca57cbe506bdfe6">box_decimal_to_int64</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int64_t *num)</td></tr>
<tr class="memdesc:aa213d0898e63876e3ca57cbe506bdfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given decimal to int64_t.  <a href="module_8h.html#aa213d0898e63876e3ca57cbe506bdfe6">More...</a><br /></td></tr>
<tr class="separator:aa213d0898e63876e3ca57cbe506bdfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f83c5dd155eb132a17f0a4e2efa47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af45f83c5dd155eb132a17f0a4e2efa47">box_decimal_to_uint64</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, uint64_t *num)</td></tr>
<tr class="memdesc:af45f83c5dd155eb132a17f0a4e2efa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given decimal to uint64_t.  <a href="module_8h.html#af45f83c5dd155eb132a17f0a4e2efa47">More...</a><br /></td></tr>
<tr class="separator:af45f83c5dd155eb132a17f0a4e2efa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e2827ab276075fedde86a576d15e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aae4e2827ab276075fedde86a576d15e9">box_decimal_round</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:aae4e2827ab276075fedde86a576d15e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to nearest decimal at given <em>scale</em>, half goes away from zero.  <a href="module_8h.html#aae4e2827ab276075fedde86a576d15e9">More...</a><br /></td></tr>
<tr class="separator:aae4e2827ab276075fedde86a576d15e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471927fb872be29fdff66d0e198a3878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a471927fb872be29fdff66d0e198a3878">box_decimal_floor</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:a471927fb872be29fdff66d0e198a3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a floor function to a decimal, i.e.  <a href="module_8h.html#a471927fb872be29fdff66d0e198a3878">More...</a><br /></td></tr>
<tr class="separator:a471927fb872be29fdff66d0e198a3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6b6c8fd7096a6bfe54d65007255281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8d6b6c8fd7096a6bfe54d65007255281">box_decimal_trim</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a8d6b6c8fd7096a6bfe54d65007255281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing zeros from the fractional part of a number.  <a href="module_8h.html#a8d6b6c8fd7096a6bfe54d65007255281">More...</a><br /></td></tr>
<tr class="separator:a8d6b6c8fd7096a6bfe54d65007255281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3599d3e81a8144fa1a10199908a84f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac3599d3e81a8144fa1a10199908a84f2">box_decimal_rescale</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, int scale)</td></tr>
<tr class="memdesc:ac3599d3e81a8144fa1a10199908a84f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set scale of <em>dec</em> to <em>scale</em>.  <a href="module_8h.html#ac3599d3e81a8144fa1a10199908a84f2">More...</a><br /></td></tr>
<tr class="separator:ac3599d3e81a8144fa1a10199908a84f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0376671f42b04fdafb2706527762b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaf0376671f42b04fdafb2706527762b4">box_decimal_compare</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aaf0376671f42b04fdafb2706527762b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two decimal values.  <a href="module_8h.html#aaf0376671f42b04fdafb2706527762b4">More...</a><br /></td></tr>
<tr class="separator:aaf0376671f42b04fdafb2706527762b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a33cc8495c4fc3ef343bf4ffe767d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2a33cc8495c4fc3ef343bf4ffe767d81">box_decimal_abs</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a2a33cc8495c4fc3ef343bf4ffe767d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute value of a decimal.  <a href="module_8h.html#a2a33cc8495c4fc3ef343bf4ffe767d81">More...</a><br /></td></tr>
<tr class="separator:a2a33cc8495c4fc3ef343bf4ffe767d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58747fcce83cdad8ffde68b78ad57da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ac58747fcce83cdad8ffde68b78ad57da">box_decimal_minus</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:ac58747fcce83cdad8ffde68b78ad57da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform unary minus operation.  <a href="module_8h.html#ac58747fcce83cdad8ffde68b78ad57da">More...</a><br /></td></tr>
<tr class="separator:ac58747fcce83cdad8ffde68b78ad57da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5c7bbc81f8c39f8767cccc27b0d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a39c5c7bbc81f8c39f8767cccc27b0d09">box_decimal_add</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:a39c5c7bbc81f8c39f8767cccc27b0d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a sum of two decimal numbers.  <a href="module_8h.html#a39c5c7bbc81f8c39f8767cccc27b0d09">More...</a><br /></td></tr>
<tr class="separator:a39c5c7bbc81f8c39f8767cccc27b0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26473f8f35e87789e1f7e51e0c9c01d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a26473f8f35e87789e1f7e51e0c9c01d5">box_decimal_sub</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:a26473f8f35e87789e1f7e51e0c9c01d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one decimal number from another.  <a href="module_8h.html#a26473f8f35e87789e1f7e51e0c9c01d5">More...</a><br /></td></tr>
<tr class="separator:a26473f8f35e87789e1f7e51e0c9c01d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ab08f3604f10eb105b18868511a66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af8ab08f3604f10eb105b18868511a66d">box_decimal_mul</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:af8ab08f3604f10eb105b18868511a66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two decimal numbers.  <a href="module_8h.html#af8ab08f3604f10eb105b18868511a66d">More...</a><br /></td></tr>
<tr class="separator:af8ab08f3604f10eb105b18868511a66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2246edd7f0b9df9c182038bdbb6d2b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a2246edd7f0b9df9c182038bdbb6d2b11">box_decimal_div</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:a2246edd7f0b9df9c182038bdbb6d2b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide one decimal number on another.  <a href="module_8h.html#a2246edd7f0b9df9c182038bdbb6d2b11">More...</a><br /></td></tr>
<tr class="separator:a2246edd7f0b9df9c182038bdbb6d2b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb908abdbaea9d758545b1825604101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaeb908abdbaea9d758545b1825604101">box_decimal_remainder</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:aaeb908abdbaea9d758545b1825604101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remainder of diviging two decimals.  <a href="module_8h.html#aaeb908abdbaea9d758545b1825604101">More...</a><br /></td></tr>
<tr class="separator:aaeb908abdbaea9d758545b1825604101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92596f1e666deb84a3569b7af48af95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#af92596f1e666deb84a3569b7af48af95">box_decimal_log10</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:af92596f1e666deb84a3569b7af48af95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a common logarithm (base 10).  <a href="module_8h.html#af92596f1e666deb84a3569b7af48af95">More...</a><br /></td></tr>
<tr class="separator:af92596f1e666deb84a3569b7af48af95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe79a92142c93b7344f6e6559edea7a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afe79a92142c93b7344f6e6559edea7a6">box_decimal_ln</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:afe79a92142c93b7344f6e6559edea7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a natural logarithm (base e).  <a href="module_8h.html#afe79a92142c93b7344f6e6559edea7a6">More...</a><br /></td></tr>
<tr class="separator:afe79a92142c93b7344f6e6559edea7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78523b113439b54d761c5ffe19317f59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a78523b113439b54d761c5ffe19317f59">box_decimal_pow</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *lhs, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *rhs)</td></tr>
<tr class="memdesc:a78523b113439b54d761c5ffe19317f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <em>lhs</em> raised to the power of <em>rhs</em>.  <a href="module_8h.html#a78523b113439b54d761c5ffe19317f59">More...</a><br /></td></tr>
<tr class="separator:a78523b113439b54d761c5ffe19317f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4d239489a058ab770f6da11c16dcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aaf4d239489a058ab770f6da11c16dcd4">box_decimal_exp</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:aaf4d239489a058ab770f6da11c16dcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate exp(<em>dec</em>), i.e.  <a href="module_8h.html#aaf4d239489a058ab770f6da11c16dcd4">More...</a><br /></td></tr>
<tr class="separator:aaf4d239489a058ab770f6da11c16dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8947463e9d73c92ffee508b32a3b3d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a8947463e9d73c92ffee508b32a3b3d9b">box_decimal_sqrt</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *res, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:a8947463e9d73c92ffee508b32a3b3d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a square root.  <a href="module_8h.html#a8947463e9d73c92ffee508b32a3b3d9b">More...</a><br /></td></tr>
<tr class="separator:a8947463e9d73c92ffee508b32a3b3d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847059b54874f3e4bde5550ec228fd3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ad847059b54874f3e4bde5550ec228fd3">box_decimal_mp_sizeof</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:ad847059b54874f3e4bde5550ec228fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate exact buffer size needed to store msgpack representation of a decimal.  <a href="module_8h.html#ad847059b54874f3e4bde5550ec228fd3">More...</a><br /></td></tr>
<tr class="separator:ad847059b54874f3e4bde5550ec228fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7cf68d7ca8998fad15492ae99bbf7e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#afc7cf68d7ca8998fad15492ae99bbf7e">box_decimal_mp_encode</a> (const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, char *data)</td></tr>
<tr class="memdesc:afc7cf68d7ca8998fad15492ae99bbf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a decimal as msgpack.  <a href="module_8h.html#afc7cf68d7ca8998fad15492ae99bbf7e">More...</a><br /></td></tr>
<tr class="separator:afc7cf68d7ca8998fad15492ae99bbf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f14822373ac8e50ecb18bd23aeee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aa91f14822373ac8e50ecb18bd23aeee4">box_decimal_mp_decode</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char **data)</td></tr>
<tr class="memdesc:aa91f14822373ac8e50ecb18bd23aeee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a decimal from msgpack <em>data</em>.  <a href="module_8h.html#aa91f14822373ac8e50ecb18bd23aeee4">More...</a><br /></td></tr>
<tr class="separator:aa91f14822373ac8e50ecb18bd23aeee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69f4b3c80347bcbfb617a70b57f820e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#ae69f4b3c80347bcbfb617a70b57f820e">box_decimal_mp_decode_data</a> (<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec, const char **data, uint32_t size)</td></tr>
<tr class="memdesc:ae69f4b3c80347bcbfb617a70b57f820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a decimal from msgpack <em>data</em> without the msgpack extension header.  <a href="module_8h.html#ae69f4b3c80347bcbfb617a70b57f820e">More...</a><br /></td></tr>
<tr class="separator:ae69f4b3c80347bcbfb617a70b57f820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062a07e1c119c2c50b65afd23d0ce40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a7062a07e1c119c2c50b65afd23d0ce40">luaT_newdecimal</a> (struct lua_State *L)</td></tr>
<tr class="memdesc:a7062a07e1c119c2c50b65afd23d0ce40"><td class="mdescLeft">&#160;</td><td class="mdescRight">public  <a href="module_8h.html#a7062a07e1c119c2c50b65afd23d0ce40">More...</a><br /></td></tr>
<tr class="separator:a7062a07e1c119c2c50b65afd23d0ce40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef837b9429a6fe562b43d5bff5c3c426"><td class="memItemLeft" align="right" valign="top"><a id="aef837b9429a6fe562b43d5bff5c3c426"></a>
<a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#aef837b9429a6fe562b43d5bff5c3c426">luaT_pushdecimal</a> (struct lua_State *L, const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *dec)</td></tr>
<tr class="memdesc:aef837b9429a6fe562b43d5bff5c3c426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new decimal on the Lua stack with copy of given decimal and return a pointer to it. <br /></td></tr>
<tr class="separator:aef837b9429a6fe562b43d5bff5c3c426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f6c9c6047142026a2e3727e4e43a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#a53f6c9c6047142026a2e3727e4e43a24">luaT_isdecimal</a> (struct lua_State *L, int index)</td></tr>
<tr class="memdesc:a53f6c9c6047142026a2e3727e4e43a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a value on the Lua stack is a decimal.  <a href="module_8h.html#a53f6c9c6047142026a2e3727e4e43a24">More...</a><br /></td></tr>
<tr class="separator:a53f6c9c6047142026a2e3727e4e43a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab5a71c2541c377b3d5b34fdb35964c2e"><td class="memItemLeft" align="right" valign="top"><a id="ab5a71c2541c377b3d5b34fdb35964c2e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>log_level</b></td></tr>
<tr class="separator:ab5a71c2541c377b3d5b34fdb35964c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe1e6dda2fc92e77e64561cd3d4380f"><td class="memItemLeft" align="right" valign="top"><a id="abfe1e6dda2fc92e77e64561cd3d4380f"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="module_8h.html#abfe1e6dda2fc92e77e64561cd3d4380f">log_write_flightrec</a> )(int level, const char *filename, int line, const char *error, const char *format, va_list ap)</td></tr>
<tr class="memdesc:abfe1e6dda2fc92e77e64561cd3d4380f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called for every log which log level is not less than log_level_flightrec. <br /></td></tr>
<tr class="separator:abfe1e6dda2fc92e77e64561cd3d4380f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af989845e24678c452b9222afdac95e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af989845e24678c452b9222afdac95e7f">&#9670;&nbsp;</a></span>__has_feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __has_feature</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Feature test macros for -std=c11 / -std=c++11</p>
<p>Sic: clang aims to be gcc-compatible and thus defines <b>GNUC</b> </p>

</div>
</div>
<a id="a3ed9482331696beaadb8ab2e6b4dfead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed9482331696beaadb8ab2e6b4dfead">&#9670;&nbsp;</a></span>alignof</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alignof</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_T</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(struct { char c; _T member; }, member)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C11/C++11 operator. </p>
<p>Returns the alignment, in bytes, required for any instance of the type indicated by type-id, which is either complete type, an array type, or a reference type. </p>

</div>
</div>
<a id="ac8c9f90a1d4b7435c509fd2020e4aa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9f90a1d4b7435c509fd2020e4aa88">&#9670;&nbsp;</a></span>BUILD_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUILD_INFO&#160;&#160;&#160;&quot;Linux-x86_64-Debug&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CMake build type signature, e.g. </p>
<p>Linux-x86_64-Debug </p>

</div>
</div>
<a id="a040141d0f88e012c0b915e3531fef5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040141d0f88e012c0b915e3531fef5cc">&#9670;&nbsp;</a></span>BUILD_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUILD_TYPE&#160;&#160;&#160;&quot;Debug&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build type, e.g. </p>
<p>Debug or Release </p>

</div>
</div>
<a id="a75df7795fe4158ac681564ae0520d975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75df7795fe4158ac681564ae0520d975">&#9670;&nbsp;</a></span>CFORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFORMAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">archetype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stringindex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">firsttocheck&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CFORMAT attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments that should be type-checked against a format string. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html</a> </dd></dl>

</div>
</div>
<a id="af8c317a42292b61c93aae91e59118a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c317a42292b61c93aae91e59118a46">&#9670;&nbsp;</a></span>container_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define container_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        const typeof( ((type *)0)-&gt;member  ) *__mptr = (ptr); \</div>
<div class="line">        (type *)( (<span class="keywordtype">char</span> *)__mptr - <a class="code" href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a>(type,member)  );})</div>
<div class="ttc" id="amodule_8h_html_afd049f7ad59dbe455f460807475c2841"><div class="ttname"><a href="module_8h.html#afd049f7ad59dbe455f460807475c2841">offsetof</a></div><div class="ttdeci">#define offsetof(type, member)</div><div class="ttdoc">The macro offsetof expands to an integral constant expression of type size_t, the value of which is t...</div><div class="ttdef"><b>Definition:</b> module.h:191</div></div>
</div><!-- fragment -->
<p>This macro is used to retrieve an enclosing structure from a pointer to a nested element. </p>

</div>
</div>
<a id="a033c6face33bc7db165c0ba591696fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033c6face33bc7db165c0ba591696fcc">&#9670;&nbsp;</a></span>DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEPRECATED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_msg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The DEPRECATED attribute can be applied to a function, a variable, or a type. </p>
<p>This is useful when identifying functions, variables, or types that are expected to be removed in a future version of a program. </p>

</div>
</div>
<a id="a0cf2d82c57a09723ab59e6f4dcc45b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf2d82c57a09723ab59e6f4dcc45b84">&#9670;&nbsp;</a></span>FALLTHROUGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALLTHROUGH</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Attributes }}}. </p>
<p>{{{ Statement Attributes The fallthrough attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the -Wimplicit-fallthrough warning must not trigger. The fallthrough attribute may appear at most once in each attribute list, and may not be mixed with other attributes. It can only be used in a switch statement (the compiler will issue an error otherwise), after a preceding statement and before a logically succeeding case label, or user-defined label. </p>

</div>
</div>
<a id="a643b6b7ac15874197420e2adbea8b6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643b6b7ac15874197420e2adbea8b6bb">&#9670;&nbsp;</a></span>INSTALL_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTALL_PREFIX&#160;&#160;&#160;&quot;/usr/local&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install prefix (e.g. </p>
<p>/usr) </p>

</div>
</div>
<a id="a217a0bd562b98ae8c2ffce44935351e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217a0bd562b98ae8c2ffce44935351e1">&#9670;&nbsp;</a></span>likely</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define likely</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiler-independent built-ins. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a></dd></dl>
<p>{{{ Built-ins You may use <a class="el" href="module_8h.html#a217a0bd562b98ae8c2ffce44935351e1" title="Compiler-independent built-ins.">likely()</a>/unlikely() to provide the compiler with branch prediction information. </p>

</div>
</div>
<a id="aa326a05d5e30f9e9a4bb0b4469d5d0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa326a05d5e30f9e9a4bb0b4469d5d0c0">&#9670;&nbsp;</a></span>PACKAGE_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PACKAGE_VERSION&#160;&#160;&#160;&quot;3.0.0-entrypoint-80-g3dbbf2d39&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string with major-minor-patch-commit-id identifier of the release, e.g. </p>
<p>1.6.6-113-g8399d0e. </p>

</div>
</div>
<a id="add6458adcc00e90c64bc87db324d1602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6458adcc00e90c64bc87db324d1602">&#9670;&nbsp;</a></span>prefetch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define prefetch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((void) addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed. </p>
<p>You can insert calls to <a class="el" href="module_8h.html#add6458adcc00e90c64bc87db324d1602" title="This macro is used to minimize cache-miss latency by moving data into a cache before it is accessed.">prefetch()</a> into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions will be generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</p>
<p>The value of addr is the address of the memory to prefetch. There are two optional arguments, rw and locality. The value of rw is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value locality must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three. </p>

</div>
</div>
<a id="a5b2bb360001f6dfb4f946335950cabbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2bb360001f6dfb4f946335950cabbf">&#9670;&nbsp;</a></span>say</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">error, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        say_file_line(level, __FILE__, __LINE__, error, format, ##__VA_ARGS__); })</div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>(int) - log level (see enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a>) </td></tr>
    <tr><td class="paramname">error</td><td>(const char * ) - error description, may be NULL </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> </dd></dl>

</div>
</div>
<a id="a7971b0f41c615be5a0b7100b5e42dcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7971b0f41c615be5a0b7100b5e42dcb3">&#9670;&nbsp;</a></span>say_crit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_crit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_CRIT, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
<div class="ttc" id="amodule_8h_html_ae02d530f5d4ff18fd7786c3648dac2cf"><div class="ttname"><a href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a></div><div class="ttdeci">#define say_info(format,...)</div><div class="ttdoc">Format and print a message to Tarantool log file.</div><div class="ttdef"><b>Definition:</b> module.h:519</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab318c2435df2b04c7180df57a3c217ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab318c2435df2b04c7180df57a3c217ae">&#9670;&nbsp;</a></span>say_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_debug</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_DEBUG, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0a7d66a81cb7c12fdb2bf2c16b9c563e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7d66a81cb7c12fdb2bf2c16b9c563e">&#9670;&nbsp;</a></span>say_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_error</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_ERROR, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aed82e9747a226e287b0355deecfee5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82e9747a226e287b0355deecfee5d1">&#9670;&nbsp;</a></span>say_file_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_file_line</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">file, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">line, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">error, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        ({ \</div>
<div class="line">        if (say_log_level_is_enabled(level)) \</div>
<div class="line">                _say(level, file, line, error, format, ##__VA_ARGS__); })</div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>(int) - log level (see enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a>) </td></tr>
    <tr><td class="paramname">file</td><td>(const char * ) - file name to print </td></tr>
    <tr><td class="paramname">line</td><td>(int) - line number to print </td></tr>
    <tr><td class="paramname">error</td><td>(const char * ) - error description, may be NULL </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> </dd></dl>

</div>
</div>
<a id="ae02d530f5d4ff18fd7786c3648dac2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02d530f5d4ff18fd7786c3648dac2cf">&#9670;&nbsp;</a></span>say_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_info</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_INFO, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a39929109aefade22a76048b9ac73bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39929109aefade22a76048b9ac73bd8d">&#9670;&nbsp;</a></span>say_syserror</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_syserror</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                      <a class="code" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_SYSERROR, <a class="code" href="module_8h.html#a9bffd74e9753961e0568d85db8e2304b">_say_strerror</a>(errno), \</div>
<div class="line">                                      format, ##__VA_ARGS__)</div>
<div class="ttc" id="amodule_8h_html_a5b2bb360001f6dfb4f946335950cabbf"><div class="ttname"><a href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a></div><div class="ttdeci">#define say(level, error, format,...)</div><div class="ttdoc">Format and print a message to Tarantool log file.</div><div class="ttdef"><b>Definition:</b> module.h:498</div></div>
<div class="ttc" id="amodule_8h_html_a9bffd74e9753961e0568d85db8e2304b"><div class="ttname"><a href="module_8h.html#a9bffd74e9753961e0568d85db8e2304b">_say_strerror</a></div><div class="ttdeci">const char * _say_strerror(int errnum)</div><div class="ttdoc">Internal function that implements MT-Safe strerror().</div></div>
</div><!-- fragment -->
<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a01a0037b2d3389e850c9bd7d66996b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a0037b2d3389e850c9bd7d66996b42">&#9670;&nbsp;</a></span>say_verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_verbose</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_VERBOSE, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac1ea95f80b8aa81fe56ca4291814b8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ea95f80b8aa81fe56ca4291814b8a3">&#9670;&nbsp;</a></span>say_warn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define say_warn</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">format, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="module_8h.html#a5b2bb360001f6dfb4f946335950cabbf">say</a>(S_WARN, NULL, format, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format and print a message to Tarantool log file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>printf() </dd>
<dd>
enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82" title="public">say_level</a> Example: <div class="fragment"><div class="line"><a class="code" href="module_8h.html#ae02d530f5d4ff18fd7786c3648dac2cf">say_info</a>(<span class="stringliteral">&quot;Some useful information: %s&quot;</span>, status);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb6d1259777e8f56c6260be6faed183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6d1259777e8f56c6260be6faed183e">&#9670;&nbsp;</a></span>SYSCONF_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYSCONF_DIR&#160;&#160;&#160;&quot;etc&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>System configuration dir (e.g /etc) </p>

</div>
</div>
<a id="a86d08c1b23d67eca942da0ac012d89f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d08c1b23d67eca942da0ac012d89f3">&#9670;&nbsp;</a></span>unreachable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define unreachable</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(assert(0))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If control flow reaches the point of the <a class="el" href="module_8h.html#a86d08c1b23d67eca942da0ac012d89f3" title="If control flow reaches the point of the unreachable(), the program is undefined.">unreachable()</a>, the program is undefined. </p>
<p>It is useful in situations where the compiler cannot deduce the unreachability of the code. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a90d26cf0c54dfa5e878e95ca0f73202a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d26cf0c54dfa5e878e95ca0f73202a">&#9670;&nbsp;</a></span>box_decimal_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structbox__decimal.html">box_decimal</a> <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage for a decimal number. </p>
<p>This type is large enough to hold a decimal value. The primary usage is to allocate a decimal on the stack and pass it to a box_decimal_*() function.</p>
<p>Take it as opacue structure with ability to allocate a value on the stack.</p>
<p>Use <a class="el" href="module_8h.html#ab67fc69b043029952787aeb05b146145" title="Copy decimal value from one storage to another.">box_decimal_copy()</a> to copy the value, don't use memcpy(). The real data can be smaller than this type. Moreover, tarantool may allocate less bytes for <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> value, so direct read/write of the structure may lead to access to an unallocated memory.</p>
<p>The alignment of the structure is not less than alignment of decimal values allocated by tarantool. It can be larger and it is another reason to don't access the structure content directly.</p>
<p>Last, but not least: the data format is unspecified and can be changed. Modules and applications that aims to be compatible with future tarantool versions must not lean on particular data representation within the structure. </p>

</div>
</div>
<a id="a302d3f85cf14f03ace911e9541c95c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302d3f85cf14f03ace911e9541c95c4d">&#9670;&nbsp;</a></span>box_key_part_def_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionPACKED.html">PACKED</a> <a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public representation of a key part definition. </p>
<p>Usage: Allocate an array of such key parts, initialize each key part (call &lt;box_key_part_def_create&gt;() and set necessary fields), pass the array into &lt;box_key_def_new_v2&gt;() function.</p>
<p>Important: A module should call &lt;box_key_part_def_create&gt;() to initialize the structure with default values. There is no guarantee that all future default values for fields and flags will be remain the same.</p>
<p>The idea of separation from internal &lt;struct key_part_def&gt; is to provide stable API and ABI for modules.</p>
<p>New fields may be added into the end of the structure in later tarantool versions. Also new flags may be introduced within &lt;flags&gt; field. &lt;collation&gt; cannot be changed to a union (to reuse for some other value), because it is verified even for a non-string key part by &lt;box_key_def_new_v2&gt;().</p>
<p>Fields that are unknown at given tarantool version are ignored in general, but filled with zeros when initialized. </p>

</div>
</div>
<a id="a923d13f137e4bdb8c852ea04637da58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d13f137e4bdb8c852ea04637da58d">&#9670;&nbsp;</a></span>box_latch_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct box_latch <a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>A lock for cooperative multitasking environment </p>

</div>
</div>
<a id="aa9eb59c79a9b32bb8a23204e89bced9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb59c79a9b32bb8a23204e89bced9d">&#9670;&nbsp;</a></span>iproto_handler_destroy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* iproto_handler_destroy_t) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPROTO request handler destructor called when the corresponding handler is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19dc8ff47cfc25ee92d0f74cdf459070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dc8ff47cfc25ee92d0f74cdf459070">&#9670;&nbsp;</a></span>iproto_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a>(* iproto_handler_t) (const char *header, const char *header_end, const char *body, const char *body_end, void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPROTO request handler signature: receives MsgPack encoded header and body, a context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a>, and must return one of the status codes from iproto_handler_status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Msgpack encoded header </td></tr>
    <tr><td class="paramname">header_end</td><td>end of Msgpack encoded header </td></tr>
    <tr><td class="paramname">body</td><td>Msgpack encoded body </td></tr>
    <tr><td class="paramname">body_end</td><td>end of Msgpack encoded body </td></tr>
    <tr><td class="paramname">ctx</td><td>context provided by <a class="el" href="module_8h.html#a6f6d1752bccac95ed2d154a98c3fe9c7" title="Sets an IPROTO request handler with the provided context for the given request type.">box_iproto_override()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a status code </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a06fc87d81c62e9abb8790b6e5713c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fc87d81c62e9abb8790b6e5713c55b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06fc87d81c62e9abb8790b6e5713c55ba4e556d3f75a54e162feaa8e9451cfce7"></a>COIO_READ&#160;</td><td class="fielddoc"><p>READ event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06fc87d81c62e9abb8790b6e5713c55ba9ccd504861956d107f717efa66b3f1b7"></a>COIO_WRITE&#160;</td><td class="fielddoc"><p>WRITE event. </p>
</td></tr>
</table>

</div>
</div>
<a id="a99fb83031ce9923c84392b4e92f956b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb83031ce9923c84392b4e92f956b5">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is recommended to verify size of &lt;box_key_part_def_t&gt; against this constant on the module side at build time. </p>
<p>Example:</p>
<p>| #if !defined(__cplusplus) &amp;&amp; !defined(static_assert) | #define static_assert _Static_assert | #endif | | (slash)* | * Verify that &lt;box_key_part_def_t&gt; has the same size when | * compiled within tarantool and within the module. | * | * It is important, because the module allocates an array of key | * parts and passes it to &lt;box_key_def_new_v2&gt;() tarantool | * function. | *(slash) | static_assert(sizeof(box_key_part_def_t) == BOX_KEY_PART_DEF_T_SIZE, | "sizeof(box_key_part_def_t)");</p>
<p>This snippet is not part of <a class="el" href="module_8h.html">module.h</a>, because portability of static_assert() / _Static_assert() is dubious. It should be decision of a module author how portable its code should be. </p>

</div>
</div>
<a id="abc6126af1d45847bc59afa0aa3216b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6126af1d45847bc59afa0aa3216b04">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a05cae1bfc9671a38779ffd9dde4d7f58"></a>BOX_SYSTEM_ID_MIN&#160;</td><td class="fielddoc"><p>Start of the reserved range of system spaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ab14386b6fac3c938ed3a3b614510bb72"></a>BOX_VINYL_DEFERRED_DELETE_ID&#160;</td><td class="fielddoc"><p>Space if of _vinyl_deferred_delete. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a97f8ff937bc22208ebe19175eb0016a0"></a>BOX_SCHEMA_ID&#160;</td><td class="fielddoc"><p>Space id of _schema. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a3bcd934a5e27f4aee628e875fd422af5"></a>BOX_COLLATION_ID&#160;</td><td class="fielddoc"><p>Space id of _collation. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a3879bb29a2f51b4de4a923e4d6ba1b63"></a>BOX_VCOLLATION_ID&#160;</td><td class="fielddoc"><p>Space id of _vcollation. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a2f5e17bb60cab866ec35b516c75c686a"></a>BOX_SPACE_ID&#160;</td><td class="fielddoc"><p>Space id of _space. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04abd4d512ca7fdebf9ec1a6bf7f11e1840"></a>BOX_VSPACE_ID&#160;</td><td class="fielddoc"><p>Space id of _vspace view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a43c8f5e53b0c9db9be2da424c152cec9"></a>BOX_SEQUENCE_ID&#160;</td><td class="fielddoc"><p>Space id of _sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ad41b03d39d656d7612c911d8a60582c3"></a>BOX_SEQUENCE_DATA_ID&#160;</td><td class="fielddoc"><p>Space id of _sequence_data. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04adb9d519142826402c9efc166df12428e"></a>BOX_VSEQUENCE_ID&#160;</td><td class="fielddoc"><p>Space id of _vsequence view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a482bf0fb6fc52ff01f40edb92705c95f"></a>BOX_INDEX_ID&#160;</td><td class="fielddoc"><p>Space id of _index. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ac27ac3d0508d4e5f19f91053f7971cb7"></a>BOX_VINDEX_ID&#160;</td><td class="fielddoc"><p>Space id of _vindex view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a744b39a5e9efc8559776daba88b01dd3"></a>BOX_FUNC_ID&#160;</td><td class="fielddoc"><p>Space id of _func. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a8cb7f39326f7dfc0afcf9dc32f5314da"></a>BOX_VFUNC_ID&#160;</td><td class="fielddoc"><p>Space id of _vfunc view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a0f673849e4f92136273e92af04637e81"></a>BOX_USER_ID&#160;</td><td class="fielddoc"><p>Space id of _user. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ab508bf1accff87e8422bb32785e505bb"></a>BOX_VUSER_ID&#160;</td><td class="fielddoc"><p>Space id of _vuser view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a1bbd73fc6936dfa1977c7ea18677c4f9"></a>BOX_PRIV_ID&#160;</td><td class="fielddoc"><p>Space id of _priv. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a37bb51c69ca47d95c4ce5777c9640613"></a>BOX_VPRIV_ID&#160;</td><td class="fielddoc"><p>Space id of _vpriv view. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ab05d38e39c97e255ecaf3e48db943d62"></a>BOX_CLUSTER_ID&#160;</td><td class="fielddoc"><p>Space id of _cluster. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04add17b7c9ec4c6322a8344e00e8c25c62"></a>BOX_TRIGGER_ID&#160;</td><td class="fielddoc"><p>Space id of _trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a41c61daeecfce31f01f55ac6eb971f72"></a>BOX_TRUNCATE_ID&#160;</td><td class="fielddoc"><p>Space id of _truncate. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ad4db1b50b1f6446f75a8db82e0327374"></a>BOX_SPACE_SEQUENCE_ID&#160;</td><td class="fielddoc"><p>Space id of _space_sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04abe8471169b17b8ad853f4bd201c71785"></a>BOX_VSPACE_SEQUENCE_ID&#160;</td><td class="fielddoc"><p>Space id of _vspace_sequence. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a99e954bd1de658ba6586d7354fe06378"></a>BOX_FK_CONSTRAINT_ID&#160;</td><td class="fielddoc"><p>Space id of _fk_constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04ae97c7da44f193fcfea35afe2dfe98dc8"></a>BOX_CK_CONSTRAINT_ID&#160;</td><td class="fielddoc"><p>Space id of _ck_contraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a5590980099004e7b53cd73cd5418f98b"></a>BOX_FUNC_INDEX_ID&#160;</td><td class="fielddoc"><p>Space id of _func_index. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04a03e08a677af627a4199839a08b9020e8"></a>BOX_SESSION_SETTINGS_ID&#160;</td><td class="fielddoc"><p>Space id of _session_settings. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc6126af1d45847bc59afa0aa3216b04abb87df1b61192ee3aea178534071b9cd"></a>BOX_SYSTEM_ID_MAX&#160;</td><td class="fielddoc"><p>End of the reserved range of system spaces. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4dab01cb6470a8177e9618558523ff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dab01cb6470a8177e9618558523ff7b">&#9670;&nbsp;</a></span>iproto_handler_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#a4dab01cb6470a8177e9618558523ff7b">iproto_handler_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return codes for IPROTO request handlers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7ba964fc0581c3169c5047abaebcbc6a190"></a>IPROTO_HANDLER_OK&#160;</td><td class="fielddoc"><p>Success, no further actions needed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7ba3838e3dc0206744064024e6948f5f214"></a>IPROTO_HANDLER_ERROR&#160;</td><td class="fielddoc"><p>Error, diagnostic must be set by handler via <a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b" title="Set the last error.">box_error_set()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4dab01cb6470a8177e9618558523ff7badb3e2b86bb68c8ef55af839fc59a63a5"></a>IPROTO_HANDLER_FALLBACK&#160;</td><td class="fielddoc"><p>Fallback to system handler. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2693ce4bd8fa71e8ac1e5272fc64d17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2693ce4bd8fa71e8ac1e5272fc64d17e">&#9670;&nbsp;</a></span>iterator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Controls how to iterate over tuples in an index. Different index types support different iterator types. For example, one can start iteration from a particular value (request key) and then retrieve all tuples where keys are greater or equal (= GE) to this key.</p>
<p>If iterator type is not supported by the selected index type, iterator constructor must fail with ER_UNSUPPORTED. To be selectable for primary key, an index must support at least ITER_EQ and ITER_GE types.</p>
<p>NULL value of request key corresponds to the first or last key in the index, depending on iteration direction. (first key for GE and GT types, and last key for LE and LT). Therefore, to iterate over all tuples in an index, one can use ITER_GE or ITER_LE iteration types with start key equal to NULL. For ITER_EQ, the key must not be NULL. </p>

</div>
</div>
<a id="af667a90dfe6a8cc25b510af73d98bb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af667a90dfe6a8cc25b510af73d98bb82">&#9670;&nbsp;</a></span>say_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#af667a90dfe6a8cc25b510af73d98bb82">say_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Log levels </p>

</div>
</div>
<a id="af2d527c62a52f85cb173c79c31d20ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d527c62a52f85cb173c79c31d20ce1">&#9670;&nbsp;</a></span>txn_isolation_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="module_8h.html#af2d527c62a52f85cb173c79c31d20ce1">txn_isolation_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>When a transaction calls <code>commit</code>, this action can last for some time until redo data is written to WAL. While such a <code>commit</code> call is in progress we call changes of such a transaction as 'committed', and when the process is finished - we call the changes as 'confirmed'. One of the main options of a transaction is to see or not to see 'committed' changes. Note that now there are different terminologies in different places. This enum uses new 'committed' and 'confirmed' states of transactions. Meanwhile in engined the first state is usually called as 'prepared', and the second as 'committed' or 'completed'. Warning: this enum is exposed in lua via ffi, and thus any change in items must be correspondingly modified on ffi.cdef(), see schema.lua. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a4f9fb36818af61558b13124ca0e02363"></a>TXN_ISOLATION_DEFAULT&#160;</td><td class="fielddoc"><p>Take isolation level from global default_isolation_level. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a351aceaaa55693a90f5e33103d051947"></a>TXN_ISOLATION_READ_COMMITTED&#160;</td><td class="fielddoc"><p>Allow to read committed, but not confirmed changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1ab2411f8d6a9d68367da464d9fcff932f"></a>TXN_ISOLATION_READ_CONFIRMED&#160;</td><td class="fielddoc"><p>Allow to read only confirmed changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1afa0bc338b3e678625a61d16254991c7b"></a>TXN_ISOLATION_BEST_EFFORT&#160;</td><td class="fielddoc"><p>Determine isolation level automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a6236950c80e86644457d27e158639b60"></a>TXN_ISOLATION_LINEARIZABLE&#160;</td><td class="fielddoc"><p>Allow to read only the changes confirmed on any cluster node. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d527c62a52f85cb173c79c31d20ce1a8e225c05de0c630a787eb113f64e3af4"></a>txn_isolation_level_MAX&#160;</td><td class="fielddoc"><p>Upper bound of valid values. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9bffd74e9753961e0568d85db8e2304b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bffd74e9753961e0568d85db8e2304b">&#9670;&nbsp;</a></span>_say_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* _say_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>errnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that implements MT-Safe strerror(). </p>
<p>It is used by <a class="el" href="module_8h.html#a39929109aefade22a76048b9ac73bd8d" title="Format and print a message to Tarantool log file.">say_syserror()</a> macro. </p>

</div>
</div>
<a id="a2a33cc8495c4fc3ef343bf4ffe767d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a33cc8495c4fc3ef343bf4ffe767d81">&#9670;&nbsp;</a></span>box_decimal_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute value of a decimal. </p>
<p><em>res</em> is set to the absolute value of <em>dec</em>.</p>
<p>box_decimal_abs(&amp;a, &amp;a) is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to store the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>res</em> </dd></dl>

</div>
</div>
<a id="a39c5c7bbc81f8c39f8767cccc27b0d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5c7bbc81f8c39f8767cccc27b0d09">&#9670;&nbsp;</a></span>box_decimal_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a sum of two decimal numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="aaf0376671f42b04fdafb2706527762b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0376671f42b04fdafb2706527762b4">&#9670;&nbsp;</a></span>box_decimal_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two decimal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if lhs &lt; rhs </dd>
<dd>
0 if lhs = rhs </dd>
<dd>
1 if lhs &gt; rhs </dd></dl>

</div>
</div>
<a id="ab67fc69b043029952787aeb05b146145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fc69b043029952787aeb05b146145">&#9670;&nbsp;</a></span>box_decimal_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy decimal value from one storage to another. </p>
<p>Use this function where you would use memcpy() if the precise data size would be known.</p>
<p>The memory areas must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>where to store the copy </td></tr>
    <tr><td class="paramname">src</td><td>from where to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy (<em>dest</em>) </dd></dl>

</div>
</div>
<a id="a2246edd7f0b9df9c182038bdbb6d2b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2246edd7f0b9df9c182038bdbb6d2b11">&#9670;&nbsp;</a></span>box_decimal_div()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide one decimal number on another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="aaf4d239489a058ab770f6da11c16dcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4d239489a058ab770f6da11c16dcd4">&#9670;&nbsp;</a></span>box_decimal_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate exp(<em>dec</em>), i.e. </p>
<p>pow(e, <em>dec</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="a471927fb872be29fdff66d0e198a3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471927fb872be29fdff66d0e198a3878">&#9670;&nbsp;</a></span>box_decimal_floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a floor function to a decimal, i.e. </p>
<p>round it towards zero to a decimal with given <em>scale</em>.</p>
<p>floor(-0.66, 1) -&gt; -0.6 floor(-0.65, 1) -&gt; -0.6 floor(-0.64, 1) -&gt; -0.6</p>
<p>floor(0.64, 1) -&gt; 0.6 floor(0.65, 1) -&gt; 0.6 floor(0.66, 1) -&gt; 0.6</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#aae4e2827ab276075fedde86a576d15e9" title="Round to nearest decimal at given scale, half goes away from zero.">box_decimal_round</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number @oaram scale target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <em>scale</em> is out of supported range </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="a69214f1ba250729dbf5d06894ff7d4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69214f1ba250729dbf5d06894ff7d4cc">&#9670;&nbsp;</a></span>box_decimal_from_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_from_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal from double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">d</td><td>source double value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the double is NaN, Infinity or greater than a maximum precision for decimal values </dd>
<dd>
decimal result </dd></dl>

</div>
</div>
<a id="a4e0a0856aae8c1c80208eee4027e5f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0a0856aae8c1c80208eee4027e5f83">&#9670;&nbsp;</a></span>box_decimal_from_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_from_int64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a signed integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">num</td><td>source integer value (signed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal result </dd></dl>

</div>
</div>
<a id="ae81c9e590563ab312a470066e732c874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81c9e590563ab312a470066e732c874">&#9670;&nbsp;</a></span>box_decimal_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a value from a string. </p>
<p>The fractional part may be rounded if a maximum precision is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">str</td><td>source string value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the string is invalid or the number is too big </dd>
<dd>
decimal result </dd></dl>

</div>
</div>
<a id="a74864d2137cbd53f64999bd419a721fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74864d2137cbd53f64999bd419a721fb">&#9670;&nbsp;</a></span>box_decimal_from_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_from_uint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a decimal with a unsigned integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
    <tr><td class="paramname">num</td><td>source integer value (unsigned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal result </dd></dl>

</div>
</div>
<a id="a1adad9501fc38ba6e6a54f58d6152840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adad9501fc38ba6e6a54f58d6152840">&#9670;&nbsp;</a></span>box_decimal_is_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool box_decimal_is_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the fractional part of a decimal number is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the fractional part is zero </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a74749ee03d5f2860c5813b0bf36cabe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74749ee03d5f2860c5813b0bf36cabe4">&#9670;&nbsp;</a></span>box_decimal_is_neg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool box_decimal_is_neg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a decimal number is negative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the decimal is less than zero </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="afe79a92142c93b7344f6e6559edea7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe79a92142c93b7344f6e6559edea7a6">&#9670;&nbsp;</a></span>box_decimal_ln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a natural logarithm (base e). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="af92596f1e666deb84a3569b7af48af95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92596f1e666deb84a3569b7af48af95">&#9670;&nbsp;</a></span>box_decimal_log10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a common logarithm (base 10). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="ac58747fcce83cdad8ffde68b78ad57da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58747fcce83cdad8ffde68b78ad57da">&#9670;&nbsp;</a></span>box_decimal_minus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_minus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform unary minus operation. </p>
<p><em>res</em> is set to -dec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to store the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>res</em> </dd></dl>

</div>
</div>
<a id="aa91f14822373ac8e50ecb18bd23aeee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91f14822373ac8e50ecb18bd23aeee4">&#9670;&nbsp;</a></span>box_decimal_mp_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_mp_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a decimal from msgpack <em>data</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decoded decimal </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer with the msgpack data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the msgpack data does not represent a valid decimal value </dd>
<dd>
the decoded decimal </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + box_decimal_mp_sizeof(retval) </dd></dl>

</div>
</div>
<a id="ae69f4b3c80347bcbfb617a70b57f820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69f4b3c80347bcbfb617a70b57f820e">&#9670;&nbsp;</a></span>box_decimal_mp_decode_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_mp_decode_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a decimal from msgpack <em>data</em> without the msgpack extension header. </p>
<p>| <a class="el" href="module_8h.html#ae69f4b3c80347bcbfb617a70b57f820e" title="Decode a decimal from msgpack data without the msgpack extension header.">box_decimal_mp_decode_data()</a> must be called for this position | | | v | &lt;msgpack type&gt; &lt;size&gt; &lt;extension type&gt; &lt;data&gt; | ^ | | | <a class="el" href="module_8h.html#aa91f14822373ac8e50ecb18bd23aeee4" title="Decode a decimal from msgpack data.">box_decimal_mp_decode()</a> must be called for this position</p>
<p>This function is suitable to finish decoding after calling mp_decode_extl() (from the msgpuck library).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decoded decimal </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer with the msgpack data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the msgpack data does not represent a valid decimal value </dd>
<dd>
the decoded decimal </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>*data = *data + <em>size</em> </dd></dl>

</div>
</div>
<a id="afc7cf68d7ca8998fad15492ae99bbf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7cf68d7ca8998fad15492ae99bbf7e">&#9670;&nbsp;</a></span>box_decimal_mp_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* box_decimal_mp_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a decimal as msgpack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number to encode </td></tr>
    <tr><td class="paramname">data</td><td>buffer to write the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>data</em> + box_decimal_mp_sizeof(<em>dec</em>) </dd></dl>

</div>
</div>
<a id="ad847059b54874f3e4bde5550ec228fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad847059b54874f3e4bde5550ec228fd3">&#9670;&nbsp;</a></span>box_decimal_mp_sizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_decimal_mp_sizeof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate exact buffer size needed to store msgpack representation of a decimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer size </dd></dl>

</div>
</div>
<a id="af8ab08f3604f10eb105b18868511a66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ab08f3604f10eb105b18868511a66d">&#9670;&nbsp;</a></span>box_decimal_mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two decimal numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="a78523b113439b54d761c5ffe19317f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78523b113439b54d761c5ffe19317f59">&#9670;&nbsp;</a></span>box_decimal_pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <em>lhs</em> raised to the power of <em>rhs</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand, base </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand, power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="a1815f3add53077a6f1383db1d9347c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1815f3add53077a6f1383db1d9347c99">&#9670;&nbsp;</a></span>box_decimal_precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_precision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decimal precision. </p>
<p>It is equivalent to amount of decimal digits in the string representation (not counting minus, decimal separator and the leading zero in 0.ddd...ddd number, but counting trailing zeros if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>precision </dd></dl>

</div>
</div>
<a id="aaeb908abdbaea9d758545b1825604101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb908abdbaea9d758545b1825604101">&#9670;&nbsp;</a></span>box_decimal_remainder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the remainder of diviging two decimals. </p>
<p><em>res</em> is set to the remainder of dividing <em>lhs</em> by <em>rhs</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="ac3599d3e81a8144fa1a10199908a84f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3599d3e81a8144fa1a10199908a84f2">&#9670;&nbsp;</a></span>box_decimal_rescale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_rescale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set scale of <em>dec</em> to <em>scale</em>. </p>
<p>If <em>scale</em> is less than scale(<em>dec</em>), round the decimal. Otherwise append a sufficient amount of trailing fractional zeros.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#aae4e2827ab276075fedde86a576d15e9" title="Round to nearest decimal at given scale, half goes away from zero.">box_decimal_round</a> </dd>
<dd>
<a class="el" href="module_8h.html#a8d6b6c8fd7096a6bfe54d65007255281" title="Remove trailing zeros from the fractional part of a number.">box_decimal_trim</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number @oaram scale target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if scale is out of supported range (less than zero or too big) </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="aae4e2827ab276075fedde86a576d15e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4e2827ab276075fedde86a576d15e9">&#9670;&nbsp;</a></span>box_decimal_round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round to nearest decimal at given <em>scale</em>, half goes away from zero. </p>
<p>round(-0.66, 1) -&gt; -0.7 round(-0.65, 1) -&gt; -0.7 round(-0.64, 1) -&gt; -0.6</p>
<p>round(0.64, 1) -&gt; 0.6 round(0.65, 1) -&gt; 0.7 round(0.66, 1) -&gt; 0.7</p>
<p>Resulting decimal number has not more than <em>scale</em> digits after the decimal point.</p>
<p>If <em>scale</em> if greater than current <em>dec</em> scale, do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number @oaram scale target scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if <em>scale</em> is out of supported range </dd>
<dd>
<em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="a3499bd306b660788339570ea8b9f4733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499bd306b660788339570ea8b9f4733">&#9670;&nbsp;</a></span>box_decimal_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_decimal_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decimal scale. </p>
<p>It is equivalent to amount of digits after the decimal separator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scale </dd></dl>

</div>
</div>
<a id="a8947463e9d73c92ffee508b32a3b3d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8947463e9d73c92ffee508b32a3b3d9b">&#9670;&nbsp;</a></span>box_decimal_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">dec</td><td>decimal operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="a26473f8f35e87789e1f7e51e0c9c01d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26473f8f35e87789e1f7e51e0c9c01d5">&#9670;&nbsp;</a></span>box_decimal_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract one decimal number from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>where to hold the result </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on an error (an overflow for example) </dd>
<dd>
decimal result (@res) </dd></dl>

</div>
</div>
<a id="aa213d0898e63876e3ca57cbe506bdfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa213d0898e63876e3ca57cbe506bdfe6">&#9670;&nbsp;</a></span>box_decimal_to_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_to_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given decimal to int64_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">num</td><td>where to store <em>dec</em> integer representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the value does not fit into int64_t </dd>
<dd>
<em>dec</em> </dd></dl>

</div>
</div>
<a id="a7a20acf8704e0a8de6b2c6e70cabda94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a20acf8704e0a8de6b2c6e70cabda94">&#9670;&nbsp;</a></span>box_decimal_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_decimal_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the decimal as a string into the passed buffer. </p>
<p>The buffer must have at least <a class="el" href="module_8h.html#afd0415940d06f795e1f4dcfd40dd6c5b">BOX_DECIMAL_STRING_BUFFER_SIZE</a> bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">buf</td><td>where to write <em>dec</em> string representation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af45f83c5dd155eb132a17f0a4e2efa47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45f83c5dd155eb132a17f0a4e2efa47">&#9670;&nbsp;</a></span>box_decimal_to_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_to_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given decimal to uint64_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>source decimal number </td></tr>
    <tr><td class="paramname">num</td><td>where to store <em>dec</em> integer representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the value does not fit into uint64_t </dd>
<dd>
<em>dec</em> </dd></dl>

</div>
</div>
<a id="a8d6b6c8fd7096a6bfe54d65007255281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6b6c8fd7096a6bfe54d65007255281">&#9670;&nbsp;</a></span>box_decimal_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing zeros from the fractional part of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>decimal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>dec</em> (changed) </dd></dl>

</div>
</div>
<a id="ab5057a778894e99543a07aecbce998af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5057a778894e99543a07aecbce998af">&#9670;&nbsp;</a></span>box_decimal_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* box_decimal_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>dec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a zero decimal number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dec</td><td>where to store the decimal result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decimal result </dd></dl>

</div>
</div>
<a id="a740bf8f0f5f912dfa78221c9fe5f21bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740bf8f0f5f912dfa78221c9fe5f21bb">&#9670;&nbsp;</a></span>box_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_delete </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an DELETE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>an old tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:<span class="keyword">delete</span>(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a800a57f7e18f0b9c3880d4e516589e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a57f7e18f0b9c3880d4e516589e73">&#9670;&nbsp;</a></span>box_error_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce">box_error_code</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return IPROTO error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum box_error_code </dd></dl>

</div>
</div>
<a id="af8f82c313ba49fc97782663ffba71f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f82c313ba49fc97782663ffba71f58">&#9670;&nbsp;</a></span>box_error_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a>* box_error_last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about the last API call error. </p>
<p>The Tarantool error handling works most like libc's errno. All API calls return -1 or NULL in the event of error. An internal pointer to box_error_t type is set by API functions to indicate what went wrong. This value is only significant if API call failed (returned -1 or NULL).</p>
<p>Successful function can also touch the last error in some cases. You don't have to clear the last error before calling API functions. The returned object is valid only until next call to <b>any</b> API function.</p>
<p>You must set the last error using <a class="el" href="module_8h.html#aa6e6803bc4309c3f59b93e2709cb418b" title="Set the last error.">box_error_set()</a> in your stored C procedures if you want to return a custom error message. You can re-throw the last API error to IPROTO client by keeping the current value and returning -1 to Tarantool from your stored procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>last error. </dd></dl>

</div>
</div>
<a id="aff2a8679174320da6a54edc6df4681ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2a8679174320da6a54edc6df4681ae">&#9670;&nbsp;</a></span>box_error_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_error_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>not-null string </dd></dl>

</div>
</div>
<a id="aa6e6803bc4309c3f59b93e2709cb418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e6803bc4309c3f59b93e2709cb418b">&#9670;&nbsp;</a></span>box_error_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_error_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the last error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>IPROTO error code (enum <a class="el" href="module_8h.html#a800a57f7e18f0b9c3880d4e516589e73">box_error_code</a>) </td></tr>
    <tr><td class="paramname">format</td><td>(const char * ) - printf()-like format string </td></tr>
    <tr><td class="paramname">...</td><td>- format arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for convention use</dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="module_8h.html#a029e9d16d637a97b37560ccf24c4adce" title="public">box_error_code</a> </dd></dl>

</div>
</div>
<a id="a9b58e493b5515222c6bb9c0393d092ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b58e493b5515222c6bb9c0393d092ce">&#9670;&nbsp;</a></span>box_error_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_error_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#ad49d5e355555804f6b46b79513715be8">box_error_t</a> *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error type, e.g. </p>
<p>"ClientError", "SocketError", etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>not-null string </dd></dl>

</div>
</div>
<a id="a1fb9d369f674c637b476fd92b00d3da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb9d369f674c637b476fd92b00d3da5">&#9670;&nbsp;</a></span>box_ibuf_read_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_ibuf_read_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>rpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>wpos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointers to read range pointers used [rpos..wpos) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>ibuf structure </td></tr>
    <tr><td class="paramname">rpos</td><td>where to place ibuf.rpos address </td></tr>
    <tr><td class="paramname">wpos</td><td>where to place ibuf.wpos address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b6dd91e6e7f26a9b57f4c317c2af203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6dd91e6e7f26a9b57f4c317c2af203">&#9670;&nbsp;</a></span>box_ibuf_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* box_ibuf_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve requested amount of bytes in ibuf buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>buffer used for allocation </td></tr>
    <tr><td class="paramname">size</td><td>allocated bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error, check diag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74b2d0e25c3a295f9ae0200a787c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b2d0e25c3a295f9ae0200a787c432">&#9670;&nbsp;</a></span>box_ibuf_write_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_ibuf_write_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>wpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointers to write range pointers used [wpos..end) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibuf</td><td>ibuf structure </td></tr>
    <tr><td class="paramname">wpos</td><td>where to place ibuf.rpos address </td></tr>
    <tr><td class="paramname">end</td><td>where to place ibuf.wpos address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeda3d99d32c382bc5ac2bc8f0a09f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda3d99d32c382bc5ac2bc8f0a09f48">&#9670;&nbsp;</a></span>box_index_bsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_bsize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes used in memory by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=</td><td>0 otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f06a7df9e461267455477bd84ce02ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f06a7df9e461267455477bd84ce02ed">&#9670;&nbsp;</a></span>box_index_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_count </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramname">type</td><td>iterator type - enum <a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator_type</a> </td></tr>
    <tr><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:count(key,</div>
<div class="line">   { iterator = type }) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5c9cedd4198d62ddfe6c77ef2bf89f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9cedd4198d62ddfe6c77ef2bf89f56">&#9670;&nbsp;</a></span>box_index_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a tuple from index by the key. </p>
<p>Please note that this function works much more faster than box_select() or <a class="el" href="module_8h.html#aab8b69829c8d89799a9fb0e5d360e84b" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a> + <a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347" title="Retrieve the next item from the iterator.">box_iterator_next()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>key != NULL </dd></dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:get(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4abb8381625fb1364af63d58a0235b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abb8381625fb1364af63d58a0235b3a">&#9670;&nbsp;</a></span>box_index_id_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_index_id_by_name </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find index id by name. </p>
<p>This function performs SELECT request to _vindex system space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">name</td><td>index name </td></tr>
    <tr><td class="paramname">len</td><td>length of <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BOX_ID_NIL</td><td>on error or if not found (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">index_id</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a4a816d0fc386d810b874b50db1f50293" title="Find space id by name.">box_space_id_by_name</a> </dd></dl>

</div>
</div>
<a id="aab8b69829c8d89799a9fb0e5d360e84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8b69829c8d89799a9fb0e5d360e84b">&#9670;&nbsp;</a></span>box_index_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a>* box_index_iterator </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize iterator for space_id, index_id. </p>
<p>A returned iterator must be destroyed by <a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c" title="Destroy and deallocate iterator.">box_iterator_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier. </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier. </td></tr>
    <tr><td class="paramname">type</td><td><a class="el" href="module_8h.html#a2693ce4bd8fa71e8ac1e5272fc64d17e">iterator type </a> </td></tr>
    <tr><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramname">key_end</td><td>the end of encoded <em>key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">iterator</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ae4361728e6abe6243e7f02b098e7b347" title="Retrieve the next item from the iterator.">box_iterator_next()</a> </dd>
<dd>
<a class="el" href="module_8h.html#a6f7fe762b15009de313fdf915378429c" title="Destroy and deallocate iterator.">box_iterator_free()</a> </dd></dl>

</div>
</div>
<a id="a698d8991fa015a4b490f078b29e8d929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698d8991fa015a4b490f078b29e8d929">&#9670;&nbsp;</a></span>box_index_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_index_len </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of element in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramname">index_id</td><td>index identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">&gt;=</td><td>0 otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044e5f79addcfd9c7312fe66e7be7514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e5f79addcfd9c7312fe66e7be7514">&#9670;&nbsp;</a></span>box_index_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_max </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a last (maximal) tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:max(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4fbd278987613571a9d6475de6103a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbd278987613571a9d6475de6103a4f">&#9670;&nbsp;</a></span>box_index_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_min </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a first (minimal) tuple matched the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:min(key) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa56e2bf2a5720259ea3997149ae53ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56e2bf2a5720259ea3997149ae53ca9">&#9670;&nbsp;</a></span>box_index_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_index_random </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random tuple from the index (useful for statistical analysis). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rnd</td><td>random seed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if index is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:random(rnd) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a08571f03c05abf96fd6e98a590d78822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08571f03c05abf96fd6e98a590d78822">&#9670;&nbsp;</a></span>box_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_insert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an INSERT request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id]:insert(tuple) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6f6d1752bccac95ed2d154a98c3fe9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6d1752bccac95ed2d154a98c3fe9c7">&#9670;&nbsp;</a></span>box_iproto_override()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iproto_override </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>req_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a19dc8ff47cfc25ee92d0f74cdf459070">iproto_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa9eb59c79a9b32bb8a23204e89bced9d">iproto_handler_destroy_t</a>&#160;</td>
          <td class="paramname"><em>destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an IPROTO request handler with the provided context for the given request type. </p>
<p>NB: yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_type</td><td>request type code from iproto_type enumeration (src/box/iproto_constants.h); use IPROTO_UNKNOWN for overriding the handler of unknown request types; </td></tr>
    <tr><td class="paramname">handler</td><td>IPROTO request handler; passing NULL resets the corresponding handler </td></tr>
    <tr><td class="paramname">destroy</td><td>IPROTO request handler destructor </td></tr>
    <tr><td class="paramname">ctx</td><td>context passed to handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcef363e704e69cb0cc4efb80c6a648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcef363e704e69cb0cc4efb80c6a648e">&#9670;&nbsp;</a></span>box_iproto_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iproto_send </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>body_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a packet with the given header and body over the IPROTO session's socket. </p>
<p>NB: yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>IPROTO session identifier </td></tr>
    <tr><td class="paramname">header</td><td>MsgPack encoded header </td></tr>
    <tr><td class="paramname">header_end</td><td>MsgPack encoded header end </td></tr>
    <tr><td class="paramname">body</td><td>MsgPack encoded body </td></tr>
    <tr><td class="paramname">body_end</td><td>MsgPack encoded body end </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f7fe762b15009de313fdf915378429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7fe762b15009de313fdf915378429c">&#9670;&nbsp;</a></span>box_iterator_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_iterator_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and deallocate iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>an iterator returned by <a class="el" href="module_8h.html#aab8b69829c8d89799a9fb0e5d360e84b" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4361728e6abe6243e7f02b098e7b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4361728e6abe6243e7f02b098e7b347">&#9670;&nbsp;</a></span>box_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a2b04d0397e455b7ed42b530c1c1ea9e6">box_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next item from the <em>iterator</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iterator</td><td>an iterator returned by <a class="el" href="module_8h.html#aab8b69829c8d89799a9fb0e5d360e84b" title="Allocate and initialize iterator for space_id, index_id.">box_index_iterator()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a tuple or NULL if there is no more data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a> for details) </td></tr>
    <tr><td class="paramname">0</td><td>on success. The end of data is not an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82fdf05e0d276baa072123358c29e046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fdf05e0d276baa072123358c29e046">&#9670;&nbsp;</a></span>box_key_def_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_key_def_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>key definition to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6ea5a24503d921ba39fab504eac17fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ea5a24503d921ba39fab504eac17fe">&#9670;&nbsp;</a></span>box_key_def_dump_parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a>* box_key_def_dump_parts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>part_count_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump key part definitions of given key_def. </p>
<p>The function allocates key parts and storage for pointer fields (e.g. collation names) on the box region. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_region_truncate&gt;().</dd></dl>
<p>&lt;box_key_part_def_t&gt; fields that are unknown at given tarantool version are set to zero. The same for unknown &lt;flags&gt; bits.</p>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="af072fd108644a06c68d5ba1f74efb460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af072fd108644a06c68d5ba1f74efb460">&#9670;&nbsp;</a></span>box_key_def_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a>* box_key_def_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate key_def. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Original key_def.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Duplicate of src. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e3e05887ff307b8ac5390f70f60158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3e05887ff307b8ac5390f70f60158">&#9670;&nbsp;</a></span>box_key_def_extract_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* box_key_def_extract_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multikey_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract key from tuple by given key definition and return buffer allocated on the box region with this key. </p>
<dl class="section see"><dt>See also</dt><dd>&lt;box_region_truncate&gt;().</dd></dl>
<p>This function has O(n) complexity, where n is the number of key parts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Definition of key that need to extract. </td></tr>
    <tr><td class="paramname">tuple</td><td>Tuple from which need to extract key. </td></tr>
    <tr><td class="paramname">multikey_idx</td><td>Multikey index hint or -1. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of extracted key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Success. </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="ad2ee8761b613b5a518f94dc7f2ca0073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ee8761b613b5a518f94dc7f2ca0073">&#9670;&nbsp;</a></span>box_key_def_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a>* box_key_def_merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new key_def with a set union of key parts from first and second key defs. </p>
<p>Parts of the new key_def consist of the first key_def's parts and those parts of the second key_def that were not among the first parts.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Ok. </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory error.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="aa6977b1c26a2a187c8d4de4e93799186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6977b1c26a2a187c8d4de4e93799186">&#9670;&nbsp;</a></span>box_key_def_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a>* box_key_def_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>part_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create key definition with given field numbers and field types. </p>
<p>May be used for tuple format creation and/or tuple comparison.</p>
<dl class="section see"><dt>See also</dt><dd>&lt;box_key_def_new_v2&gt;().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>array with key field identifiers </td></tr>
    <tr><td class="paramname">types</td><td>array with key field types (see enum field_type) </td></tr>
    <tr><td class="paramname">part_count</td><td>the number of key fields </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new key definition object </dd></dl>

</div>
</div>
<a id="a3591006ff571eb1ac2b05f5e41a8a8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591006ff571eb1ac2b05f5e41a8a8ca">&#9670;&nbsp;</a></span>box_key_def_new_v2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a>* box_key_def_new_v2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td>
          <td class="paramname"><em>parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>part_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a key_def from given key parts. </p>
<p>Unlike &lt;box_key_def_new&gt;() this function allows to define nullability, collation and other options for each key part.</p>
<p>&lt;box_key_part_def_t&gt; fields that are unknown at given tarantool version are ignored. The same for unknown &lt;flags&gt; bits.</p>
<p>In case of an error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="a237492509ee5f9e478b72077c4c65833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237492509ee5f9e478b72077c4c65833">&#9670;&nbsp;</a></span>box_key_def_validate_full_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_full_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a full key against given key definition. </p>
<p>Verifies key parts against given key_def's field types with respect to nullability.</p>
<p>Imposes the same parts count in <em>key</em> as in <em>key_def</em>. Absence of trailing key parts fails the check.</p>
<p>Note: nil is accepted for nullable fields, but only for them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">key</td><td>MessagePack'ed data for matching. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of the validated key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The key is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The key is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid key set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="a32868fa25087aa7d7249fd2692a0ac52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32868fa25087aa7d7249fd2692a0ac52">&#9670;&nbsp;</a></span>box_key_def_validate_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a key against given key definition. </p>
<p>Verifies key parts against given key_def's field types with respect to nullability.</p>
<p>A partial key (with less part than defined in <em>key_def</em>) is verified by given key parts, the omitted tail is not verified anyhow.</p>
<p>Note: nil is accepted for nullable fields, but only for them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">key</td><td>MessagePack'ed data for matching. </td></tr>
    <tr><td class="paramname">key_size_ptr</td><td>Here will be size of the validated key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The key is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The key is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid key set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="a3c01aea33b0593fd1b84243be7033469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c01aea33b0593fd1b84243be7033469">&#9670;&nbsp;</a></span>box_key_def_validate_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_key_def_validate_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that tuple fields match with given key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_def</td><td>Key definition. </td></tr>
    <tr><td class="paramname">tuple</td><td>Tuple to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The tuple is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The tuple is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>In case of an invalid tuple set a diag and return -1. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="a52f751905f893144ead356172137e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f751905f893144ead356172137e796">&#9670;&nbsp;</a></span>box_key_part_def_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_key_part_def_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a302d3f85cf14f03ace911e9541c95c4d">box_key_part_def_t</a> *&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a key part with default values. </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Details    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fieldno   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">flags   </td><td class="markdownTableBodyNone">&lt;default flags&gt;   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">field_type   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone">[^1]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">collation   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">NULL   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Default flag values are the following:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Default value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BOX_KEY_PART_DEF_IS_NULLABLE   </td><td class="markdownTableBodyNone">0 (unset)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">BOX_KEY_PART_DEF_EXCLUDE_NULL   </td><td class="markdownTableBodyNone">0 (unset)   </td></tr>
</table>
<p>Default values of fields and flags are permitted to be changed in future tarantool versions. However we should be VERY conservative here and consider any meaningful usage scenarios, when doing so. At least new defaults should be consistent with how tarantool itself doing key_def related operations: validation, key extraction, comparisons and so on.</p>
<p>All trailing padding bytes are set to zero. The same for unknown &lt;flags&gt; bits.</p>
<p>[^1]: &lt;box_key_def_new_v2&gt;() does not accept NULL as a &lt;field_type&gt;, so it should be filled explicitly. </p>

</div>
</div>
<a id="a83a897e7386e946cd5ffd2ea1cb47a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a897e7386e946cd5ffd2ea1cb47a52">&#9670;&nbsp;</a></span>box_latch_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy and free the latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef397199dd9a19cb7b9362233a1d4a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef397199dd9a19cb7b9362233a1d4a98">&#9670;&nbsp;</a></span>box_latch_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a latch. </p>
<p>Waits indefinitely until the current fiber can gain access to the latch. Locks are acquired in the strict order as they were requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c106ac756a1b7fa422a72e71b379b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c106ac756a1b7fa422a72e71b379b0a">&#9670;&nbsp;</a></span>box_latch_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a>* box_latch_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the new latch. </p>
<dl class="section return"><dt>Returns</dt><dd>latch </dd></dl>

</div>
</div>
<a id="a294e53c819e91f172428d580a29f434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294e53c819e91f172428d580a29f434f">&#9670;&nbsp;</a></span>box_latch_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_latch_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock a latch. </p>
<p>Return immediately if the latch is locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">1</td><td>- the latch is locked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11dea9d7a0347d38956ed59f739c68ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dea9d7a0347d38956ed59f739c68ca">&#9670;&nbsp;</a></span>box_latch_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_latch_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a923d13f137e4bdb8c852ea04637da58d">box_latch_t</a> *&#160;</td>
          <td class="paramname"><em>latch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a latch. </p>
<p>The fiber calling this function must own the latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latch</td><td>a latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a35d7a7fe53c673112e06ab78794216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a35d7a7fe53c673112e06ab78794216">&#9670;&nbsp;</a></span>box_on_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_on_shutdown </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>new_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *)&#160;</td>
          <td class="paramname"><em>old_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statement Attributes }}}. </p>
<p>public Function, which registers or deletes on_shutdown handler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>on_shutdown function's argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_handler</td><td>New on_shutdown handler, in case this argument is NULL, function finds and destroys old on_shutdown handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_handler</td><td>Old on_shutdown handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">return</td><td>0 if success otherwise return -1 and sets errno. There are three cases when function fails:<ul>
<li>both old_handler and new_handler are equal to zero (sets errno to EINVAL).</li>
<li>old_handler != NULL, but there is no trigger with such function (sets errno to EINVAL).</li>
<li>malloc for some internal struct memory allocation return NULL (errno sets by malloc to ENOMEM). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a541b6608e37fc392112a9aee229432fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541b6608e37fc392112a9aee229432fa">&#9670;&nbsp;</a></span>box_region_aligned_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* box_region_aligned_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate size bytes from the box region with given alignment. </p>
<p>Alignment must be a power of 2.</p>
<p>In case of a memory error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="ac8e7d6a912f5f8230bd8c8035735ef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7d6a912f5f8230bd8c8035735ef2f">&#9670;&nbsp;</a></span>box_region_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* box_region_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate size bytes from the box region. </p>
<p>Don't use this function to allocate a memory block for a value or array of values of a type with alignment requirements. A violation of alignment requirements leads to undefined behaviour.</p>
<p>In case of a memory error set a diag and return NULL. </p><dl class="section see"><dt>See also</dt><dd>&lt;box_error_last&gt;(). </dd></dl>

</div>
</div>
<a id="a113af82955ade6d52b5a03fc327b266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113af82955ade6d52b5a03fc327b266f">&#9670;&nbsp;</a></span>box_region_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t box_region_used </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>box region allocator </p>
<p>It is the region allocator from the small library. It is useful for allocating tons of small objects and free them at once.</p>
<p>Typical usage is illustrated in the sketch below.</p>
<p>| size_t region_svp = <a class="el" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f" title="box region allocator">box_region_used()</a>; | while (&lt;...&gt;) { | char *buf = box_region_alloc(&lt;...&gt;); | &lt;...&gt; | } | box_region_truncate(region_svp);</p>
<p>There are module API functions that return a result on this region. In this case a caller is responsible to free the result:</p>
<p>| size_t region_svp = <a class="el" href="module_8h.html#a113af82955ade6d52b5a03fc327b266f" title="box region allocator">box_region_used()</a>; | char *buf = box_&lt;...&gt;(&lt;...&gt;); | &lt;...&gt; | box_region_truncate(region_svp);</p>
<p>This API provides better compatibility guarantees over using the small library directly in a module. A binary layout of internal structures may be changed in a future, but &lt;box_region_*&gt;() functions will remain API and ABI compatible.</p>
<p>Each fiber has its own box region. It means that a call of, say, &lt;box_region_used&gt;() will give its own value in different fibers. It also means that a yield does not invalidate data in the box region.</p>
<p>Prior to version 2.11, the box region was implicitly cleaned up on transaction commit (see &lt;box_txn_commit&gt;()) so that &lt;box_region_truncate&gt;() wasn't strictly necessary. Starting from version 2.11, it isn't true anymore, and the client code must free all its allocations explicitly. How much memory is used by the box region. </p>

</div>
</div>
<a id="a933b6e9cbf9d4fc05e3964b0949b5bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933b6e9cbf9d4fc05e3964b0949b5bd0">&#9670;&nbsp;</a></span>box_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_replace </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an REPLACE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id]:replace(tuple) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a96bf7ae13f994a18d2f9dcf7816578ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf7ae13f994a18d2f9dcf7816578ca">&#9670;&nbsp;</a></span>box_return_mp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_return_mp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mp_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return MessagePack from a stored C procedure. </p>
<p>The MessagePack is copied, so it is safe to free/reuse the passed arguments after the call. MessagePack is not validated, for the sake of speed. It is expected to be a single encoded object. An attempt to encode and return multiple objects without wrapping them into an MP_ARRAY or MP_MAP is undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>An opaque structure passed to the stored C procedure by Tarantool. </td></tr>
    <tr><td class="paramname">mp</td><td>Begin of MessagePack. </td></tr>
    <tr><td class="paramname">mp_end</td><td>End of MessagePack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>Error. </td></tr>
    <tr><td class="paramname">0</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb00cd4eac4d388d58e9e5ef1ea1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb00cd4eac4d388d58e9e5ef1ea1b3f">&#9670;&nbsp;</a></span>box_return_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_return_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa37ca06842be0fe827d5272493e2311f">box_function_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tuple from stored C procedure. </p>
<p>Returned tuple is automatically reference counted by Tarantool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>an opaque structure passed to the stored C procedure by Tarantool </td></tr>
    <tr><td class="paramname">tuple</td><td>a tuple to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (perhaps, out of memory; check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b1e8f1e92bb906daefd5666e0ff2f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1e8f1e92bb906daefd5666e0ff2f4d">&#9670;&nbsp;</a></span>box_schema_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t box_schema_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Returns the current version of the database schema, an unsigned number that goes up when there is a major change in the schema, i.e., on DDL operations (</p><dl class="section see"><dt>See also</dt><dd>IPROTO_SCHEMA_VERSION). </dd></dl>

</div>
</div>
<a id="a66ac5f1357a07acaae764e5d2e2e55fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ac5f1357a07acaae764e5d2e2e55fa">&#9670;&nbsp;</a></span>box_sequence_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_current </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last value returned by a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to a variable where the current sequence value will be stored on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e5fd9116818749f73bf868d4e780256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5fd9116818749f73bf868d4e780256">&#9670;&nbsp;</a></span>box_sequence_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_next </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>pointer to a variable where the next sequence value will be stored on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9c3210df64b1f6fd89eb2c5e088e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c3210df64b1f6fd89eb2c5e088e94">&#9670;&nbsp;</a></span>box_sequence_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_reset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2243f60e2773d3522a540103f645110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2243f60e2773d3522a540103f645110">&#9670;&nbsp;</a></span>box_sequence_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_sequence_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a sequence value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_id</td><td>sequence identifier </td></tr>
    <tr><td class="paramname">value</td><td>new sequence value; on success the next call to <a class="el" href="module_8h.html#a3e5fd9116818749f73bf868d4e780256" title="Advance a sequence.">box_sequence_next()</a> will return the value following <em>value</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a6ea7f0c101d1986f27de9f8ec25c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a6ea7f0c101d1986f27de9f8ec25c8">&#9670;&nbsp;</a></span>box_session_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t box_session_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current session's unique monotonic identifier (</dd></dl>
<dl class="section see"><dt>See also</dt><dd>box.session.id) </dd></dl>

</div>
</div>
<a id="a0e9c91d463ce4aca081e5bd376aac1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9c91d463ce4aca081e5bd376aac1d9">&#9670;&nbsp;</a></span>box_session_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_session_push </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push MessagePack data into a session data channel - socket, console or whatever is behind the session. </p>
<p>Note, that successful push does not guarantee delivery in case it was sent into the network. Just like with write()/send() system calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>begin of MessagePack to push </td></tr>
    <tr><td class="paramname">data_end</td><td>end of MessagePack to push </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a816d0fc386d810b874b50db1f50293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a816d0fc386d810b874b50db1f50293">&#9670;&nbsp;</a></span>box_space_id_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_space_id_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find space id by name. </p>
<p>This function performs SELECT request to _vspace system space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>space name </td></tr>
    <tr><td class="paramname">len</td><td>length of <em>name</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BOX_ID_NIL</td><td>on error or if not found (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">space_id</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a4abb8381625fb1364af63d58a0235b3a" title="Find index id by name.">box_index_id_by_name</a> </dd></dl>

</div>
</div>
<a id="a20de21b171ded688588f1063ac04a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20de21b171ded688588f1063ac04a9d3">&#9670;&nbsp;</a></span>box_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_truncate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>space identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6812d20a87dc1f55648679680d0d2272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6812d20a87dc1f55648679680d0d2272">&#9670;&nbsp;</a></span>box_tuple_bsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t box_tuple_bsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes used to store internal tuple data (MsgPack Array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b978e168708341cb358a15c5e42430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b978e168708341cb358a15c5e42430">&#9670;&nbsp;</a></span>box_tuple_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare tuples using the key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_a</td><td>first tuple </td></tr>
    <tr><td class="paramname">tuple_b</td><td>second tuple </td></tr>
    <tr><td class="paramname">key_def</td><td>key definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if key_fields(tuple_a) == key_fields(tuple_b) </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if key_fields(tuple_a) &lt; key_fields(tuple_b) </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if key_fields(tuple_a) &gt; key_fields(tuple_b) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8fec3862fabe2eb885bb71517b99a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fec3862fabe2eb885bb71517b99a5f">&#9670;&nbsp;</a></span>box_tuple_compare_with_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_compare_with_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#acfbe4043908ad1b4a106689ad2da8814">box_key_def_t</a> *&#160;</td>
          <td class="paramname"><em>key_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare tuple with key using the key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple </td></tr>
    <tr><td class="paramname">key</td><td>key with MessagePack array header </td></tr>
    <tr><td class="paramname">key_def</td><td>key definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if key_fields(tuple) == parts(key) </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if key_fields(tuple) &lt; parts(key) </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if key_fields(tuple) &gt; parts(key) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1314851b7b1ec2fab6908eaef71f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1314851b7b1ec2fab6908eaef71f52">&#9670;&nbsp;</a></span>box_tuple_extract_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* box_tuple_extract_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract key from tuple according to key definition of given index. </p>
<p>Returned buffer is allocated on <a class="el" href="module_8h.html#adf5cc88ba87d8e5afe81604385609191" title="Allocate memory on txn memory pool.">box_txn_alloc()</a> with this key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple from which need to extract key. </td></tr>
    <tr><td class="paramname">space_id</td><td>Space identifier. </td></tr>
    <tr><td class="paramname">index_id</td><td>Index identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">not</td><td>NULL Success </td></tr>
    <tr><td class="paramname">NULL</td><td>Memory Allocation error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b0c6fa0fbeb5d6f2974e8b82aa83f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0c6fa0fbeb5d6f2974e8b82aa83f0">&#9670;&nbsp;</a></span>box_tuple_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_tuple_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fieldno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the raw tuple field in MsgPack format. </p>
<p>The buffer is valid until next call to box_tuple_* functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
    <tr><td class="paramname">fieldno</td><td>zero-based index in MsgPack array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if i &gt;= box_tuple_field_count(tuple) </td></tr>
    <tr><td class="paramname">msgpack</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74729917c4ca28b3044569f5eccaecd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74729917c4ca28b3044569f5eccaecd9">&#9670;&nbsp;</a></span>box_tuple_field_by_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_tuple_field_by_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a raw tuple field in the MsgPack format pointed by a JSON path. </p>
<p>The JSON path includes the outmost field. For example, "c" in ["a", ["b", "c"], "d"] can be accessed using "[2][2]" path (if index_base is 1, as in Lua). If index_base is set to 0, the same field will be pointed by the "[1][1]" path.</p>
<p>The first JSON path token may be a field name if the tuple has associated format with named fields. A field of a nested map can be accessed in the same way: "foo.bar" or ".foo.bar".</p>
<p>The return value is valid until the tuple is destroyed, see <a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a>.</p>
<p>Return NULL if the field does not exist or if the JSON path is malformed or invalid. Multikey JSON path token [*] is treated as invalid in this context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
    <tr><td class="paramname">path</td><td>a JSON path </td></tr>
    <tr><td class="paramname">path_len</td><td>a length of <em>path</em> </td></tr>
    <tr><td class="paramname">index_base</td><td>0 if array element indexes in <em>path</em> are zero-based (like in C) or 1 if they're one-based (like in Lua) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>pointer to a field data if the field exists or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a800d61b749ed483d35b65025eaa3039e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800d61b749ed483d35b65025eaa3039e">&#9670;&nbsp;</a></span>box_tuple_field_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_tuple_field_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of fields in tuple (the size of MsgPack Array). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7195d3207b3d7e034473d26b6d24dd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7195d3207b3d7e034473d26b6d24dd2f">&#9670;&nbsp;</a></span>box_tuple_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a>* box_tuple_format </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the associated format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple_format </dd></dl>

</div>
</div>
<a id="a5a457c9503bb15df42c4854fbede340e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a457c9503bb15df42c4854fbede340e">&#9670;&nbsp;</a></span>box_tuple_format_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a>* box_tuple_format_default </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tuple Format. </p>
<p>Each Tuple has associated format (class). Default format is used to create tuples which are not attach to any particular space. </p>

</div>
</div>
<a id="a1515eaa49be2b9990eab5fff279600be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1515eaa49be2b9990eab5fff279600be">&#9670;&nbsp;</a></span>box_tuple_format_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a>* box_tuple_format_new </td>
          <td>(</td>
          <td class="paramtype">struct key_def **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Return new in-memory tuple format based on passed key definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>array of keys defined for the format \key_count count of keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">new</td><td>tuple format if success </td></tr>
    <tr><td class="paramname">NULL</td><td>for error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc998b676589a854eaf71e2e1fd4debc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc998b676589a854eaf71e2e1fd4debc">&#9670;&nbsp;</a></span>box_tuple_format_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_format_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment tuple format ref count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_format</td><td>the tuple format to ref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134eab27cb960c030d553d3881d8d074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134eab27cb960c030d553d3881d8d074">&#9670;&nbsp;</a></span>box_tuple_format_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_format_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement tuple format ref count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_format</td><td>the tuple format to unref </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aabe2cc4f09abaa070664c6d7156cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aabe2cc4f09abaa070664c6d7156cd1">&#9670;&nbsp;</a></span>box_tuple_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a>* box_tuple_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new tuple iterator. </p>
<p>The tuple iterator allow to iterate over fields at root level of MsgPack array.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="module_8h.html#a1aabe2cc4f09abaa070664c6d7156cd1">box_tuple_iterator</a> *it = <a class="code" href="module_8h.html#a1aabe2cc4f09abaa070664c6d7156cd1">box_tuple_iterator</a>(tuple);</div>
<div class="line"><span class="keywordflow">if</span> (it == NULL) {</div>
<div class="line">     <span class="comment">// error handling using box_error_last()</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *field;</div>
<div class="line"><span class="keywordflow">while</span> (field = <a class="code" href="module_8h.html#a7b88a4ee472624416d875a906a82d99b">box_tuple_next</a>(it)) {</div>
<div class="line">     <span class="comment">// process raw MsgPack data</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rewind iterator to first position</span></div>
<div class="line"><a class="code" href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a>(it);</div>
<div class="line">assert(<a class="code" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a>(it) == 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rewind iterator to first position</span></div>
<div class="line">field = <a class="code" href="module_8h.html#a76dc6a76579c761e9c7b2b9ced89290a">box_tuple_seek</a>(it, 3);</div>
<div class="line">assert(<a class="code" href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a>(it) == 4);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a>(it);</div>
<div class="ttc" id="amodule_8h_html_a1aabe2cc4f09abaa070664c6d7156cd1"><div class="ttname"><a href="module_8h.html#a1aabe2cc4f09abaa070664c6d7156cd1">box_tuple_iterator</a></div><div class="ttdeci">box_tuple_iterator_t * box_tuple_iterator(box_tuple_t *tuple)</div><div class="ttdoc">Allocate and initialize a new tuple iterator.</div></div>
<div class="ttc" id="amodule_8h_html_a6f7fe762b15009de313fdf915378429c"><div class="ttname"><a href="module_8h.html#a6f7fe762b15009de313fdf915378429c">box_iterator_free</a></div><div class="ttdeci">void box_iterator_free(box_iterator_t *iterator)</div><div class="ttdoc">Destroy and deallocate iterator.</div></div>
<div class="ttc" id="amodule_8h_html_a76dc6a76579c761e9c7b2b9ced89290a"><div class="ttname"><a href="module_8h.html#a76dc6a76579c761e9c7b2b9ced89290a">box_tuple_seek</a></div><div class="ttdeci">const char * box_tuple_seek(box_tuple_iterator_t *it, uint32_t fieldno)</div><div class="ttdoc">Seek the tuple iterator.</div></div>
<div class="ttc" id="amodule_8h_html_a7b88a4ee472624416d875a906a82d99b"><div class="ttname"><a href="module_8h.html#a7b88a4ee472624416d875a906a82d99b">box_tuple_next</a></div><div class="ttdeci">const char * box_tuple_next(box_tuple_iterator_t *it)</div><div class="ttdoc">Return the next tuple field from tuple iterator.</div></div>
<div class="ttc" id="amodule_8h_html_aaa998b89aa550c51d8576d3b766d1a67"><div class="ttname"><a href="module_8h.html#aaa998b89aa550c51d8576d3b766d1a67">box_tuple_rewind</a></div><div class="ttdeci">void box_tuple_rewind(box_tuple_iterator_t *it)</div><div class="ttdoc">Rewind iterator to the initial position.</div></div>
<div class="ttc" id="amodule_8h_html_ac24865c6c4138cd6a252f32c55c812c6"><div class="ttname"><a href="module_8h.html#ac24865c6c4138cd6a252f32c55c812c6">box_tuple_position</a></div><div class="ttdeci">uint32_t box_tuple_position(box_tuple_iterator_t *it)</div><div class="ttdoc">Return zero-based next position in iterator.</div></div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == 0 </dd></dl>

</div>
</div>
<a id="a442eb6797ae4d114d00dc68f2b1e361a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442eb6797ae4d114d00dc68f2b1e361a">&#9670;&nbsp;</a></span>box_tuple_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a>* box_tuple_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new tuple from a raw MsgPack Array data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>tuple format. Use <a class="el" href="module_8h.html#a5a457c9503bb15df42c4854fbede340e" title="Tuple Format.">box_tuple_format_default()</a> to create space-independent tuple. </td></tr>
    <tr><td class="paramname">data</td><td>tuple data in MsgPack Array format ([field1, field2, ...]). </td></tr>
    <tr><td class="paramname">end</td><td>the end of <em>data</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tuple</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>data, end is valid MsgPack Array </dd></dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.tuple.new(data) </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7b88a4ee472624416d875a906a82d99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b88a4ee472624416d875a906a82d99b">&#9670;&nbsp;</a></span>box_tuple_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_tuple_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next tuple field from tuple iterator. </p>
<p>The returned buffer is valid until next call to box_tuple_* API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if there are no more fields. </td></tr>
    <tr><td class="paramname">MsgPack</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>box_tuple_position(it) is zero-based id of returned field </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == box_tuple_field_count(tuple) if returned value is NULL. </dd></dl>

</div>
</div>
<a id="ac24865c6c4138cd6a252f32c55c812c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24865c6c4138cd6a252f32c55c812c6">&#9670;&nbsp;</a></span>box_tuple_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t box_tuple_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return zero-based next position in iterator. </p>
<p>That is, this function return the field id of field that will be returned by the next call to box_tuple_next(it). Returned value is zero after initialization or rewind and box_tuple_field_count(tuple) after the end of iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position. </dd></dl>

</div>
</div>
<a id="a2211f2682d19f564c55f2888e35d6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2211f2682d19f564c55f2888e35d6430">&#9670;&nbsp;</a></span>box_tuple_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the reference counter of tuple. </p>
<p>Tuples are reference counted. All functions that return tuples guarantee that the last returned tuple is refcounted internally until the next call to API function that yields or returns another tuple.</p>
<p>You should increase the reference counter before taking tuples for long processing in your code. Such tuples will not be garbage collected even if another fiber remove they from space. After processing please decrement the reference counter using <a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc" title="Decrease the reference counter of tuple.">box_tuple_unref()</a>, otherwise the tuple will leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>always </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a22d7b12b1afbff0c3cc20726c10cc6cc" title="Decrease the reference counter of tuple.">box_tuple_unref()</a> </dd></dl>

</div>
</div>
<a id="aaa998b89aa550c51d8576d3b766d1a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa998b89aa550c51d8576d3b766d1a67">&#9670;&nbsp;</a></span>box_tuple_rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind iterator to the initial position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == 0 </dd></dl>

</div>
</div>
<a id="a76dc6a76579c761e9c7b2b9ced89290a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc6a76579c761e9c7b2b9ced89290a">&#9670;&nbsp;</a></span>box_tuple_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* box_tuple_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#aa289ab037764b9f065d4b683cb186bda">box_tuple_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fieldno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek the tuple iterator. </p>
<p>The returned buffer is valid until next call to box_tuple_* API. Requested fieldno returned by next call to box_tuple_next(it).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>tuple iterator </td></tr>
    <tr><td class="paramname">fieldno</td><td>- zero-based position in MsgPack array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>box_tuple_position(it) == fieldno if returned value is not NULL </dd>
<dd>
box_tuple_position(it) == box_tuple_field_count(tuple) if returned value is NULL. </dd></dl>

</div>
</div>
<a id="af520a6742b61a5bcb879b75d09d72f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af520a6742b61a5bcb879b75d09d72f4e">&#9670;&nbsp;</a></span>box_tuple_to_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t box_tuple_to_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump raw MsgPack data to the memory buffer <em>buf</em> of size <em>size</em>. </p>
<p>Store tuple fields in the memory buffer. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error. </td></tr>
    <tr><td class="paramname">number</td><td>of bytes written on success. Upon successful return, the function returns the number of bytes written. If buffer size is not enough then the return value is the number of bytes which would have been written if enough space had been available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d7b12b1afbff0c3cc20726c10cc6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d7b12b1afbff0c3cc20726c10cc6cc">&#9670;&nbsp;</a></span>box_tuple_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_tuple_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease the reference counter of tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>a tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a> </dd></dl>

</div>
</div>
<a id="a8f05611324090cd538b14e0728cf185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05611324090cd538b14e0728cf185a">&#9670;&nbsp;</a></span>box_tuple_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_tuple_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check tuple data correspondence to the space format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Tuple to validate. </td></tr>
    <tr><td class="paramname">format</td><td>Format to which the tuple must match.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The tuple is valid. </td></tr>
    <tr><td class="paramname">-1</td><td>The tuple is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf5cc88ba87d8e5afe81604385609191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5cc88ba87d8e5afe81604385609191">&#9670;&nbsp;</a></span>box_txn_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* box_txn_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory on txn memory pool. </p>
<p>The memory is automatically deallocated when the transaction is committed or rolled back.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88346fff21ac55ecf5e8e7e8750093ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88346fff21ac55ecf5e8e7e8750093ce">&#9670;&nbsp;</a></span>box_txn_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin a transaction in the current fiber. </p>
<p>A transaction is attached to caller fiber, therefore one fiber can have only one active transaction.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">-1</td><td>- failed, perhaps a transaction has already been started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a541c69864552de6ae21c4edce2bbf949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541c69864552de6ae21c4edce2bbf949">&#9670;&nbsp;</a></span>box_txn_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_commit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commit the current transaction. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- success </td></tr>
    <tr><td class="paramname">-1</td><td>- failed, perhaps a disk write failure. started </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94bf484fef1147b9e53323cd5082b505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bf484fef1147b9e53323cd5082b505">&#9670;&nbsp;</a></span>box_txn_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t box_txn_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Transaction id - a non-persistent unique identifier of the current transaction. -1 if there is no current transaction. </p>

</div>
</div>
<a id="ab434c9ba079ac5578be4699220b1860f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab434c9ba079ac5578be4699220b1860f">&#9670;&nbsp;</a></span>box_txn_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_isolation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get isolation level of current transaction, one of enum txn_isolation_level values (but cannot be TXN_ISOLATION_DEFAULT (which is zero) by design). </p>
<p>-1 if there is no current transaction. </p>

</div>
</div>
<a id="a59188d28eb2a8cd892d48f74041fec45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59188d28eb2a8cd892d48f74041fec45">&#9670;&nbsp;</a></span>box_txn_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_rollback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rollback the current transaction. </p>
<p>May fail if called from a nested statement. </p>

</div>
</div>
<a id="a8a24686e9b0f80d53ded039aa69dfd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a24686e9b0f80d53ded039aa69dfd33">&#9670;&nbsp;</a></span>box_txn_set_isolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_set_isolation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an isolation <em>level</em> for a transaction. </p>
<p>Must be called before the first DML. The level must be of enun txn_isolation_level values. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if success </td></tr>
    <tr><td class="paramname">-1</td><td>if failed, diag is set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e930976f6e8e73e213f701c3761fce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e930976f6e8e73e213f701c3761fce4">&#9670;&nbsp;</a></span>box_txn_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_txn_set_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>timeout</em> for transaction, when it expires, transaction will be rolled back. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if success </td></tr>
    <tr><td class="paramname">-1</td><td>if timeout is less than or equal to 0, there is no current transaction or rollback timer for current transaction is already started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9badf4d5cc54e424a157439fcb58b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9badf4d5cc54e424a157439fcb58b96a">&#9670;&nbsp;</a></span>box_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_update </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an UPDATE request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>encoded key in MsgPack Array format ([part1, part2, ...]). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_end</td><td>the end of encoded <em>key</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops</td><td>encoded operations in MsgPack Array format, e.g. [ [ '=', fieldno, value ], ['!', 2, 'xxx'] ] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops_end</td><td>the end of encoded <em>ops</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_base</td><td>0 if fieldnos in update operations are zero-based indexed (like C) or 1 if for one-based indexed field ids (like Lua). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:update(key, ops) </div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="module_8h.html#a268a03389cd856206f0ddfc90f3cbf84" title="Execute an UPSERT request.">box_upsert()</a> </dd></dl>

</div>
</div>
<a id="a268a03389cd856206f0ddfc90f3cbf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268a03389cd856206f0ddfc90f3cbf84">&#9670;&nbsp;</a></span>box_upsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int box_upsert </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tuple_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an UPSERT request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">space_id</td><td>space identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_id</td><td>index identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops</td><td>encoded operations in MsgPack Array format, e.g. [ [ '=', fieldno, value ], ['!', 2, 'xxx'] ] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ops_end</td><td>the end of encoded <em>ops</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple</td><td>encoded tuple in MsgPack Array format ([ field1, field2, ...]) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuple_end</td><td>end of <em>tuple</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_base</td><td>0 if fieldnos in update operations are zero-based indexed (like C) or 1 if for one-based indexed field ids (like Lua). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a new tuple. Can be set to NULL to discard result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error (check <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><div class="fragment"><div class="line">box.space[space_id].index[index_id]:update(key, ops) </div>
</div><!-- fragment --> </dd>
<dd>
<a class="el" href="module_8h.html#a9badf4d5cc54e424a157439fcb58b96a" title="Execute an UPDATE request.">box_update()</a> </dd></dl>

</div>
</div>
<a id="a35900530fb24b7e882c37016b01603aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35900530fb24b7e882c37016b01603aa">&#9670;&nbsp;</a></span>clock_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_monotonic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A nonsettable system-wide clock that represents monotonic time. </p>
<p>See clock_gettime(2), CLOCK_MONOTONIC. </p>

</div>
</div>
<a id="a7ecf77597c056216e310c34951bf21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecf77597c056216e310c34951bf21b9">&#9670;&nbsp;</a></span>clock_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A clock that measures CPU time consumed by this process (by all threads in the process). </p>
<p>See clock_gettime(2), CLOCK_PROCESS_CPUTIME_ID. </p>

</div>
</div>
<a id="a82b915cd0f2fbf8da0031594334d1161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b915cd0f2fbf8da0031594334d1161">&#9670;&nbsp;</a></span>clock_realtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_realtime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>A settable system-wide clock that measures real (i.e., wall-clock) time.</p>
<p>See clock_gettime(2), CLOCK_REALTIME. </p>

</div>
</div>
<a id="aac6c5ad4ed25168dd171bd2f9d112d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6c5ad4ed25168dd171bd2f9d112d0d">&#9670;&nbsp;</a></span>clock_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clock_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A clock that measures CPU time consumed by this thread. </p>
<p>See clock_gettime(2), CLOCK_THREAD_CPUTIME_ID. </p>

</div>
</div>
<a id="af9433c7d42d7747f1f69b79a0d98df13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9433c7d42d7747f1f69b79a0d98df13">&#9670;&nbsp;</a></span>coio_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t coio_call </td>
          <td>(</td>
          <td class="paramtype">ssize_t(*)(va_list)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Create new eio task with specified function and arguments. Yield and wait until the task is complete.</p>
<p>This function doesn't throw exceptions to avoid double error checking: in most cases it's also necessary to check the return value of the called function and perform necessary actions. If func sets errno, the errno is preserved across the call.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>and errno = ENOMEM if failed to create a task </td></tr>
    <tr><td class="paramname">the</td><td>function return (errno is preserved).</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> ssize_t openfile_cb(va_list ap)</div>
<div class="line">{</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">char</span> *filename = va_arg(ap);</div>
<div class="line">         <span class="keywordtype">int</span> flags = va_arg(ap);</div>
<div class="line">         <span class="keywordflow">return</span> open(filename, flags);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a>(openfile_cb, <span class="stringliteral">&quot;/tmp/file&quot;</span>, 0) == -1)</div>
<div class="line">   <span class="comment">// handle errors.</span></div>
<div class="line">...</div>
<div class="ttc" id="amodule_8h_html_af9433c7d42d7747f1f69b79a0d98df13"><div class="ttname"><a href="module_8h.html#af9433c7d42d7747f1f69b79a0d98df13">coio_call</a></div><div class="ttdeci">ssize_t coio_call(ssize_t(*func)(va_list),...)</div><div class="ttdoc">public</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a832b67e03175570d9f6fa17ffd77bf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832b67e03175570d9f6fa17ffd77bf83">&#9670;&nbsp;</a></span>coio_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coio_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber-friendly version of getaddrinfo(3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>host name, i.e. "tarantool.org" </td></tr>
    <tr><td class="paramname">port</td><td>service name, i.e. "80" or "http" </td></tr>
    <tr><td class="paramname">hints</td><td>hints, see getaddrinfo(3) </td></tr>
    <tr><td class="paramname">res[out]</td><td>result, see getaddrinfo(3) </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success, please free <em>res</em> using freeaddrinfo(3). </td></tr>
    <tr><td class="paramname">-1</td><td>on error, check diag. Please note that the return value is not compatible with getaddrinfo(3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getaddrinfo() </dd></dl>

</div>
</div>
<a id="ab9c521a569fd78b25f355f3b7525ba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c521a569fd78b25f355f3b7525ba9a">&#9670;&nbsp;</a></span>coio_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coio_wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until READ or WRITE event on socket (<em>fd</em>). </p>
<p>Yields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>- non-blocking socket file description </td></tr>
    <tr><td class="paramname">events</td><td>- requested events to wait. Combination of TNT_IO_READ | TNT_IO_WRITE bit flags. </td></tr>
    <tr><td class="paramname">timeout</td><td>- timeout in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- timeout </td></tr>
    <tr><td class="paramname">&gt;0</td><td>- returned events. Combination of TNT_IO_READ | TNT_IO_WRITE bit flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4003e7d28985f1573cf3faf8b4d38ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4003e7d28985f1573cf3faf8b4d38ee">&#9670;&nbsp;</a></span>fiber_attr_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_attr_delete </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the fiber_attr and free all allocated resources. </p>
<p>This is safe when fibers created with this attribute still exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attr</td><td>fiber attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad628f573827cf2393f0849c194719a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad628f573827cf2393f0849c194719a94">&#9670;&nbsp;</a></span>fiber_attr_getstacksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fiber_attr_getstacksize </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stack size from the fiber attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attribute</td><td>fiber attribute container or NULL for default </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">stack</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a615728b106aa274514dea63a9a693fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615728b106aa274514dea63a9a693fd1">&#9670;&nbsp;</a></span>fiber_attr_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber_attr* fiber_attr_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber attribute container and initialize it with default parameters. </p>
<p>Can be used for many fibers creation, corresponding fibers will not take ownership. </p>

</div>
</div>
<a id="a4f42c1a444922edf2163806c5433ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f42c1a444922edf2163806c5433ae1a">&#9670;&nbsp;</a></span>fiber_attr_setstacksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_attr_setstacksize </td>
          <td>(</td>
          <td class="paramtype">struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stack size for the fiber attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fiber_attribute</td><td>fiber attribute container </td></tr>
    <tr><td class="paramname">stacksize</td><td>stack size for new fibers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a5b700b2122f08e6bc1298ac7eb0435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5b700b2122f08e6bc1298ac7eb0435">&#9670;&nbsp;</a></span>fiber_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cancel </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the subject fiber. </p>
<p>Cancellation is asynchronous. Use <a class="el" href="module_8h.html#a58ac22e89f3fdab0556cc5f6922f0f59" title="Wait until the fiber is dead and then move its execution status to the caller.">fiber_join()</a> to wait for the cancellation to complete.</p>
<p>After <a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435" title="Cancel the subject fiber.">fiber_cancel()</a> is called, the fiber may or may not check whether it was cancelled. If the fiber does not check it, it cannot ever be cancelled. However, as long as most of the cooperative code calls fiber_testcancel(), most of the fibers are cancellable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be cancelled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1c835fac5180f57e01c388a95440d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c835fac5180f57e01c388a95440d5">&#9670;&nbsp;</a></span>fiber_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fiber_clock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as double (cheap). </p>
<p>Uses monotonic clock. </p>

</div>
</div>
<a id="a8ed4eb4281eaa96a74c6e052995af645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed4eb4281eaa96a74c6e052995af645">&#9670;&nbsp;</a></span>fiber_clock64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fiber_clock64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as 64-bit int. </p>
<p>Uses monotonic clock. </p>

</div>
</div>
<a id="abbca6fff4cd2ccf2b65528ea5e1e1e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbca6fff4cd2ccf2b65528ea5e1e1e39">&#9670;&nbsp;</a></span>fiber_cond_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake up all fibers waiting for the cond. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64787aacecdc620e9b7e402babf9ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64787aacecdc620e9b7e402babf9ae1e">&#9670;&nbsp;</a></span>fiber_cond_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_delete </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the fiber cond object. </p>
<p>Behaviour is undefined if there are fiber waiting for the cond. </p>

</div>
</div>
<a id="a670f12ab6752093a3e2ae0ff48ccd491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670f12ab6752093a3e2ae0ff48ccd491">&#9670;&nbsp;</a></span>fiber_cond_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber_cond* fiber_cond_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Instantiate a new fiber cond object. </p>

</div>
</div>
<a id="a3f13caca027d090cc02574e333c78f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f13caca027d090cc02574e333c78f3c">&#9670;&nbsp;</a></span>fiber_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_cond_signal </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake one fiber waiting for the cond. </p>
<p>Does nothing if no one is waiting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd72e262e9e59a14c1337bc0fa2447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd72e262e9e59a14c1337bc0fa2447c">&#9670;&nbsp;</a></span>fiber_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_cond_wait </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for <a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a9e7882234efd30663364ded133ab3fad" title="Suspend the execution of the current fiber (i.e.">fiber_cond_wait_timeout()</a> </dd></dl>

</div>
</div>
<a id="a9e7882234efd30663364ded133ab3fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7882234efd30663364ded133ab3fad">&#9670;&nbsp;</a></span>fiber_cond_wait_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_cond_wait_timeout </td>
          <td>(</td>
          <td class="paramtype">struct fiber_cond *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the execution of the current fiber (i.e. </p>
<p>yield) until <a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c" title="Wake one fiber waiting for the cond.">fiber_cond_signal()</a> is called. Like pthread_cond, fiber_cond can issue spurious wake ups caused by explicit <a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40" title="Interrupt a synchronous wait of a fiber.">fiber_wakeup()</a> or <a class="el" href="module_8h.html#a9a5b700b2122f08e6bc1298ac7eb0435" title="Cancel the subject fiber.">fiber_cancel()</a> calls. It is highly recommended to wrap calls to this function into a loop and check an actual predicate and fiber_testcancel() on every iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on <a class="el" href="module_8h.html#a3f13caca027d090cc02574e333c78f3c" title="Wake one fiber waiting for the cond.">fiber_cond_signal()</a> call or a spurious wake up </td></tr>
    <tr><td class="paramname">-1</td><td>on timeout or fiber cancellation, diag is set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a292f6964c2f9336780175623c94f0be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292f6964c2f9336780175623c94f0be2">&#9670;&nbsp;</a></span>fiber_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fiber_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context for the fiber which was set via the fiber_set_ctx function. </p>
<p>Can be used to avoid calling fiber_start which means no yields.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">context</td><td>for the fiber function set by fiber_set_ctx function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ac596a2d875dcfa8477bbfc1ccc7b809d" title="Set a pointer to context for the fiber.">fiber_set_ctx</a> </dd></dl>

</div>
</div>
<a id="a58ac22e89f3fdab0556cc5f6922f0f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ac22e89f3fdab0556cc5f6922f0f59">&#9670;&nbsp;</a></span>fiber_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_join </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the fiber is dead and then move its execution status to the caller. </p>
<p>The fiber must not be detached (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208" title="Set fiber to be joinable (false by default).">fiber_set_joinable()</a>). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FIBER_IS_JOINABLE flag is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fiber function ret code </dd></dl>

</div>
</div>
<a id="a676e8a263a2592320b7260095f5c10f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676e8a263a2592320b7260095f5c10f3">&#9670;&nbsp;</a></span>fiber_join_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fiber_join_timeout </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the fiber is dead or timeout exceeded. </p>
<p>In case timeout == TIMEOUT_INFINITY, this function same as fiber_join function. Return fiber execution status to the caller or -1 if timeout exceeded and set diag. The fiber must not be detached (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a8ee4e98a4e9c2239b5d7eb98c2b0b208" title="Set fiber to be joinable (false by default).">fiber_set_joinable()</a>). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FIBER_IS_JOINABLE flag is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
    <tr><td class="paramname">timeout</td><td>time during which we wait for the fiber completion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fiber function ret code or -1 in case if timeout exceeded </dd></dl>

</div>
</div>
<a id="ac0d955b4ac367ab3b95c6c0d0df31050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d955b4ac367ab3b95c6c0d0df31050">&#9670;&nbsp;</a></span>fiber_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber* fiber_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber. </p>
<p>Takes a fiber from fiber cache, if it's not empty. Can fail only if there is not enough memory for the fiber structure or fiber stack.</p>
<p>The created fiber automatically returns itself to the fiber cache when its "main" function completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>string with fiber name </td></tr>
    <tr><td class="paramname">fiber_func</td><td>func for run inside fiber</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2" title="Start execution of created fiber.">fiber_start</a> </dd></dl>

</div>
</div>
<a id="a8e8dbdb4656ce6c89ea1e3215c0d6adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8dbdb4656ce6c89ea1e3215c0d6adf">&#9670;&nbsp;</a></span>fiber_new_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fiber* fiber_new_ex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fiber_attr *&#160;</td>
          <td class="paramname"><em>fiber_attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a94849dd4556ce6560a898d5af2d20779">fiber_func</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new fiber with defined attributes. </p>
<p>Can fail only if there is not enough memory for the fiber structure or fiber stack.</p>
<p>The created fiber automatically returns itself to the fiber cache if has default stack size when its "main" function completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>string with fiber name </td></tr>
    <tr><td class="paramname">fiber_attr</td><td>fiber attributes </td></tr>
    <tr><td class="paramname">fiber_func</td><td>func for run inside fiber</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#abca18eb68ebf89507d4cf5eb3c402cb2" title="Start execution of created fiber.">fiber_start</a> </dd></dl>

</div>
</div>
<a id="a4078cbddc22b0ed941548f86672224d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4078cbddc22b0ed941548f86672224d9">&#9670;&nbsp;</a></span>fiber_set_cancellable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fiber_set_cancellable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yesno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

</div>
</div>
<a id="ac596a2d875dcfa8477bbfc1ccc7b809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac596a2d875dcfa8477bbfc1ccc7b809d">&#9670;&nbsp;</a></span>fiber_set_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_set_ctx </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a pointer to context for the fiber. </p>
<p>Can be used to avoid calling fiber_start which means no yields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to set the context for </td></tr>
    <tr><td class="paramname">f_arg</td><td>context for the fiber function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee4e98a4e9c2239b5d7eb98c2b0b208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee4e98a4e9c2239b5d7eb98c2b0b208">&#9670;&nbsp;</a></span>fiber_set_joinable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_set_joinable </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>fiber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yesno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fiber to be joinable (false by default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yesno</td><td>status to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ab0816e3ddf7e11b448926569e6bc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab0816e3ddf7e11b448926569e6bc49">&#9670;&nbsp;</a></span>fiber_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_sleep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current fiber to sleep for at least 's' seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>time to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a cancellation point (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a972d46a2ac9d787bc69b61ce09938587" title="Check current fiber for cancellation (it must be checked manually).">fiber_is_cancelled</a>) </dd></dl>

</div>
</div>
<a id="abca18eb68ebf89507d4cf5eb3c402cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca18eb68ebf89507d4cf5eb3c402cb2">&#9670;&nbsp;</a></span>fiber_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_start </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start execution of created fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callee</td><td>fiber to start </td></tr>
    <tr><td class="paramname">...</td><td>arguments to start the fiber with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ac0d955b4ac367ab3b95c6c0d0df31050" title="Create a new fiber.">fiber_new</a> </dd></dl>

</div>
</div>
<a id="a077a6068c998d2e548168be5e1a6008f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077a6068c998d2e548168be5e1a6008f">&#9670;&nbsp;</a></span>fiber_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fiber_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as double (cheap). </p>
<p>Uses real time clock. </p>

</div>
</div>
<a id="ae1e9fb25b47b6090a587c92aaf536aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e9fb25b47b6090a587c92aaf536aed">&#9670;&nbsp;</a></span>fiber_time64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t fiber_time64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report loop begin time as 64-bit int. </p>
<p>Uses real time clock. </p>

</div>
</div>
<a id="a661de7f72aa265ff6ffcb8b3acfafe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661de7f72aa265ff6ffcb8b3acfafe40">&#9670;&nbsp;</a></span>fiber_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_wakeup </td>
          <td>(</td>
          <td class="paramtype">struct fiber *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt a synchronous wait of a fiber. </p>
<p>Nop for the currently running fiber.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>fiber to be woken up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5beb40f119b9400bb57b81820b24ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5beb40f119b9400bb57b81820b24ff">&#9670;&nbsp;</a></span>fiber_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fiber_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return control to another fiber and wait until it'll be woken. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a661de7f72aa265ff6ffcb8b3acfafe40" title="Interrupt a synchronous wait of a fiber.">fiber_wakeup</a> </dd></dl>

</div>
</div>
<a id="a498681c0c56f0aebe938004ab8947b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498681c0c56f0aebe938004ab8947b0f">&#9670;&nbsp;</a></span>luaL_cdef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_cdef </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctypename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare symbols for FFI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypename</td><td>C definitions, e.g "struct stat" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>ffi.cdef(def) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">LUA_ERRRUN,LUA_ERRMEM,LUA_ERRERR</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b8d32a69bc903b97ee3379b34fb2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b8d32a69bc903b97ee3379b34fb2af">&#9670;&nbsp;</a></span>luaL_checkcdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* luaL_checkcdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ctypeid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the function argument idx is a cdata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>stack index </td></tr>
    <tr><td class="paramname">ctypeid</td><td>FFI's CTypeID of this cdata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a6016a29a15957c333f568d4059923fad" title="Push cdata of given ctypeid onto the stack.">luaL_pushcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>memory associated with this cdata </dd></dl>

</div>
</div>
<a id="a159fe92272b876c3fa7b130f026705bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159fe92272b876c3fa7b130f026705bd">&#9670;&nbsp;</a></span>luaL_checkint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t luaL_checkint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a int64 or a convertible string and returns this number. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument can't be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5247fbc8230e2f49464e25e27b87d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5247fbc8230e2f49464e25e27b87d35">&#9670;&nbsp;</a></span>luaL_checkuint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t luaL_checkuint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a uint64 or a convertible string and returns this number. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument can't be converted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d1f07b7fe39b8bd9b7a87f7c84d5d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1f07b7fe39b8bd9b7a87f7c84d5d73">&#9670;&nbsp;</a></span>luaL_ctypeid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t luaL_ctypeid </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctypename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CTypeID (FFI) of given DATA type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypename</td><td> type name as string (e.g. "struct request" or "uint32_t") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a6016a29a15957c333f568d4059923fad" title="Push cdata of given ctypeid onto the stack.">luaL_pushcdata</a> </dd>
<dd>
<a class="el" href="module_8h.html#a09b8d32a69bc903b97ee3379b34fb2af" title="Checks whether the function argument idx is a cdata.">luaL_checkcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CTypeID </dd></dl>

</div>
</div>
<a id="a08ca887563c2bcd2e17ad199dac627b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ca887563c2bcd2e17ad199dac627b2">&#9670;&nbsp;</a></span>luaL_iscallable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_iscallable </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a Lua object is a function or has metatable/metatype with a __call field. </p>
<p>Note: It does not check type of __call metatable/metatype field. </p>

</div>
</div>
<a id="acc9bcfc8296607ac6cbfdd9d44cd7451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9bcfc8296607ac6cbfdd9d44cd7451">&#9670;&nbsp;</a></span>luaL_iscdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaL_iscdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Checks whether a value on the Lua stack is a cdata.</p>
<p>Unlike &lt;luaL_checkcdata&gt;() this function does not raise an error. It is useful to raise a domain specific error.</p>
<p>Lua API and module API don't expose LUA_TCDATA constant. We have no guarantee that this constant will remain the same in future LuaJIT versions. So this function should be used in modules instead of <code>lua_type(L, idx) == LUA_TCDATA</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua state. </td></tr>
    <tr><td class="paramname">idx</td><td>Acceptable index on the Lua stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>If the value at the given index is a cdata. </td></tr>
    <tr><td class="paramname">0</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6016a29a15957c333f568d4059923fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6016a29a15957c333f568d4059923fad">&#9670;&nbsp;</a></span>luaL_pushcdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* luaL_pushcdata </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctypeid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push cdata of given <em>ctypeid</em> onto the stack. </p>
<p>CTypeID must be used from FFI at least once. Allocated memory returned uninitialized. Only numbers and pointers are supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">ctypeid</td><td>FFI's CTypeID of this cdata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a09b8d32a69bc903b97ee3379b34fb2af" title="Checks whether the function argument idx is a cdata.">luaL_checkcdata</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>memory associated with this cdata </dd></dl>

</div>
</div>
<a id="a1dcccfbc48bac7e8cf4802e839c2f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcccfbc48bac7e8cf4802e839c2f198">&#9670;&nbsp;</a></span>luaL_pushint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_pushint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push int64_t onto the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>is a Lua State </td></tr>
    <tr><td class="paramname">val</td><td>is a value to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6439d4dd158b27d2567e1bfd6243e084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6439d4dd158b27d2567e1bfd6243e084">&#9670;&nbsp;</a></span>luaL_pushuint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_pushuint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Push uint64_t onto the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>is a Lua State </td></tr>
    <tr><td class="paramname">val</td><td>is a value to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa62fc5e919f74956a06a9b40fb24f691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62fc5e919f74956a06a9b40fb24f691">&#9670;&nbsp;</a></span>luaL_setcdatagc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaL_setcdatagc </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets finalizer function on a cdata object. </p>
<p>Equivalent to call ffi.gc(obj, function). Finalizer function must be on the top of the stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31727f17a0a09ff7fb92ac3d2eaa2dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31727f17a0a09ff7fb92ac3d2eaa2dce">&#9670;&nbsp;</a></span>luaL_toint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t luaL_toint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a int64 or a convertible string and returns this number. </p>
<dl class="section return"><dt>Returns</dt><dd>the converted number or 0 of argument can't be converted. </dd></dl>

</div>
</div>
<a id="a20e035148bc707412c054291f9b51855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e035148bc707412c054291f9b51855">&#9670;&nbsp;</a></span>luaL_touint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t luaL_touint64 </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the argument idx is a uint64 or a convertible string and returns this number. </p>
<dl class="section return"><dt>Returns</dt><dd>the converted number or 0 of argument can't be converted. </dd></dl>

</div>
</div>
<a id="a4c95f4e99d2f7b5be64ca3918fdc4ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95f4e99d2f7b5be64ca3918fdc4ccf">&#9670;&nbsp;</a></span>luaT_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_call </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nreturns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lua_call(), but with the proper support of Tarantool errors. </p>
<dl class="section see"><dt>See also</dt><dd>lua_call() </dd></dl>

</div>
</div>
<a id="a6f106407ff1e6560bd8cba9b4698040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f106407ff1e6560bd8cba9b4698040d">&#9670;&nbsp;</a></span>luaT_checktuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a>* luaT_checktuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Checks whether the argument idx is a tuple and returns it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>the stack index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>argument is tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">error</td><td>if the argument is not a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08aafb8aaa59640f2b7130e9281e53ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aafb8aaa59640f2b7130e9281e53ec">&#9670;&nbsp;</a></span>luaT_cpcall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_cpcall </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lua_CFunction&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lua_cpcall(), but with the proper support of Tarantool errors. </p>
<dl class="section see"><dt>See also</dt><dd>lua_cpcall() </dd></dl>

</div>
</div>
<a id="ae5e643c0eff90628dd8cb09ddd8dfc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e643c0eff90628dd8cb09ddd8dfc68">&#9670;&nbsp;</a></span>luaT_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_error </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-throws the last Tarantool error as a Lua object. </p>
<dl class="section see"><dt>See also</dt><dd>lua_error() </dd>
<dd>
<a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a> </dd></dl>

</div>
</div>
<a id="a53f6c9c6047142026a2e3727e4e43a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f6c9c6047142026a2e3727e4e43a24">&#9670;&nbsp;</a></span>luaT_isdecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* luaT_isdecimal </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a value on the Lua stack is a decimal. </p>
<p>Returns a pointer to the decimal on a successful check, NULL otherwise. </p>

</div>
</div>
<a id="ab1dce37206b2951e42b76a9ce704f9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dce37206b2951e42b76a9ce704f9f2">&#9670;&nbsp;</a></span>luaT_istuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a>* luaT_istuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether argument idx is a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
    <tr><td class="paramname">idx</td><td>the stack index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>argument is tuple </td></tr>
    <tr><td class="paramname">NULL</td><td>argument is not tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7062a07e1c119c2c50b65afd23d0ce40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7062a07e1c119c2c50b65afd23d0ce40">&#9670;&nbsp;</a></span>luaT_newdecimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a90d26cf0c54dfa5e878e95ca0f73202a">box_decimal_t</a>* luaT_newdecimal </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>public </p>
<p>Allocate a new decimal on the Lua stack and return a pointer to it. </p>

</div>
</div>
<a id="aa1740670301221218d3780f2a4df33c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1740670301221218d3780f2a4df33c6">&#9670;&nbsp;</a></span>luaT_push_nil_and_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int luaT_push_nil_and_error </td>
          <td>(</td>
          <td class="paramtype">lua_State *&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return nil as the first return value and an error as the second. </p>
<p>The error is received using <a class="el" href="module_8h.html#af8f82c313ba49fc97782663ffba71f58" title="Get the information about the last API call error.">box_error_last()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddb8bf7e1f41149fe67352de0f276d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddb8bf7e1f41149fe67352de0f276d4">&#9670;&nbsp;</a></span>luaT_pushtuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void luaT_pushtuple </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a tuple onto the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua State </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#ab1dce37206b2951e42b76a9ce704f9f2" title="Checks whether argument idx is a tuple.">luaT_istuple</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">on</td><td>OOM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac572fcff70dbc1c4c33339f1db082315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac572fcff70dbc1c4c33339f1db082315">&#9670;&nbsp;</a></span>luaT_toibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#ae1cb16b1acef0772ea4192316f742aa8">box_ibuf_t</a>* luaT_toibuf </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a value on <em>L</em> stack by index <em>idx</em> is an ibuf object. </p>
<p>Both 'struct ibuf' and 'struct ibuf *' are accepted. Returns NULL, if can't convert - not an ibuf object. </p>

</div>
</div>
<a id="ab57d953ad39d6f1e0704a6c536b7ab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57d953ad39d6f1e0704a6c536b7ab60">&#9670;&nbsp;</a></span>luaT_tuple_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* luaT_tuple_encode </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tuple_len_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a table or a tuple on the Lua stack as an MsgPack array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Lua state. </td></tr>
    <tr><td class="paramname">idx</td><td>Acceptable index on the Lua stack. </td></tr>
    <tr><td class="paramname">tuple_len_ptr</td><td>Where to store tuple data size in bytes (or NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>The storage for data is allocated on the box region. A caller should call &lt;box_region_truncate&gt;() to release the data.</p>
<p>In case of an error set a diag and return NULL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a2a9365f857b2bb2b02d03b0c075fd793" title="Create a new tuple with specific format from a Lua table or a tuple.">luaT_tuple_new()</a> </dd></dl>

</div>
</div>
<a id="a2a9365f857b2bb2b02d03b0c075fd793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9365f857b2bb2b02d03b0c075fd793">&#9670;&nbsp;</a></span>luaT_tuple_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="module_8h.html#a880c3e1e8e63b9a12353853fb6aefa3f">box_tuple_t</a>* luaT_tuple_new </td>
          <td>(</td>
          <td class="paramtype">struct lua_State *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="module_8h.html#ab230ff08fb24d580407126fc905cc271">box_tuple_format_t</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new tuple with specific format from a Lua table or a tuple. </p>
<p>The new tuple is referenced in the same way as one created by &lt;box_tuple_new&gt;(). There are two possible usage scenarios:</p>
<ol type="1">
<li>A short living tuple may not be referenced explicitly and will be collected automatically at the next module API call that yields or returns a tuple.</li>
<li>A long living tuple must be referenced using &lt;box_tuple_ref&gt;() and unreferenced then with &lt;box_tuple_unref&gt;().</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="module_8h.html#a2211f2682d19f564c55f2888e35d6430" title="Increase the reference counter of tuple.">box_tuple_ref()</a></dd></dl>
<p>In case of an error set a diag and return NULL. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 20 2023 16:54:59 for Tarantool by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
