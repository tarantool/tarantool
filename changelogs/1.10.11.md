Date: 2021-08-19
Tag: 1.10.11

## Overview

1.10.11 is the next stable release in the [long-term support (LTS)
version][release_policy][release_policy] 1.10.x release series.

The label "stable" means there are 1.10.x-based applications running in
production for quite a while without known crashes, incorrect results or
other showstopper bugs.

This release introduces 1 improvements and resolves roughly 14
issues since the 1.10.10 version.

[release_policy]: https://www.tarantool.io/en/doc/1.10/dev_guide/release_management/#release-policy
[issues]: https://github.com/tarantool/tarantool/issues

## Compatibility

Tarantool 1.10.11 is backward compatible with Tarantool 1.9.x in binary data
layout, client-server protocol and replication protocol.

Please [upgrade][upgrade] using the `box.schema.upgrade()` procedure to unlock
all the new features of the 1.10.x series.

[upgrade]: https://www.tarantool.io/en/doc/1.10/book/admin/upgrades/

## Functionality added or changed

### Build

* Support fedora-34 build. (gh-6074)
 * Stop support fedora-28 and fedora-29.

## Bugs fixed

### Core


* **[Breaking change]** `fiber.wakeup()` in Lua and `fiber_wakeup()` in C became
  NOP on the currently running fiber. Previously they allowed to "ignore" the
  next yield or sleep leading to unexpected spurious wakeups. Could lead to a
  crash (in debug build) or undefined behaviour (in release build) if called
  right before `fiber.create()` in Lua or `fiber_start()` in C (gh-6043).

  There was a single usecase for that - reschedule in the same event loop
  iteration which is not the same as `fiber.sleep(0)` in Lua and
  `fiber_sleep(0)` in C. Could be done in C like that:
  ```C
  fiber_wakeup(fiber_self());
  fiber_yield();
  ```
  and in Lua like that:
  ```Lua
  fiber.self():wakeup()
  fiber.yield()
  ```
  Now to get the same effect in C use `fiber_reschedule()`. In Lua it is now
  simply impossible to reschedule the current fiber in the same event loop
  iteration directly. But still can reschedule self through a second fiber like
  this (**never use it, please**):
  ```Lua
  local self = fiber.self()
  fiber.new(function() self:wakeup() end)
  fiber.sleep(0)
  ```

* Fixed memory leak on each `box.on_commit()` and `box.on_rollback()` (gh-6025).
* Fixed invalid results produced by `json` module's `encode` function when it
  was used from Lua's garbage collector. For instance, in functions used as
  `ffi.gc()` (gh-6050).
* Fixed a bug when iterators became invalid (up to crash) after schema change (gh-6147).
* Fix crash in case of reloading a compiled module when the
  new module lacks some of functions which were present in the
  former code. In turn this event triggers a fallback procedure
  where we restore old functions but instead of restoring each
  function we process a sole entry only leading to the crash
  later when these restored functions are called (gh-5968).
* Fixed console client connection breakage if request times out (gh-6249).
* Added missing broadcast to net.box.future:discard() so that now fibers
  waiting for a request result are woken up when the request is discarded
  (gh-6250).

### Vinyl

* Fix possible keys divergence during secondary index build which might
  lead to missing tuples in it (gh-6045).
* Fix crash which may occur while switching read_only mode due to duplicating
  transaction in tx writer list (gh-5934).
* Fixed a race between Vinyl garbage collection and compaction resulting in
  broken vylog and recovery (gh-5436).

### Replication

* Fix replication stopping occasionally with `ER_INVALID_MSGPACK` when replica
  is under high load (gh-4040).

### LuaJIT

* Fixed optimization for single-char strings in `IR_BUFPUT` assembly routine.
* Fixed slots alignment in `lj-stack` command output when `LJ_GC64` is enabled
  (gh-5876).
* Fixed dummy frame unwinding in `lj-stack` command.
* Fixed detection of inconsistent renames even in the presence of sunk values
  (gh-4252, gh-5049, gh-5118).
