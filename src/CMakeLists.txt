#
# Set compile flags for entire src/ directory
#
enable_tnt_compile_flags()

include_directories(${LIBEV_INCLUDE_DIR})
include_directories(${LIBEIO_INCLUDE_DIR})
include_directories(${LIBCORO_INCLUDE_DIR})
include_directories(${LUAJIT_INCLUDE_DIRS})
include_directories(${READLINE_INCLUDE_DIRS})
include_directories(${LIBYAML_INCLUDE_DIRS})
include_directories(${MSGPUCK_INCLUDE_DIRS})
include_directories(${CURL_INCLUDE_DIRS})
include_directories(${ICU_INCLUDE_DIRS})
include_directories(${ICONV_INCLUDE_DIRS})

set(LIBUTIL_FREEBSD_SRC ${CMAKE_SOURCE_DIR}/third_party/libutil_freebsd)
include_directories(${LIBUTIL_FREEBSD_SRC})

# Compile src/lua/*.lua files into src/lua/*.lua.c sources
set(lua_sources)
lua_source(lua_sources lua/init.lua)
lua_source(lua_sources lua/debug.lua)
lua_source(lua_sources lua/string.lua)
lua_source(lua_sources lua/fiber.lua)
lua_source(lua_sources lua/buffer.lua)
lua_source(lua_sources lua/uuid.lua)
lua_source(lua_sources lua/crypto.lua)
lua_source(lua_sources lua/digest.lua)
lua_source(lua_sources lua/msgpackffi.lua)
lua_source(lua_sources lua/uri.lua)
lua_source(lua_sources lua/socket.lua)
lua_source(lua_sources lua/errno.lua)
lua_source(lua_sources lua/log.lua)
lua_source(lua_sources lua/help.lua)
lua_source(lua_sources lua/help_en_US.lua)
lua_source(lua_sources lua/tap.lua)
lua_source(lua_sources lua/fio.lua)
lua_source(lua_sources lua/csv.lua)
lua_source(lua_sources lua/strict.lua)
lua_source(lua_sources lua/clock.lua)
lua_source(lua_sources lua/title.lua)
lua_source(lua_sources lua/argparse.lua)
lua_source(lua_sources lua/env.lua)
lua_source(lua_sources lua/pwd.lua)
lua_source(lua_sources lua/trigger.lua)
lua_source(lua_sources lua/table.lua)
lua_source(lua_sources ../third_party/luafun/fun.lua)
lua_source(lua_sources lua/httpc.lua)
lua_source(lua_sources lua/iconv.lua)
# LuaJIT jit.* library
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/bc.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/bcsave.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/dis_x86.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/dis_x64.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/dump.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/v.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/p.lua)
lua_source(lua_sources ${LUAJIT_SOURCE_ROOT}/src/jit/zone.lua)
lua_source(lua_sources ${LUAJIT_BINARY_ROOT}/src/jit/vmdef.lua)

add_custom_target(generate_lua_sources
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/src/box
    DEPENDS ${lua_sources})
set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${lua_sources})

add_custom_target(ragel
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    COMMAND ragel -G2 src/uri.rl -o src/uri.c)

# There is no libdl.so on FreeBSD prior to 11.2.
#
# Always links pthread and dl dynamically.
set(generic_libraries pthread)
find_library(DL_LIBRARY NAMES dl)
if(NOT "${DL_LIBRARY}" STREQUAL "DL_LIBRARY-NOTFOUND")
    set(generic_libraries ${generic_libraries} dl)
endif()

set (core_sources
     diag.c
     say.c
     memory.c
     clock.c
     fiber.c
     backtrace.cc
     cbus.c
     fiber_pool.c
     fiber_cond.c
     fiber_channel.c
     latch.c
     sio.cc
     evio.cc
     coio.cc
     coio_task.c
     coio_file.c
     coio_buf.cc
     fio.c
     cbus.c
     exception.cc
     errinj.c
     reflection.c
     assoc.c
     util.c
     random.c
     trigger.cc
     http_parser.c
     coll.c
     coll_def.c
     cord_buf.c
 )

if (TARGET_OS_NETBSD)
    # A workaround for "undefined reference to `__gcc_personality_v0'"
    # on x86_64-rumprun-netbsd-gcc
    set_source_files_properties(util.c PROPERTIES COMPILE_FLAGS
        -fno-exceptions)
endif ()

add_library(core STATIC ${core_sources})
add_dependencies(core curl)
target_link_libraries(core
    salad small uri
    ${LIBEV_LIBRARIES}
    ${LIBEIO_LIBRARIES}
    ${LIBCORO_LIBRARIES}
    ${MSGPUCK_LIBRARIES}
    ${generic_libraries})

add_library(stat STATIC rmean.c latency.c histogram.c)
target_link_libraries(stat core)

if (ENABLE_BACKTRACE AND NOT TARGET_OS_DARWIN)
    target_link_libraries(core gcc_s ${UNWIND_LIBRARIES})
endif()

if (CC_HAS_WNO_IMPLICIT_FALLTHROUGH)
    # Suppress noise warnings for autogenerated Ragel code
    set_source_files_properties(uri.c PROPERTIES COMPILE_FLAGS
        -Wno-implicit-fallthrough)
endif()
add_library(uri STATIC uri.c)

add_library(uuid STATIC tt_uuid.c)
target_link_libraries(uuid core bit)

add_library(scramble STATIC scramble.c)
target_link_libraries(scramble core misc)

add_library(crc32 STATIC
    crc32.c
    cpu_feature.c
    ${PROJECT_SOURCE_DIR}/third_party/crc32_impl.c
)

set (server_sources
     find_path.c
     curl.c
     httpc.c
     pickle.c
     cfg.c
     cpu_feature.c
     title.c
     proc_title.c
     path_lock.c
     ssl_cert_paths_discover.c
     systemd.c
     version.c
     lua/digest.c
     lua/init.c
     lua/fiber.c
     lua/fiber_cond.c
     lua/fiber_channel.c
     lua/trigger.c
     lua/msgpack.c
     lua/utils.c
     lua/serializer.c
     lua/errno.c
     lua/tnt_iconv.c
     lua/socket.c
     lua/pickle.c
     lua/fio.c
     lua/crypto.c
     lua/httpc.c
     lua/utf8.c
     ${lua_sources}
     ${PROJECT_SOURCE_DIR}/third_party/lua-yaml/lyaml.cc
     ${PROJECT_SOURCE_DIR}/third_party/lua-yaml/b64.c
     ${PROJECT_SOURCE_DIR}/third_party/lua-cjson/lua_cjson.c
     ${PROJECT_SOURCE_DIR}/third_party/lua-cjson/strbuf.c
)

set(api_headers
    ${CMAKE_BINARY_DIR}/src/trivia/config.h
    ${CMAKE_SOURCE_DIR}/src/trivia/util.h
    ${CMAKE_SOURCE_DIR}/src/say.h
    ${CMAKE_SOURCE_DIR}/src/fiber.h
    ${CMAKE_SOURCE_DIR}/src/fiber_cond.h
    ${CMAKE_SOURCE_DIR}/src/coio.h
    ${CMAKE_SOURCE_DIR}/src/coio_task.h
    ${CMAKE_SOURCE_DIR}/src/box/ibuf.h
    ${CMAKE_SOURCE_DIR}/src/lua/utils.h
    ${CMAKE_SOURCE_DIR}/src/box/txn.h
    ${CMAKE_SOURCE_DIR}/src/box/tuple.h
    ${CMAKE_SOURCE_DIR}/src/box/key_def.h
    ${CMAKE_SOURCE_DIR}/src/box/field_def.h
    ${CMAKE_SOURCE_DIR}/src/box/tuple_format.h
    ${CMAKE_SOURCE_DIR}/src/box/tuple_extract_key.h
    ${CMAKE_SOURCE_DIR}/src/box/schema_def.h
    ${CMAKE_SOURCE_DIR}/src/box/box.h
    ${CMAKE_SOURCE_DIR}/src/box/index.h
    ${CMAKE_SOURCE_DIR}/src/box/iterator_type.h
    ${CMAKE_SOURCE_DIR}/src/box/error.h
    ${CMAKE_SOURCE_DIR}/src/box/lua/call.h
    ${CMAKE_SOURCE_DIR}/src/box/lua/tuple.h
    ${CMAKE_SOURCE_DIR}/src/latch.h
    ${CMAKE_SOURCE_DIR}/src/clock.h
)
rebuild_module_api(${api_headers})

if (NOT TARGET_OS_DEBIAN_FREEBSD)
    if (TARGET_OS_FREEBSD)
        set_source_files_properties(
        ${PROJECT_SOURCE_DIR}/src/proc_title.c
        PROPERTIES COMPILE_FLAGS "-DHAVE_SETPROCTITLE")
    endif()
endif()

set_source_files_compile_flags(${server_sources})
add_library(server STATIC ${server_sources})
add_dependencies(server build_bundled_libs)
target_link_libraries(server core bit uri uuid ${ICU_LIBRARIES} crc32)

# Rule of thumb: if exporting a symbol from a static library, list the
# library here.
set (reexport_libraries server core misc bitset csv
     ${LUAJIT_LIBRARIES} ${MSGPUCK_LIBRARIES} ${ICU_LIBRARIES} ${CURL_LIBRARIES})

set (common_libraries
    ${reexport_libraries}
    ${LIBYAML_LIBRARIES}
    ${READLINE_LIBRARIES}
    ${ICONV_LIBRARIES}
    ${OPENSSL_LIBRARIES}
)

if (TARGET_OS_LINUX OR TARGET_OS_DEBIAN_FREEBSD)
    set (common_libraries ${common_libraries} dl rt)
endif()

if (TARGET_OS_FREEBSD AND NOT TARGET_OS_DEBIAN_FREEBSD)
    find_library (INTL intl)
    if (NOT INTL)
        message(FATAL_ERROR "intl library not found")
    else()
        set (common_libraries ${common_libraries} ${INTL})
    endif()
endif()

set (common_libraries ${common_libraries} ${LIBUUID_LIBRARIES})
set (common_libraries ${common_libraries} PARENT_SCOPE)

add_subdirectory(lib)
add_subdirectory(box)

# Save CMAKE_XXX_FLAGS from this directory for config.h (used in --version)
set(TARANTOOL_C_FLAGS ${CMAKE_C_FLAGS} PARENT_SCOPE)
set(TARANTOOL_CXX_FLAGS ${CMAKE_CXX_FLAGS} PARENT_SCOPE)

set(EXPORT_LIST)
if(BUILD_STATIC)
    # for each static library we should find a corresponding shared library to
    # parse and reexport library api functions
    foreach(libstatic
            ${READLINE_LIBRARIES}
            ${CURL_LIBRARIES}
            ${OPENSSL_LIBRARIES}
            ${ICU_LIBRARIES})
        if (${libstatic} MATCHES "lib[^/]+.a")
            string(REGEX MATCH "lib[^/]+.a" libname ${libstatic})
            string(REGEX REPLACE "\\.a$" "" libname ${libname})
            string(REGEX REPLACE "^lib" "" libname ${libname})
            find_library(SYMBOLS_LIB NAMES ${libname})
            # add found library to export list
            list(APPEND EXPORT_LIST ${SYMBOLS_LIB})
            # set variable to allow rescan (CMake depended)
            set(SYMBOLS_LIB "SYMBOLS_LIB-NOTFOUND")
        elseif (${libstatic} STREQUAL bundled-libcurl OR
                ${libstatic} STREQUAL bundled-ares)
            message("We don't need to export symbols from statically linked ${libstatic}, skipped")
        else()
            message(WARNING "${libstatic} should be a static")
        endif()
    endforeach(libstatic)
    string(REPLACE ";" " " EXPORT_LIST "${EXPORT_LIST}")

    if (HAVE_OPENMP)
        # Link libgomp explicitly to make it static. Avoid linking
        # against DSO version of libgomp, which implied by -fopenmp
        set (common_libraries ${common_libraries} "libgomp.a")
        set(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} -fno-openmp")
    endif()
endif()

set(exports_file_sources ${CMAKE_SOURCE_DIR}/extra/exports)
if (EXPORT_LIBCURL_SYMBOLS)
    set(exports_file_sources ${exports_file_sources}
        ${CMAKE_SOURCE_DIR}/extra/exports_libcurl)
endif()
string(REPLACE ";" " " exports_file_sources "${exports_file_sources}")

# Exports syntax is toolchain-dependent, preprocessing is necessary
set(exports_file ${CMAKE_BINARY_DIR}/extra/exports.${CMAKE_SYSTEM_NAME})
add_custom_target(preprocess_exports
                  DEPENDS ${exports_file})
add_custom_command(
    OUTPUT  ${exports_file}
    DEPENDS ${CMAKE_SOURCE_DIR}/extra/exports
    COMMAND ${CMAKE_SOURCE_DIR}/extra/mkexports
            ${exports_file_sources}
            ${exports_file} ${CMAKE_SYSTEM_NAME}
            ${EXPORT_LIST}
)

add_executable(
    tarantool main.cc
    ${LIBUTIL_FREEBSD_SRC}/flopen.c
    ${LIBUTIL_FREEBSD_SRC}/pidfile.c)

add_dependencies(tarantool build_bundled_libs preprocess_exports)

# Re-link if exports changed
set_target_properties(tarantool PROPERTIES LINK_DEPENDS ${exports_file})

# A note about linkers:
# [GNU linker] When linking an *executable* visibility is ignored, and
#              either nothing is exported (default), or any non-static
#              symbol is exported (-rdynamic), or explicitly listed
#              symbols are exported (--dynamic-list).
#
#              However, if a symbol listed lives in a static library it
#              won't be automatically pulled, hence --whole-archive
#              option.
#
# [Apple linker] One can provide an explicit export list; pulls symbols
#                from static libraries.
#
if (TARGET_OS_DARWIN)
    target_link_libraries(tarantool box ${common_libraries})
    set_target_properties(tarantool PROPERTIES
        LINK_FLAGS "-Wl,-exported_symbols_list,${exports_file}")
else ()
    target_link_libraries(tarantool
                          -Wl,--whole-archive box ${reexport_libraries}
                          salad -Wl,--no-whole-archive
                          ${common_libraries}
                          ${generic_libraries})
    set_target_properties(tarantool PROPERTIES
        LINK_FLAGS "-Wl,--dynamic-list,${exports_file}")
    # get rid of -rdynamic
    set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "")
endif()

install (TARGETS tarantool DESTINATION bin)
